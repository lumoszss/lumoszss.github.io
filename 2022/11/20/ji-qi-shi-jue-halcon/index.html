<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Halcon机器视觉, Lumos">
    <meta name="description" content="Halcon机器视觉
编程方式

在HDevelop 编写算法部分

使用C++ 或 C# 开发应用程序

从HDevelop 导出算法代码并集成到应用程序中



视觉处理的常用框架

采集图像
预处理（中值滤波、均值滤波、高斯滤波、灰度">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Halcon机器视觉 | Lumos</title>
    <link rel="icon" type="image/jpeg" href="/favicon.jpg">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/mylogo.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Lumos</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/mylogo.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">Lumos</div>
        <div class="logo-desc">
            
            未到终局，焉知生死
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/lumoszss" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/lumoszss" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Halcon机器视觉</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/">
                                <span class="chip bg-color">机器视觉</span>
                            </a>
                        
                            <a href="/tags/Halcon/">
                                <span class="chip bg-color">Halcon</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" class="post-category">
                                图像处理
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-11-20
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Halcon机器视觉"><a href="#Halcon机器视觉" class="headerlink" title="Halcon机器视觉"></a>Halcon机器视觉</h1><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/什么是HALCON.jpg" style="zoom:50%;"></p>
<p><strong>编程方式</strong></p>
<ol>
<li><p>在HDevelop 编写算法部分</p>
</li>
<li><p>使用C++ 或 C# 开发应用程序</p>
</li>
<li><p>从HDevelop 导出算法代码并集成到应用程序中</p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/解决方案.jpg" style="zoom:50%;"></p>
</li>
</ol>
<p><strong>视觉处理的常用框架</strong></p>
<ol>
<li>采集图像</li>
<li>预处理（中值滤波、均值滤波、高斯滤波、灰度变换、gray_range_rect等）</li>
<li>特征处理 (select_shape)</li>
<li>训练识别 (深度学习)</li>
<li>显示</li>
</ol>
<p><strong>快捷键</strong></p>
<ul>
<li>打开帮助窗口：F1</li>
<li>注释：F4</li>
<li>激活：F3</li>
<li>运行：F5</li>
<li>直接运行一个语句：Shift + 回车</li>
<li>打开算子窗口：Ctrl + Shift + 空格</li>
</ul>
<h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><ol>
<li><p>窗口：图形窗口、变量窗口 (<strong>Iconic</strong>、<strong>Control</strong>、<strong>Tuple</strong>)、算子窗口、程序窗口</p>
<ul>
<li><p>图像变量: Iconic (image , region, XLD)</p>
<ul>
<li><p>Region是图像处理里面的一大对象，该对象描述图像中的区域。图像可通过threshold（阈值分割）算子转换成区域，也可以手动画ROI （感兴趣区域）来定义区域。手动ROI跟阈值分割转换区域是不同的，前者基于窗口，后者基于像素灰度值</p>
</li>
<li><p>XLD，亚像素精度轮廓，指图像中某一块区域的轮廓，在 HALCON 中查看 XLD 的特征步骤与查看 Region 特征的步骤相似。点击工具栏中的特征检测选择XLD , 在图形窗口选择要查看的 XLD 特征，可看到 XLD 的特征属性及其相对应的数值</p>
</li>
</ul>
</li>
<li><p>控制类变量：Control (string, integer, real, handle)</p>
</li>
<li><p>注意：输入、输出数据严格分开，<strong>算子不会改变输入数据</strong></p>
</li>
<li><p>固定的参数顺序：Input Iconic —&gt; Output Iconic —&gt; Input Control  —&gt; Output Control </p>
<p><code>operator(Input iconic: Output iconic: Input control: Output control)</code></p>
</li>
</ul>
</li>
<li><p>HALCON自带图片素材位置：<code>C:\Users\Public\Documents\MVTec\HALCON-19.11-Progress\examples\images</code></p>
</li>
<li><p>打开一个窗口，获得窗口句柄</p>
<pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">dev_close_window()
dev_open_window (0, 0, 512, 512, 'black', WindowHandle)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>读取图像</p>
<pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">第一种方式
直接打开具体的图像：文件 ---&gt; 读取图像
或者
按住CTRL+R 打开读取图像对话窗口，在文件名称一栏中选择图像所在的文件路径，在语句插入位置点击确定，即可获得图像

第二种方式：使用代码
read_image(imgName,path) 打开图像
dev_display(imgName) 在图形窗口显示图像
选择可视化 ---&gt; 更新窗口 ---&gt; 总是 自动显示图像不需要上述的语句

可以一次读取多张图像
read_images(imgs,[path1,path2,...])
使用算子 select_obj 选择某一张图像

第三种方式
助手 —&gt; 打开新的 Image Acquisition —&gt; 资源：选择文件 (选择具体的图像，同第一种)

第四种方式
助手 —&gt; 打开新的 Image Acquisition —&gt; 资源：选择路径 (选择图像所在的文件夹) ---&gt; 代码生成：点击插入代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>使用设备采集图像：</strong>助手 —&gt; 打开新的 Image Acquisition —&gt; 资源：自动检测接口 (相机自带的库、DirectShow) —&gt; 连接：颜色空间 (灰度采集、RGB采集) —&gt; 点击连接 —&gt; 点击实时 (实时采集) —&gt;  代码生成：采集模式 (异步采集) —&gt; 点击插入代码 (自动生成代码)</p>
<ul>
<li>相机主存 —&gt; 采集卡存储器 —&gt; 上位机内存</li>
<li>异步读取：图像从采集设备获取，非实时，取像与处理并行，对图像处理时间把控比较严</li>
<li>同步读取：通过相机取像，实时，取像与处理是串行的，取像周期长。</li>
</ul>
</li>
<li><p>查看图像/区域某一点的灰度值/坐标：Ctrl+鼠标定位</p>
</li>
<li><p>图像通道：在HALCON 中，把鼠标移动到 HALCON 变量窗口中的图像变量上会显示图像变量的类型、通道及尺寸</p>
<pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">read_image (Image, 'D:/picture/ship.png')
* 计算图像通道
count_channels(Image,Num)
* 循环读取每个通道的图像
for I := 1 to Num by 1
* 获取多通道指定图像
	access_channel (Image, channel1, I)
endfor
* 分解通道
decompose3 (Image, RedImage, GreenImage, BlueImage)
* 合并通道
compose2 (RedImage, GreenImage, MultiChannelImage)
* 向图像附加通道
append_channel (MultiChannelImage, BlueImage, ImageExtended)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>保存图像</p>
<pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">read_image(Image, 'printer_chip/printer_chip_01')

* 保存图像变量
write_image (Image, 'tiff', 0, 'D://Tmp1')

*  dump_window_image 在图像对象中写入窗口内容。
dump_window_image( Image , WindowHandle)   //图像名，窗口句柄
write_image( Image , 'tiff', 0, 'D://Tmp1 )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="Tuple及控制语句"><a href="#Tuple及控制语句" class="headerlink" title="Tuple及控制语句"></a>Tuple及控制语句</h2><div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>符号</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>赋值运算符</td>
<td><code>:=</code></td>
<td>a := [2,4,6]</td>
</tr>
<tr>
<td>算数运算符</td>
<td><code>+</code>  <code>-</code>  <code>*</code>  <code>/</code>  <code>%</code></td>
<td>a1 % a2</td>
</tr>
<tr>
<td>按位左移</td>
<td><code>lsh</code></td>
<td>lsh (i1,i2)</td>
</tr>
<tr>
<td>按位右移</td>
<td><code>rsh</code></td>
<td>rsh (i1,i2)</td>
</tr>
<tr>
<td>按位与/或/异或</td>
<td><code>band</code> <code>bor</code> <code>bxor</code></td>
<td>i1 band/bor/bxor i2</td>
</tr>
<tr>
<td>按位非</td>
<td><code>bont</code></td>
<td>bnot i</td>
</tr>
<tr>
<td>比较运算符</td>
<td><code>&gt;</code> <code>&lt;</code>  <code>&gt;=</code>  <code>&lt;=</code> <code>=或==(等于)</code> <code>#(不等于)</code></td>
<td>t1 # t2 (不等于)</td>
</tr>
<tr>
<td>布尔运算符</td>
<td><code>and</code> <code>or</code> <code>not</code> <code>xor(异或)</code></td>
<td>not b</td>
</tr>
</tbody>
</table>
</div>
<p><strong>基本操作</strong></p>
<pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">a := 1  //  1
a[1] := 2  // [1, 2]
a[3] := 3  // [1,2,0,3]
a := [a,[4, 5, 6]] // [1,2,0,3,4,5,6]
len := |a| // 7 获取元组的长度 
a := [4:len-1] // [4,5,6]获取索引从4到len-1的元素
b := subset(a,0) // 4 选取索引为0的元素
a := remove(a,0)  // [5,6] 移除a中索引为0的元素
i := find(a,b) // -1 在a中查找b的位置并返回，找不到返回-1
a := [a,6]  // [5,6,6]
a := uniq(a)  // [5,6] 元组中相邻两个元素相同时只保留一个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>算子和数字函数</strong></p>
<pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">tuple_gen_const( : : Length, Const : Newtuple)
* 创建一个长度为 Length ，元素为 Const 的元组 Newtuple。
tuple_gen_const (5, 1, Newtuple)  
* Newtuple结果为 [1, 1, 1, 1, 1]

tuple_gen_sequence( : : Start, End, Step : Sequence)
* 创建一个从 Start 开始，以 Step 为步长 的等差元组 Sequence。
tuple_gen_sequence (1, 9, 2, Sequence)
* Sequence结果为 [1, 3, 5, 7, 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">min(t)  // 最小元素
max(t)  // 最大元素
min2(t1,t2) // 两个元组里面选小的
max2(t1,t2)  //  两个元组里面选大的
sum(t)  // 返回元素所有元素的和
mean(a)  // 返回平均值
deviation(a) // 返回标准差
cumul(a)  // 计算元组的累计和
median(a)  // 返回中值
select_rank(a,i) // 先对元组排序，然后选择排序后元组中索引号为i的元素
sqrt(a)  // 平方根
real(a)  // 整型转实数型
int(a)  // 取整
round(a) //  四舍五入得到整数
abs(a)  //  绝对值
fabs(a)  //  绝对值（浮点数）
ceil(a)  //  向上取整
floor(a) // 向下取整
fmod(a1,a2) // 计算 a1/a2 的余数
sgn(a)  // 计算元组的正负<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>字符数组的格式化</strong></p>
<pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">a:= 3.1415926
 
*取整
int_a   := int(a)    //取整数部分，结果是3
round_a := round(a)  //将输入元组转换为最接近的整数元组，结果是3
a1 := number(a$'.1f')  //number()是将数字字符串转为数字，结果是3.1
 
*四舍五入，结果是字符串
g0 := a$'.0f'  // '3' 保留0位 
g1 := a$'.1f'  // '3.1' 保留1位
g2 := a$'.2f'  // '3.14' 保留2位
 
*如果用算子的方式实现，则如下：
tuple_string (a, '.1f', String)  //String等于'3.5'
tuple_number (String, Number)    //Number等于3.5
 
*数字转化为字符串直接加''即可
string_a := a + ''  //结果是'3.456'
 
*保留N个有效数字，结果是字符串
y  := 2018.11
y1 := y$'.1'  //保留1位有效数字，结果是'2e+003'
y2 := y$'.2'  //保留2位有效数字，结果是'2e+003'
y3 := y$'.3'  //保留3位有效数字，结果是'2.02e+003'
y4 := y$'.4'  //保留4位有效数字，结果是'2018'
y5 := y$'.5'  //保留5位有效数字，结果是'2018.1'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>控制语句</strong></p>
<pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">* if 分支
if(表达式)
	...
elseif
	...
else
	...
endif

* switch分支
switch (Index)
case 1:
    break
case 2:
    break
default:
    break
endswitch

* for 循环
for(index:=StartNumber to EndNumber by step)
	循环体
endfor
*index是循环的变量；StartNumber是开始的数值；EndNumber是结束的数值；step是步长

* while 循环
while(条件)
    循环语句
endwhile

* repeat...until
repeat
    循环语句
until(条件)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="阈值化处理"><a href="#阈值化处理" class="headerlink" title="阈值化处理"></a>阈值化处理</h2><p><strong>阈值化处理</strong>：得到变量结果是一个区域</p>
<ol>
<li>工具：灰度直方图（在工具栏中选择）</li>
<li>勾选阈值前的方框 </li>
<li>调整区域</li>
<li><p>插入代码：<code>threshold (GrayImage, Regions, min, max)</code></p>
<pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">* 读取图像
read_image(Image,'claudia')
dev_display(Image)
* RGB图像转为灰度图像
rgb1_to_gray(Image,GrayImage)
dev_display(GrayImage)
* 选择合适的灰度范围
* 依据灰度直方图确定参数
threshold(GrayImage, Region, 0, 71)
* 划分区域
connection(Region,ConnectedRegions)
* 选取面积最大的区域
* 依据特征直方图确定参数
select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 46071.4, 46468.3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="腐蚀与膨胀"><a href="#腐蚀与膨胀" class="headerlink" title="腐蚀与膨胀"></a>腐蚀与膨胀</h2></li>
</ol>
<ul>
<li>膨胀算法：<ul>
<li>扫描原图，找到第一个像素值为0的背景点；</li>
<li>将预先设定好形状以及原点位置的结构元素的原点移到该点；</li>
<li>判断该结构元素所覆盖的像素值是否存在为1的目标点：    </li>
<li>如果是，则膨胀后图像中的相同位置上的像素值为1；  </li>
<li>如果不是，则膨胀后图像中的相同位置上的像素值为0；</li>
<li>重复2）和3），直到所有原图中像素处理完成。</li>
</ul>
</li>
<li>腐蚀算法：<ul>
<li>扫描原图，找到第一个像素值为1的目标点；</li>
<li>将预先设定好形状以及原点位置的结构元素的原点移到该点；</li>
<li>判断该结构元素所覆盖的像素值是否全部为1：      </li>
<li>如果是，则腐蚀后图像中的相同位置上的像素值为1；      </li>
<li>如果不是，则腐蚀后图像中的相同位置上的像素值为0；</li>
<li>重复2）和3），直到所有原图中像素处理完成</li>
</ul>
</li>
</ul>
<h2 id="ROI-Region-Of-Interest-生成"><a href="#ROI-Region-Of-Interest-生成" class="headerlink" title="ROI (Region Of Interest) 生成"></a>ROI (Region Of Interest) 生成</h2><ul>
<li>感兴趣区域，即ROI 。ROI 就是从被处理的图像以方框、圆、椭圆、不规则多边形等方式勾勒出需要处理的区域，这个区域是图像分析所关注的重点。使用ROI可以减少计算量，加快图像处理速度，提高效率</li>
<li><p>选择ROI 的步骤 </p>
<ul>
<li>选择关注区域：在采集到原始图像后，即可通过图像处理得出特定区域，常规的有矩形、圆形以及椭<br>圆。此时，选择的区域还不能称为 ROI, 它还只是形状或者说是像素范围。</li>
<li>裁剪区域：如果要将这选择的区域变成独立的图像，还需要将其从原图上裁剪出来。在<br>Halcon 中可以通过 reduce_domain 算子将其截取出来成为单独的一幅图片。</li>
</ul>
<p>示例：</p>
<pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">read_image(Image,'claudia')
* 获取图像的尺寸
get_image_size (Image, Width, Height)
* 获取窗口句柄
dev_open_window(0, 0, Width, Height, 'black', WindowHandle)
dev_display(Image)
* 左上角坐标(50,100)，右下角坐标(120,250)
* gen_rectangle1(Rectangle, 50, 100, 120, 250) 
* 裁剪出感兴趣区域
* reduce_domain(Image, Rectangle, ImageReduced)
* 交互式算子
* 画一个长方形
* draw_rectangle1(WindowHandle, Row1, Column1, Row2, Column2)
* gen_rectangle1(Rectangle, Row1, Column1, Row2, Column2) 
* 画一个圆
* 圆心坐标(Row, Column) 半径Radius
draw_circle(WindowHandle, Row, Column, Radius)
gen_circle(Circle, Row, Column, Radius)

* 裁剪出感兴趣区域
reduce_domain(Image, Circle, ImageReduced)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>也可以使用工具生成一个ROI </p>
</li>
</ul>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/ROI生成.jpg" style="zoom:70%;"></p>
<h2 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h2><p><strong>图像的平移旋转和缩放</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">变换</th>
<th style="text-align:center">算子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">平移</td>
<td style="text-align:center">hom_mat2d_translate(: HomMat2D, Tx, Ty: HomMat2DTranslate)</td>
</tr>
<tr>
<td style="text-align:center">旋转</td>
<td style="text-align:center">hom_mat2d_rotate(: : HomMat2D, Phi, Px, Py : HomMat2DRotate)</td>
</tr>
<tr>
<td style="text-align:center">缩放</td>
<td style="text-align:center">hom_mat2d_scale(: : HomMat2D, Sx, Sy, Px, Py : HomMat2DScale)</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Halcon中仿射变换相关算子</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">算子</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">hom_mat2d_identity(: : HomMat2DIdentity)</td>
<td style="text-align:center">创建一个仿射变换单位矩阵</td>
</tr>
<tr>
<td style="text-align:center">hom_mat2d_translate(: : HomMat2D, Tx, Ty: HomMat2DTranslate)</td>
<td style="text-align:center">设置平移参数</td>
</tr>
<tr>
<td style="text-align:center">hom_mat2d_rotate(: : HomMat2D, Phi, Px, Py : HomMat2DRotate)</td>
<td style="text-align:center">设置旋转参数</td>
</tr>
<tr>
<td style="text-align:center">hom_mat2d_scale(: : HomMat2D, Sx , Sy, Px, Py : HomMat2DScale)</td>
<td style="text-align:center">设置缩放参数</td>
</tr>
<tr>
<td style="text-align:center">affine_trans_image(Image : ImageAffinTrans : HomMat2D, Interpolation, AdaptlmageSize:)</td>
<td style="text-align:center">进行仿射变换</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">read_image (Image, 'a01.png')
* 获得图像尺寸，打开窗口，读取图片
get_image_size (Image, Width, Height)
dev_open_window (0, 0, Width, Height, 'black', WindowID)
dev_display (Image)
* 转灰度图像
rgb1_to_gray(Image, GrayImage)
* 图像二值化
threshold (Image, Regions, 164, 245)
* 获取图像面积，中心点坐标
area_center(Regions, Area, Row, Column)
* 定义仿射变换矩阵
hom_mat2d_identity (HomMat2DIdentity)
* 设置平移矩阵至中心点坐标
hom_mat2d_translate (HomMat2DIdentity, Height/2-Row, Width/2-Column, HomMat2DTranslate)
* 通过仿射变换将图形移至中心点位置并显示图像
affine_trans_image(GrayImage, ImageAffinTrans , HomMat2DTranslate, 'constant', 'false')
dev_display(ImageAffinTrans)
* 旋转变换
* (Height/2, Width/2)为基准点
hom_mat2d_rotate (HomMat2DTranslate, 3.14/2, Height/2, Width/2, HomMat2DRotate)
affine_trans_image (ImageAffinTrans, ImageAffineTrans1, HomMat2DRotate, 'constant', 'false')
dev_display (ImageAffineTrans1)
* 设置等比例缩放矩阵，缩放倍数为 1.5 倍
hom_mat2d_scale(HomMat2DIdentity, 1.5, 1.5, Height/2, Width/2, HomMat2DScale)
affine_trans_image (ImageAffineTrans1, ImageAffineTrans2, HomMat2DScale, 'constant', 'false')
dev_display (ImageAffineTrans2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p><code>hom_mat2d_rotate</code>参数</p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/仿射变换_旋转算子.png" alt=""></p>
</li>
<li><p><code>hom_mat2d_scale</code>换参数</p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/仿射变换_缩放算子.png" alt=""></p>
</li>
</ul>
<p>点$(P_x,P_y)$是转换的固定点，也就是说，这个点在进行转换时保持不变。首先在输入的变换矩阵中加入一个平移，将固定点移到全局坐标系的原点上。然后，加入变换，最后加入一个平移，将固定点移回其原始位置。</p>
<p><strong>投影变换</strong></p>
<ul>
<li><p><code>hom_vector_to_proj_hom_mat2d( : : Px, Py, Pw, Qx, Qy, Qw, Method : HomMat2D)</code></p>
<ul>
<li>得到变换矩阵HomMat2D</li>
</ul>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/投影变换算子.jpg" style="zoom:67%;"></p>
<ul>
<li>其中</li>
</ul>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/投影算子.png" alt="投影算子" style="zoom: 50%;"></p>
</li>
</ul>
<ul>
<li><p><code>projective_trans_image(Image : TransImage : HomMat2D, Interpolation, AdaptImageSize, TransformDomain : )</code></p>
<ul>
<li><p>进行投影变换</p>
</li>
<li><p>Interpolation：图像的插值方式</p>
</li>
</ul>
</li>
<li><p>插值算法：</p>
<ul>
<li><p>对图像进行 平移，旋转，缩放 等变换后，元素可能变成非整数，那么此时需要将这些非整数转为整数输出。</p>
</li>
<li><p>最近邻插值：选取离目标点最近的点的灰度值作为新的插入点的灰度值</p>
</li>
<li><p>线性插值</p>
</li>
<li><p>双线性插值：选取最近的四个像素点做三次线性插值</p>
</li>
<li><p>双三次插值：在双三次插值法中，选取最近的16 个像素点计算目标图像处像素值</p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/插值算法.jpg" style="zoom:67%;"></p>
</li>
</ul>
</li>
</ul>
<p>示例：</p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/投影变换.png" style="zoom: 50%;"></p>
<pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">read_image (Image, '4-3.jpg')
* 打开适合图片的窗口
dev_open_window_fit_image (Image, 0, 0, -1, -1, WindowHandle)
dev_display (Image)

* 设置输出颜色为红色
dev_set_color ('red') 
* 定义输出线宽为2
dev_set_line_width(2)
stop()

* 定义坐标变量
X := [163, 280, 362, 75]
Y := [125, 120, 361, 340]
* 为每个输入点生成十字形状的 XLD 轮廓
* 6代表组成十字横线的长度，0.78 代表角度
gen_cross_contour_xld(Crosses, X, Y, 6, 0.78)
dev_display (Crosses)
* 得到单应性矩阵
hom_vector_to_proj_hom_mat2d (X, Y, [1,1,1,1], [75,360,360,75], [110,110,360,360], [1,1,1,1], 'normalized_dlt', HomMat2D)
* 进行投影变换
projective_trans_image(Image, Image_rectified , HomMat2D , 'bilinear', 'false','false')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h2><h3 id="灰度变换算子"><a href="#灰度变换算子" class="headerlink" title="灰度变换算子"></a>灰度变换算子</h3><ol>
<li><p>图像取反算子：<code>invert_image (Image : ImageInvert : :)</code></p>
<ul>
<li>$g’ := 255 - g$</li>
</ul>
</li>
<li><p>增加图像对比度算子：<code>emphasize(Image : ImageEmphasize : MaskWidth, MaskHeight, Factor : )</code></p>
<ul>
<li>$res := round((orig - mean)* Factor) + orig$</li>
<li>maskwidth 低通掩膜宽，maskheight 低通掩膜高</li>
<li>掩膜：用选定的图像，图形或物体，对处理的图像（全部或局部）进行遮挡，来控制图像处理的区域或处理过程。用于覆盖的特定图像或物体称为掩模或模板。掩模是由0和1组成的一个二进制图像。</li>
</ul>
</li>
<li><p>缩放图像的灰度：<code>scale_image(Image : ImageScaled : Mult, Add : )</code></p>
<ul>
<li><p>$g’ := g * Mult + Add$</p>
</li>
<li><p>[GMin, GMax]  $\Rightarrow$ [0,255]</p>
<ul>
<li>$Mult = \frac{255}{\text{GMax} - \text{GMin}}$, $Add = - Mult * \text{GMin}$</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-Halcon" data-language="Halcon"><code class="language-Halcon">read_image (Image, 'claudia')
get_image_size (Image, Width, Height)
rgb1_to_gray (Image, GrayImage)
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
* dev_display (GrayImage)
* 图像取反
invert_image (GrayImage, ImageInvert)
dev_display (ImageInvert)
* 对比度增强
emphasize (GrayImage, ImageEmphasize, Width, Height, 2)
dev_display (ImageEmphasize)
* 图像灰度缩放
scale_image (GrayImage, ImageScaled, 0.5, 50)
dev_display (ImageScaled)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>直方图修正算子</strong></p>
<p>直方图均衡化：<code>equ_histo_image(GrayImage , ImageEquHisto)</code></p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/直方图均衡化.png" style="zoom:70%;"></p>
<p>直方图规定化是使原图像灰度直方图变成规定形状的直方图 而对图像作修正的增强方法，以满足特定的效果。直方图均衡化处理只是直方图规定化的一个特例。</p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/直方图规定化.jpg" style="zoom:80%;"></p>
<h3 id="图像的平滑"><a href="#图像的平滑" class="headerlink" title="图像的平滑"></a>图像的平滑</h3><p><strong>噪声</strong></p>
<ol>
<li><p>高斯噪声</p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/高斯噪声.png" style="zoom:70%;"></p>
<ul>
<li><code>gauss_distribution( : : Sigma : Distribution)</code></li>
<li><code>add_noise_distribution(Image : ImageNoise : Distribution : )</code></li>
</ul>
</li>
<li><p>椒盐噪声</p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/椒盐噪声.png" style="zoom:70%;"></p>
<ul>
<li><code>sp_distribution( : : PercentSalt, PercentPepper : Distribution)</code></li>
<li><code>add_noise_distribution(Image : ImageNoise : Distribution : )</code></li>
</ul>
</li>
</ol>
<p><strong>均值滤波</strong></p>
<p>图像邻域平均法算法简单，计算速度快但它的主要缺点是在降低噪声的同时使图像产生模糊，特别在边缘和细节处。<br>图像所用的邻域半径越大，则图像的模糊程度越大。</p>
<ul>
<li><p><code>mean_image(Image : ImageMean : MaskWidth, MaskHeight : )</code></p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/均值滤波.png" style="zoom:60%;"></p>
</li>
</ul>
<p><strong>中值滤波</strong></p>
<ul>
<li><code>median_image(Image : ImageMedian : MaskType, Radius, Margin : )</code><ul>
<li>MaskType: 掩膜类型，Radius: 掩膜尺寸</li>
<li>Margin: 边界处理</li>
</ul>
</li>
</ul>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/中值滤波.png" style="zoom:60%;"></p>
<p><strong>多图像平均法</strong></p>
<ul>
<li>$g(x,y) = f(x,y) + e(x,y)$</li>
<li>$\bar{g}(x,y) = \frac{1}{M} \sum_{i=1}^{M}g_{i}(x,y)$</li>
</ul>
<h3 id="图像锐化"><a href="#图像锐化" class="headerlink" title="图像锐化"></a>图像锐化</h3><ul>
<li>在图像的识别中常需要突出边缘和轮廓信息</li>
<li>图像锐化就是增强图像的边缘或轮廓</li>
</ul>
<p>图像细节的灰度变化特性</p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/图像细节的灰度变化特性.jpg" style="zoom:90%;"></p>
<ul>
<li>因为边缘和轮廓都位于灰度突变的地方 , 所以锐化算法的实现是基于微分作用。<script type="math/tex; mode=display">
\bigtriangledown f(x,y)=\begin{bmatrix}  G_x\\  G_y\end{bmatrix}=\begin{bmatrix}  \frac{\partial f}{\partial x} \\  \frac{\partial f}{\partial y} \end{bmatrix} \ (f(x,y)\text{的梯度})\\
\left | \bigtriangledown f(x,y) \right | = mag(\bigtriangledown f)=\sqrt{G_x^{2}+G_y^{2}}=\sqrt{\left ( \frac{\partial f}{\partial x}  \right )^2+ \left ( \frac{\partial f}{\partial y}  \right )^2} \  (\text{边缘的强度}) \\
\alpha (x,y)=\arctan\left ( \frac{G_y}{G_x}  \right ) \  (\text{边缘的趋势 梯度方向始终垂直于边缘方向}) \\
G_x = f(i+1,j) - f(i,j) \ \ 
G_y = f(i,j+1) - f(i,j) \ (\text{
相邻像素间插值为1})
水平垂直差分法</script></li>
</ul>
<p><strong>水平垂直差分法</strong></p>
<ul>
<li>用小区域模板卷积来近似计算偏导数</li>
<li>对$G_x$和$G_y$各用1个模板</li>
<li>需要2个模板组合起来构成1个梯度算子</li>
</ul>
<script type="math/tex; mode=display">
G_x = \begin{bmatrix}  1 & -1\\            0 & 0\end{bmatrix} \ \ \ 
G_y = \begin{bmatrix}  1 & 0\\            -1 & 0\end{bmatrix}</script><p><strong>Roberts梯度</strong></p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/梯度差分.png" style="zoom: 50%;"></p>
<script type="math/tex; mode=display">
\left | \bigtriangledown f(x,y) \right | = \left | f(i+1,j+1) - f(i,j) \right | + \left | f(i+1,j) - f(i,j+1) \right | \\

G_x = \begin{bmatrix}  -1 & 0\\            0 & 1\end{bmatrix} \ \ \ 
G_y = \begin{bmatrix}  0 & -1\\            1 & 0\end{bmatrix}</script><p><strong>Sobel算子</strong></p>
<ul>
<li><p>采用梯度微分锐化图像同时会使噪声、条纹等得到增强，Sobel 算子则在一定程度上克服了这个问题</p>
</li>
<li><p>锐化的边缘信息较强</p>
</li>
</ul>
<script type="math/tex; mode=display">
A = \begin{bmatrix}  1 & 2 & 1\\ 
0 & 0 & 0 \\ -1 & -2 & -1\end{bmatrix} \ \ \ \ B = \begin{bmatrix}  1 & 0 & -1\\ 
2 & 0 & -2 \\ 1 & 0 & -1\end{bmatrix}</script><ul>
<li><p><code>sobel_amp(Image : EdgeAmplitude : FilterType, Size : )</code></p>
<p> <img src="/2022/11/20/ji-qi-shi-jue-halcon/sobel算子参数.png" alt=""></p>
</li>
<li><p>a和b表示用A和B对一个特定像素进行卷积的结果</p>
<p> <img src="/2022/11/20/ji-qi-shi-jue-halcon/sobel算子参数2.png" style="zoom:50%;"></p>
</li>
</ul>
<pre class="line-numbers language-Halcon" data-language="Halcon"><code class="language-Halcon">read_image (Image, 'fabrik')
* 边缘检测
sobel_amp (Image, EdgeAmplitude, 'sum_abs', 3)
* 阈值分割
threshold (EdgeAmplitude, Regions, 15, 255)
* 提取边缘框架
skeleton (Regions, Skeleton)
* 显示图片
dev_display (Image)
* 显示边缘框架
dev_display (Skeleton)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>Laplace算子</strong></p>
<ul>
<li>Sobel 算子获得的边界是比较粗略的边界，反映的边界信息较少，但是所反映的边界比较清晰</li>
<li>Laplace 算子获得的边界是比较细致的边界。反映的边界信息包括了许多的细节信息，但是所反映的边界不是太清晰。</li>
</ul>
<script type="math/tex; mode=display">
\bigtriangledown ^2f=\frac{\partial^{2}f }{\partial x^2}+\frac{\partial^{2}f }{\partial y^2}=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)</script><ul>
<li><p>Laplace掩膜</p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/laplace掩膜.png" style="zoom:50%;"></p>
</li>
<li><p>把原图像和拉普拉斯图像叠加在一起的简单方法可以保护拉普拉斯锐化处理的效果，同时又能复原背景信息。</p>
<script type="math/tex; mode=display">
g(x,y)=f(x,y)+\bigtriangledown ^2f(x,y)</script></li>
<li><p><code>laplace(Image : ImageLaplace : ResultType, MaskSize, FilterMask : )</code></p>
<p> <img src="/2022/11/20/ji-qi-shi-jue-halcon/laplace算子参数1.png" alt=""></p>
<p> <img src="/2022/11/20/ji-qi-shi-jue-halcon/laplace算子参数2.png" style="zoom: 40%;"></p>
</li>
</ul>
<pre class="line-numbers language-Halcon" data-language="Halcon"><code class="language-Halcon">* 获取图像
read_image(Image, 'mreut')
get_image_size (Image, Width, Height)
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
* 对图像进行拉普拉斯算子处理
laplace(Image, ImageLaplace , 'signed',3, 'n_4')
* 显示处理后的图像
dev_display (ImageLaplace)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="频域处理"><a href="#频域处理" class="headerlink" title="频域处理"></a>频域处理</h3><ul>
<li>一幅图像灰度均匀的区域对应低频部分 (频域 — 亮)</li>
<li>图像中的噪声、边缘、细节对应高频部分 (频域 — 暗)</li>
</ul>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/频域处理.jpg" style="zoom: 60%;"></p>
<p>直接对数字图像进行二维 DFT 变换得到的频谱图是高频在中间低频在四角，为了把能量集中起来便于使用滤波器，可以利用二维<br>DFT 的平移性质对频谱进行中心化。</p>
<ul>
<li>$\mathscr{F}(f(x,y)(-1)^{x+y})=F(u-M/2,v-N/2)$</li>
<li>应用于将最亮的位置转移到图像中心</li>
</ul>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/频域处理.png" style="zoom:50%;"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">算子</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">fft_generic(Image : ImageFFT : <strong>‘to_freq’</strong>, Exponent, Norm, Mode, ResultType : )</td>
<td style="text-align:center">进行快速傅里叶变换</td>
</tr>
<tr>
<td style="text-align:center">gen_lowpass( : ImageLowpass : Frequency, Norm, Mode, Width, Height : )</td>
<td style="text-align:center">生成理想的低通滤波模型</td>
</tr>
<tr>
<td style="text-align:center">gen_highpass( : ImageHighpass : Frequency, Norm, Mode, Width, Height : )</td>
<td style="text-align:center">生成理想的高通滤波模型</td>
</tr>
<tr>
<td style="text-align:center">convol_fft(ImageFFT, ImageFilter : ImageConvol : : )</td>
<td style="text-align:center">在频域里卷积图像</td>
</tr>
<tr>
<td style="text-align:center">fft_generic(Image : ImageFFT : <strong>‘from_freq’</strong>, Exponent, Norm, Mode, ResultType : )</td>
<td style="text-align:center">进行快速傅里叶逆变换</td>
</tr>
</tbody>
</table>
</div>
<p><strong>fft_generic(Image : ImageFFT : Direction, Exponent, Norm, Mode, ResultType : )</strong></p>
<ul>
<li>方向参数Direction允许选择FFT的逻辑方向，可能的值是 “to_freq “(正变换)和 “from_freq”(逆变换)</li>
<li>参数Exponent用于确定指数的符号。可以设置为1(逆变换)或-1(正变换)</li>
<li>参数Norm用于设置归一化系数，可以取值为’none’、’sqrt’和’n’</li>
<li>参数Mode用于选择是否进行中心化处理，可以设置为 “dc_center “或 “dc_edge”。</li>
<li>参数ResultType用来指定逆变换( ‘from_freq’)的结果图像类型。在正变换中ResultType必须设置为’complex’</li>
</ul>
<pre class="line-numbers language-Halcon" data-language="Halcon"><code class="language-Halcon">* 低通滤波器示例
* 读取图像 
read_image (Image, 'panada')
* 获取图像大小 
get_image_size (Image, Width, Height)
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
* 显示图像
dev_display (Image)

* 得到低通滤波模型
gen_lowpass (ImageLowpass, 0.1, 'none', 'dc_center', Width, Height)
* 对图像进行傅里叶变换
fft_generic (Image, ImageFFT, 'to_freq', -1, 'sqrt', 'dc_center', 'complex')

* 对频率图像进行低通滤波
convol_fft (ImageFFT, ImageLowpass, ImageConvol)
* 对得到的频率图像进行傅里叶逆变换
fft_generic (ImageConvol, ImageFFT1, 'from_freq', 1, 'sqrt', 'dc_center', 'real')
dev_display (ImageFFT1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>同态滤波增强</strong></p>
<p>同态滤波是把图像的照明反射模型作为频域处理的基础，将<em>亮度范围压缩</em>和<em>对比度增强</em>的频域方法。</p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/同态滤波.jpg" alt=""></p>
<p>同态滤波是改善图像照度不均的一种方法，以便后续进行二值化处理。</p>
<h2 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h2><h3 id="阈值分割"><a href="#阈值分割" class="headerlink" title="阈值分割"></a>阈值分割</h3><p>阈值分割法是一种基于区域的图像分割技术，它不仅可以极大的压缩数据量 ，而且也大大 简化了分析和处理步骤。<br>阈值分割法是一种传统的最常用的图像分割方法，特别适用于目标和背景占据不同灰度级范围的图像。</p>
<p>图像的阈值分割是一种按图像像素灰度幅度进行分割的方法，把图像的灰度分成不同的等级，然后用设置灰度门限（阈值）的方法确定有意义的区域或要分割物体的边界。阈值分割操作被定义为：</p>
<ul>
<li>$S = \{(r,c)\in R|g_{min} \leq f_{r,c} \leq g_{max}\}$</li>
</ul>
<p><strong>根据直方图谷底确定阈值法</strong></p>
<p>如果图像由暗色背景上的较亮物体组成，以这样组成方式的图像的灰度直方图具有明显谷底，从背景中提取物体的一种很明显的方法就是选择两峰之间的谷底对应的灰度值 $T$ 作为阈值进行图像分割。</p>
<script type="math/tex; mode=display">g(x) = \left\{\begin{matrix}
 255,\ f(x,y) \ge T\\
  0 , f(x,y) < T
\end{matrix}\right.</script><p>手动阈值分割算子：<code>threshold(Image : Region : MinGray, MaxGray : )</code></p>
<pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">read_image (Image, 'letters')
get_image_size (Image, Width, Height)
rgb1_to_gray (Image, GrayImage)
dev_close_window ()
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
* 计算图像的灰度直方图
* AbsoluteHisto 绝对灰度直方图
* RelativeHisto 相对灰度直方图 (归一化)
gray_histo (GrayImage, GrayImage, AbsoluteHisto, RelativeHisto)
* 通过直方图得到灰度的阈值
* Sigma高斯平滑的系数
histo_to_thresh (RelativeHisto, 8, MinThresh, MaxThresh)
dev_set_colored(12)
threshold (GrayImage, Region, MinThresh[0], MaxThresh[0])
dev_display (Region)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>基于直方图的自动阈值分割</strong></p>
<ul>
<li>算子：<code>auto_threshold (Image : Regions : Sigma)</code></li>
</ul>
<pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">read_image (Aegypt, 'egypt1')
get_image_size (Aegypt, Width, Height)
dev_close_window ()
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
* 自动阈值分割
auto_threshold (Aegypt, Regions, 4)
dev_display (Regions)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>局部阈值分割</strong></p>
<ul>
<li><p>适用于一些无法用单一灰度进行分割的情况</p>
<ul>
<li>背景灰度比较复杂，有的部分比前景目标亮，有的部分比前景目标暗</li>
<li>前景目标包含多种灰度，因而无法用全局阈值完成分割</li>
</ul>
</li>
<li><p>该算子利用邻域，通过局部灰度对比，找到一个合适的阀值进行分割</p>
</li>
</ul>
<p>算子：<code>dyn_threshold(OrigImage, ThresholdImage : RegionDynThresh : Offset, LightDark : )</code></p>
<ul>
<li><p>dyn_threshold算子的应用步骤一般分三步：</p>
<ol>
<li>读取原始图像；</li>
<li>使用平滑滤波器对原始图像进行适当平滑；</li>
<li>使用 dyn_threshold 算子比较原始图像与均值处理后的图像局部像素差异，将差异大于设定值的点提取出来。</li>
</ol>
</li>
<li><p>dyn_threshold从输入图像中选择那些像素满足阈值条件的区域。</p>
</li>
<li><p><code>g_{o} = g_{OrigImage}</code>，<code>g_{t} = g_{ThresholdImage}</code></p>
<ul>
<li><code>LightDark = 'light'</code>的条件为：$g_0 \ge g_t + offset$ (找到更亮的部分)</li>
<li><code>LightDark = 'dark'</code>的条件为：$g_0 \le g_t - offset$ (找到更暗的部分)</li>
<li><code>LightDark = 'equal'</code>的条件为：$g_t-offset \le g_0 &lt; g_t + offset$</li>
<li><code>LightDark = 'not_equal'</code>的条件为：$g_t-offset &gt; g_0 \vee g_0 &gt; g_t + offset$</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">read_image(Image,  'photometric_stereo/embossed_01')
* 均值滤波
mean_image (Image, ImageMean, 59, 59)
* 局部阈值分割
dyn_threshold (Image, ImageMean, RegionDynThresh, 15, 'not_equal')
dev_display (Image)
dev_display (RegionDynThresh)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h3><ul>
<li>运用一阶微分算子检测边缘：Robert、Sobel、Prewitt、Kirsch</li>
<li>运用二阶微分算子检测边缘：Laplace算子、Log算子、Canny算子</li>
</ul>
<p><strong>Prewitt算子</strong></p>
<script type="math/tex; mode=display">
A = \begin{bmatrix}  -1 & -1 & -1\\ 
0 & 0 & 0 \\ 1 & 1 & 1\end{bmatrix} \ \ \ \ B = \begin{bmatrix}  -1 & 0 & 1\\ 
-1 & 0 & 1 \\ -1 & 0 & 1\end{bmatrix}</script><p>利用像素点上下、左右邻点的灰度差，在边缘处达到极值检测边缘，去掉部分伪边缘，对噪声具有平滑作用</p>
<p>特点：与 Sobel 相比，有一定的抗干扰性。 能抑止噪声的影响， 图像效果比较干净。</p>
<pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">read_image(Image,'fabrik')
* 用Prewitt算子进行边缘提取
prewitt_amp (Image, ImageEdgeAmp)
* 阈值化操作
threshold (ImageEdgeAmp, Region, 20, 255)
* 骨骼化操作
skeleton (Region, Skeleton)
dev_display(Skeleton)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>Kirsch算法</strong></p>
<p>Kirsch算法由$K_0 \sim K_7$八个方向的模板决定，将$K_0 \sim K_7$的模板元素分别与当前像素点的模板区域的像素点相乘，然后选八个值中最大的值作为中央像素的边缘强度。</p>
<script type="math/tex; mode=display">g(x, y)=\max \left(g_{0}, g_{1}, \cdots, g_{T}\right) \quad g_{i}(x, y)=\sum_{k=-1}^{1} \sum_{l=-1}^{1} K_{i}(k, l) f(x+k, y+l)</script><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/Kirsch.jpg" alt=""></p>
<pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">read_image(Image,'fabrik')
kirsch_amp (Image, ImageEdgeAmp)
* 阈值化操作
threshold (ImageEdgeAmp, Region, 70, 255)
* 骨骼化操作
skeleton (Region, Skeleton)
dev_display(Skeleton)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>Log算子</strong></p>
<ul>
<li><p>利用图像强度二阶导数零交叉点求边缘点的算法，对噪声十分敏感</p>
<script type="math/tex; mode=display">
\begin{array}{l}
f(x, y)=s(x, y)+n(x, y)  \ \ \ \ \ n(x)=a \sin (\omega x) \\
\frac{\partial n(x)}{\partial x}=a \omega \cos (\omega x) \ \ \ \frac{\partial^{2} n(x)}{\partial x^{2}}=-a \omega^{2} \sin (\omega x)
\end{array}</script></li>
<li><p>高斯 — 拉普拉斯 (LoG : Laplacianof a Gaussian) 边缘检测算子，先采用高斯算子对原图像进行平滑，然后再施以Laplacian 算子，可克服 Laplacian 算子对噪声敏感的缺点，减少噪声的影响。</p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/Log.jpg" alt=""></p>
</li>
<li><p>高斯函数的优点</p>
<ul>
<li>高斯函数具有旋转对称性 ，用其对图像进行平滑运算时在各个方向上的平滑程度相同 ，边缘检测等操作中不会偏袒某一方向上的图像的细节。</li>
<li>随着离高斯模板中心点越远，权值越小，这使得高斯滤波器比起普通的平滑滤波器更能更好地保留图像细节 。如果距离越远的点权值越重的话，那图像就会失真。</li>
<li>在平滑图像去除噪声和保留图像的信息间找到平衡点。sigma参数越大 ，高斯函数的图谱就越低矮平缓，表现在频谱上就是频带越宽， 平滑程度高；反之sigma参数越小，平滑程度越低 。</li>
<li>二维高斯函数的取值半径（即卷积核大小）越大，平滑程度越高。</li>
</ul>
</li>
<li>减少运算量 — $\frac{d}{d x}(f <em> g)=f </em> \frac{d}{d x} g$</li>
<li>二阶微分</li>
</ul>
<script type="math/tex; mode=display">
\begin{array}{l}
 h(x, y)=\frac{1}{2 \pi \sigma^{2}} e^{-\frac{x^{2}+y^{2}}{2 \sigma^{2}}} \\
\nabla^{2}(h(x, y) * f(x, y))=\nabla^{2} h(x, y)^{*} f(x, y) \\
\nabla^{2} h(x, y)=\frac{\partial^{2} h(x, y)}{\partial x^{2}}+\frac{\partial^{2} h(x, y)}{\partial y^{2}}=\frac{1}{\pi \sigma^{4}}\left(\frac{x^{2}+y^{2}}{2 \sigma^{2}}-1\right) e^{-\frac{x^{2}+y^{2}}{2 \sigma^{2}}}
\end{array}</script><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">read_image (Image, 'mreut')
laplace_of_gauss (Image, ImageLaplace, 5)
zero_crossing (ImageLaplace, RegionCrossing)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>Canny算子</strong></p>
<p>John Canny 于 1986 年提出 Canny 算子，它与 LoG 算子类似，属于先平滑后求导方法。</p>
<p>Canny 边缘检测步骤</p>
<ul>
<li><p>用高斯滤波器平滑图像</p>
<script type="math/tex; mode=display">
g(x, y)=h(x, y ; \sigma) * f(x, y)</script></li>
<li><p>用一阶偏导的有限差分来计算梯度的幅值和方向</p>
<script type="math/tex; mode=display">
\begin{array}{l}
G_{x}(x, y) \approx[g(x+1, y)-g(x, y)+g(x+1, y+1)-g(x, y+1)] / 2 \\
G_{y}(x, y) \approx[g(x, y+1)-g(x, y)+g(x+1, y+1)-g(x+1, y)] / 2
\end{array}</script><p>幅值和方向角</p>
<script type="math/tex; mode=display">
\begin{array}{l}
M(x, y)=\sqrt{G_{x}(x, y)^{2}+G_{y}(x, y)^{2}} \\
\theta(x, y)=\arctan \left\lfloor G_{y}(x, y) / G_{x}(x, y)\right\rfloor
\end{array}</script></li>
</ul>
<ul>
<li><p>对梯度幅值应用非极大值抑制 (Non-maximum sippression, NMS)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45717425/article/details/120641010">https://blog.csdn.net/qq_45717425/article/details/120641010</a></p>
</li>
</ul>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/Non-maximum sippression.jpg" style="zoom: 50%;"></p>
<ul>
<li><p>用双阈值算法检测和连接边缘</p>
<p>将低于阈值的所有值赋零值，得到图像的边缘阵列。阈值$T$的大小对边缘的影响：</p>
<ul>
<li>阈值$T$ 取得太低时，阴影等形成假边缘 ;</li>
<li>阈值$T$ 取得太高时，部分轮廊丢失。</li>
</ul>
<p>选用两个阈值 : 更有效的阈值方案。</p>
<ul>
<li>取高低两个阈值作用在幅值图$M[i,j], \  T_2 = 2 T_1$ ,得到两个边缘图， 高阈值和低阈值边缘图。连接高阈值边缘图，出现断点时，在低阈值边缘图中的 8 邻点域搜寻边缘点。</li>
</ul>
<pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">read_image (Image, 'fabrik')
* 'canny' 使用canny算子, 'nms'非极大值抑制, 12 22 低阈值和高阈值
* ImaAmp, ImaDir：幅值，方向
edges_image (Image, ImaAmp, ImaDir, 'canny', 1, 'nms', 12, 22)
threshold (ImaAmp, Edges, 1, 255)
skeleton (Edges, Skeleton)
* 亚像素轮廓提取
gen_contours_skeleton_xld (Skeleton, Contours, 1, 'filter')
dev_display (Image)
dev_set_colored (6)
dev_display (Contours)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p><strong>其他算子</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">滤波器</th>
<th style="text-align:center">函数</th>
<th style="text-align:center">与滤波系数关系</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sobel</td>
<td style="text-align:center">/</td>
<td style="text-align:center">与滤波系数无关，速度最快，噪声干扰影响较大</td>
</tr>
<tr>
<td style="text-align:center">canny</td>
<td style="text-align:center">$g(x)=\frac{-x}{\sqrt{2 \pi} \sigma^{3}} e^{-x^{2} /\left(2 \sigma^{2}\right)}$</td>
<td style="text-align:center">滤波系数越大，轮廓越平滑</td>
</tr>
<tr>
<td style="text-align:center">deriche1</td>
<td style="text-align:center">$-\alpha^{2} x e^{-\alpha{\lvert x \rvert}}$</td>
<td style="text-align:center">滤波系数越小，轮廓越平滑，与canny相比，该方法更贴近真实轮廓</td>
</tr>
<tr>
<td style="text-align:center">deriche2</td>
<td style="text-align:center">$-2 \alpha \sin (\alpha x) e^{-\alpha{\lvert x \rvert}}$</td>
<td style="text-align:center">滤波系数越小，轮廓越平滑，与deriche1相比，收敛性比较好</td>
</tr>
<tr>
<td style="text-align:center">lanser1</td>
<td style="text-align:center">$-\alpha^{2} x e^{-\alpha{\lvert x \rvert}}$</td>
<td style="text-align:center">滤波系数越小，轮廓越平滑，与deriche相比，该算法是在角度幅值上进行轮廓提取，对角度进行修正</td>
</tr>
<tr>
<td style="text-align:center">lanser2</td>
<td style="text-align:center">$-\alpha^{2} x e^{-\alpha{\lvert x \rvert}}$</td>
<td style="text-align:center">滤波系数越小，轮廓越平滑，与lanser1相比，收敛性比较好</td>
</tr>
<tr>
<td style="text-align:center">shen</td>
<td style="text-align:center">$-\alpha e^{-\alpha{\lvert x \rvert}}$</td>
<td style="text-align:center">滤波系数越小，轮廓越平滑，精度方面比Canny高，精度没有deriche和lanser高，速度比deriche和lanser快</td>
</tr>
</tbody>
</table>
</div>
<p><strong>亚像素级别的边缘提取</strong></p>
<p>点与点之间的最小距离就是一个像素的宽度，但实际工程中可能会需要比一个像素宽<br>度更小的精度，因此就有了亚像素级精度的概念，用于提高分辨率。</p>
<p>Halcon中用 XLD(eXtended Line Descriptions) 表示亚像素的轮廓和多边形。提取<br>亚像素边缘常用的算子如下所示：</p>
<ul>
<li><code>edges_sub_pix (Image:Edges:Filter, Alpha, Low,High:)</code></li>
</ul>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/亚像素边缘提取.jpg" alt=""></p>
<h3 id="区域分割"><a href="#区域分割" class="headerlink" title="区域分割"></a>区域分割</h3><p>将具有相同属性的像素归为同一区域</p>
<p>传统的区域分割方法</p>
<ul>
<li>区域生长法</li>
<li>区域分割与合并法</li>
</ul>
<p><strong>区域生长法</strong></p>
<ul>
<li>首先，选择合适的种子，在图像上选定一个种子像素或者种子区域</li>
<li>然后，确定区域生长准则，从种子的邻域像素开始搜寻，将种子像素周围邻域中与种子像素有相同性质或相似性质的像素根据某种事先确定的生长或相似准则来判断合并到种子像素所在的区域中</li>
<li>最后，确定区域生长的终止条件，进一步将这些新像素作为新的种子像素继续进行上述操作，直到再没有满足条件的像素可被包括进来为止，图像分割随之完成 。</li>
</ul>
<p>Halcon中区域增长的算子</p>
<ul>
<li><p>regiongrowing (Image : Regions : Row, Column, Tolerance, MinSize :)</p>
<p>Row：测试的两个像素点间的垂直距离</p>
<p>Column：测试的两个像素点间的水平距离</p>
</li>
<li><p>regiongrowing_mean (Image : Regions : StartRows, StartColumns, Tolerance, MinSize :)</p>
</li>
</ul>
<p>条件</p>
<ul>
<li>区域边缘的灰度值与当前均值图中对应的灰度值的差小于Tolerance参数的值</li>
<li>区域包含的像素数应大于MinSize参数的值</li>
</ul>
<pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">read_image (Image, 'fabrik')
* 对图像进行均值处理，选用circle类型的中值滤波器
median_image (Image, ImageMedian, 'circle', 2, 'mirrored')
* 使用regiongrowing算子寻找颜色相近的邻域
regiongrowing (ImageMedian, Regions, 1, 1, 2, 5000)
* 对图像进行区域分割，提取满足各个条件的各个独立区域
* skeleton (Regions, Skeleton)
* 提取骨架上距离重心最近的一点
shape_trans (Regions, Centers, 'inner_center')
connection (Centers, SingleCenters)
* 计算出初步提取的区域的中心点坐标
area_center (SingleCenters, Area, Row, Column)
* 以均值灰度图像为输入进行区域增长计算，计算起始坐标为上一步的各区域中心
* Row, Column 种子点
regiongrowing_mean (ImageMedian, RegionsMean, Row, Column, 25, 100)
connection (RegionsMean, ConnectedRegions)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>区域分裂合并法</strong></p>
<ul>
<li>当事先完全不了解区域形状和区域数目时，可采用分裂合并法。</li>
<li>图像阈值分割法可以认为是从上到下对图像进行分割。区域生长法相当于从下往上不断对像素进行合并 。将这两种方法结合起来对图像进行划分，便是分裂合并算法 。</li>
<li><p>先把图像分成任意大小而且不重叠的区域，然后再合并或分裂这些区域以满足分割的要求 。</p>
</li>
<li><p>令$R$表示整幅图像区域，并选择一个属性$Q$。对$R$进行分割的一种方法是依次将它细分为越来越小的四象限区域，以便对于任何区域$R_i$有$Q(R_i) = TRUE$，从整个区域开始，如果$Q(R) = FALSE$，则将该区域再次细分为四个子象限区域，以此类推。</p>
</li>
</ul>
<p>前述讨论可以小结为如下过程：</p>
<ol>
<li><p>对$Q(R_i ) = FALSE$满足的任何区域$R_i$, 分裂为4个不相交的象限区域。</p>
</li>
<li><p>当不可能进一步分裂时，对满足$Q(R_j \cup R_k ) = TRUE$条件的任意两个邻接区域$R_j$和$R_k$进行聚合。</p>
</li>
<li>当无法进一步聚合时，终止算法。</li>
</ol>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/四叉树.png" alt=""></p>
<p>利用四叉树进行图像分割</p>
<ul>
<li>在图像四叉树分割时，需要用到图像区域内和区域间的均一性</li>
<li>均一性准则是区域是否合并的判断条件，可以选择的形式有<ol>
<li>区域中灰度最大值与最小值的方差小于某选定值；</li>
<li>两区域平均灰度之差及方差小于某选定值；</li>
<li>两区域的纹理特征相同；</li>
<li>两区域参数统计检验结果相同；</li>
<li>两区域的灰度分布函数之差小于某选定值。</li>
</ol>
</li>
</ul>
<h3 id="霍夫变换-Hough-Transformation"><a href="#霍夫变换-Hough-Transformation" class="headerlink" title="霍夫变换 (Hough Transformation)"></a>霍夫变换 (Hough Transformation)</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leonardohaig/article/details/87907462">https://blog.csdn.net/leonardohaig/article/details/87907462</a></p>
</li>
<li><p>在实际中由于噪声和光照不均等因素，使得在很多情况下所获得的边缘点是不连续的。</p>
</li>
<li>典型的边缘检测算法遵循用链接过程把像素组装成有意义的边缘的方法。</li>
<li>一种寻找并链接图像中线段的处理方式是 Hough 变换。</li>
</ul>
<p><strong>Hough检测直线</strong></p>
<ul>
<li>==给定图像坐标空间的边缘点，就可以通过Hough变换确定连接这些点的直线方程==</li>
</ul>
<p>直线的极坐标表示</p>
<ul>
<li><p>$\rho = x\cos\theta + y\sin\theta$</p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/hough极坐标系.png" alt=""></p>
</li>
</ul>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/hough.png" style="zoom:50%;"></p>
<ul>
<li>$x-y$图像空间的一条直线，对应于$\rho-\theta$空间中的一点，这种线到点的变换就是Hough变换</li>
<li><p>$x-y$空间的一个特征点$(x_i,y_i)$对应于$\rho-\theta$空间的一条正弦曲线$\rho = x_i\cos\theta + y_i\sin\theta$</p>
</li>
<li><p>$x-y$空间中一条直线上的$n$个点对应于$\rho-\theta$空间中 经过一个公共点的$ n $条曲线；</p>
</li>
<li><p>$ρ - θ $空间中 一条正弦曲线上的$ m $点对应于$ x - y $空间中过一公共点的$ m $条直线。</p>
</li>
</ul>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/hough4.png"></p>
<p><strong>Hough变换直线检测算法</strong></p>
<ul>
<li>量化参数空间，建立二维累加数组，并初始化为$0$;</li>
<li>把图像空间的每一特征点的坐标代入直线极坐标方程</li>
<li>根据$ r $和$ θ $的值，在相应的数组元素上加$ 1$;</li>
<li>所有目标点处理完毕后，找出累加数组中最大元素值，即为直线模型参数$(r^<em>,θ^</em>)$</li>
</ul>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/hough直线检测算法.png" alt=""></p>
<p><strong>Halcon算子</strong></p>
<p><code>hough_lines_dir(ImageDir : HoughImage, Lines : DirectionUncertainty, AngleResolution, Smoothing, FilterSize, Threshold, AngleGap, DistGap, GenLines : Angle, Dist)</code></p>
<ul>
<li><p><code>ImageDir</code>：Image containing the edge direction. The edges are described by the image domain.</p>
</li>
<li><p><code>DirectionUncertainty</code>：Uncertainty of edge direction (in degrees) — 能够容忍的边缘角度的偏差值</p>
</li>
<li><p><code>AngleResolution</code>：Resolution in the angle area (in 1/degrees) — 角度区域的分辨率</p>
</li>
<li><p><code>Smoothing</code>：Smoothing filter for hough image</p>
</li>
<li><p><code>FilterSize</code>：Required smoothing filter size</p>
</li>
<li><p><code>Threshold</code>：$ r $和$ θ $出现次数的阈值，可以调整最终得到图像的个数</p>
</li>
<li><p><code>AngleGap</code>：Minimum distance of two maxima in the Hough image (direction: angle) — 约束$\theta$</p>
</li>
<li><p><code>DistGap</code>：Minimum distance of two maxima in the Hough image (direction: distance)— 约束$\rho$</p>
</li>
<li><p><code>GenLines</code>：Create line regions if ‘true’</p>
</li>
</ul>
<pre class="line-numbers language-Halcon" data-language="Halcon"><code class="language-Halcon">read_image (Image, 'fabrik')
* 提取ROI
rectangle1_domain (Image, ImageReduced, 170, 280, 310, 360)
* Sobel边缘检测
sobel_dir (ImageReduced, EdgeAmplitude, EdgeDirection, 'sum_abs', 3)
threshold (EdgeAmplitude, Region, 55, 255)
*截取图像
reduce_domain (EdgeDirection, Region, EdgeDirectionReduced)
* Hough变换
hough_lines_dir (EdgeDirectionReduced, HoughImage, Lines, 4,2, 'mean', 3, 27, 5, 5, 'true', Angle, Dist)
* 将Hough变换提取直线以普通形式描述的输入行存储为区域
gen_region_hline (LinesHF, Angle, Dist)
* 显示
dev_display (Image)
dev_set_colored (12)
dev_set_draw ('margin') 
dev_display (LinesHF) 
dev_set_draw ('fill')
dev_display (Lines)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>Hough检测圆</strong></p>
<p>霍夫圆算法的实现一共可分为两个步骤：</p>
<ol>
<li>建立霍夫参数三维空间，并对空间内各个单元进行投票</li>
<li>设置阈值从投票结果中筛选合适的圆，并做非极大化抑制</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42044695/article/details/117793536">https://blog.csdn.net/weixin_42044695/article/details/117793536</a></p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/hough圆.png" style="zoom: 50%;"></p>
<p>​                          $\nabla I(x,y)$为$(x,y)$的梯度                                                   选择 $a,b,r $作为参数，变换到参数空间后，即对应一个圆锥</p>
<p>对$a,b,r $三维参数空间投票，计算量大</p>
<p>Hough梯度法</p>
<ul>
<li><p>梯度方向垂直于边缘方向</p>
</li>
<li><p>圆周上点的梯度方向相交于圆心</p>
</li>
<li><p>先找圆心，再由圆心确定半径</p>
</li>
</ul>
<p>算法：</p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/hough圆3.png" alt=""></p>
<script type="math/tex; mode=display">
\begin{array}{l}
a=x_{i}-r \cos \theta_{i} \quad r=\frac{x_{i}-a}{\cos \theta_{i}} \\
b=y_{i}-r \sin \theta_{i} \\
b=y_{i}-r \sin \theta_{i}=y_{i}-\left(x_{i}-a\right) \frac{\sin \theta_{i}}{\cos \theta_{i}} \\
b=a \tan \theta_{i}-x_{i} \tan \theta_{i}+y_{i}
\end{array}</script><p>变换圆检测算法操作步骤如下:</p>
<ol>
<li><p>根据精度要求, 量化参数空间 $ a  $和$  b $，由此建立二维累加数组$  A(a, b)$，并将其初始化为零。</p>
</li>
<li><p>计算边缘轮廓图像的梯度角正切值。</p>
</li>
<li><p>自上而下、自左向右扫描图像，如果检测到当前点$  (x, y) $ 是边缘点，查找当前点所对应的梯度角正切值，然后根据公式$  b=a \tan \theta_{i}-x_{i} \tan \theta_{i}+y_{i}  $计算出每一个$  a  $对应的$  b  $值。</p>
</li>
<li><p>根据 $ a  $和$  b  $的值, 执行$  A(a, b)=A(a, b)+1  $。 </p>
</li>
<li>循环执行步骤 3、4，直到所有点全部处理完毕。</li>
<li>找到累加数组中最大元素值对应坐标位置，该结果即为圆心坐标。</li>
<li>将圆心坐标代入图像空间中圆的方程式计算所有边缘点至圆心坐标的距离， 找到距离数据中出现频率最高的值，即为圆的半径参数。</li>
</ol>
<p><strong>Halcon算子</strong></p>
<ul>
<li><p>hough_circles — Centres of circles for a specific radius.</p>
<p><code>hough_circles(RegionIn : RegionOut : Radius, Percent, Mode : )</code></p>
<ul>
<li>Percent：圆在图中的面积占比</li>
<li>Mode：定义了圆的位置</li>
</ul>
</li>
<li><p>hough_circle_trans — Return the Hough-Transform for circles with a given radius</p>
<p><code>hough_circle_trans(Region : HoughImage : Radius : )</code></p>
</li>
</ul>
<h3 id="分水岭分割算法"><a href="#分水岭分割算法" class="headerlink" title="分水岭分割算法"></a>分水岭分割算法</h3><p>“分水岭”这个名字与一种地貌特点有关，它的思想是，把图像的灰度看作一张地形图，图像中的每一点像素的灰度值表示该点的海拔高度，高灰度值代表山脉，低灰度值代表盆地，每一个局部极小值及其影响区域称为集水盆，而集水盆的边界则形成分水岭。</p>
<p>分水岭算法</p>
<ol>
<li><strong>局部最小值点</strong>，该点对应一个盆地的最低点，当我们在盆地里滴一滴水的时候，由于重力作用，水最终会汇聚到该点。注意：可能存在一个最小值面，该平面内的都是最小值点。</li>
<li><strong>盆地的其它位置点</strong>，该位置滴的水滴会汇聚到局部最小点。</li>
<li><strong>盆地的边缘点</strong>，是该盆地和其它盆地交接点，在该点滴一滴水，会等概率的流向任何一个盆地。</li>
</ol>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/分水岭.png" alt=""></p>
<p>分水岭算法的整个过程：</p>
<ol>
<li>把梯度图像中的所有像素按照灰度值进行分类，并设定一个测地距离 (Geodesic Distance)阈值。</li>
<li>找到灰度值最小的像素点（默认标记为灰度值最低点），让threshold从最小值开始增长，这些点为起始点。</li>
<li>水平面在增长的过程中，会碰到周围的邻域像素，测量这些像素到起始点（灰度值最低点）的测地距离 (Geodesic Distance)，如果小于设定阈值，则将这些像素淹没，否则在这些像素上设置大坝，这样就对这些邻域像素进行了分类。</li>
<li>随着水平面越来越高，会设置更多更高的大坝，直到灰度值的最大值，所有区域都在分水岭线上相遇，这些大坝就对整个图像像素的进行了分区。</li>
</ol>
<p>在真实图像中，由于噪声点或者其它干扰因素的存在，使用分水岭算法常常存在过度分割的现象，这是因为很多很小的局部极值<br>点的存在，这样的分割效果是毫无用处的。</p>
<p>其中的解决方法：</p>
<ol>
<li>对图像进行高斯平滑操作，抹除很多小的最小值，这些小分区就会合并。</li>
<li>不从最小值开始增长，可以将相对较高的灰度值像素作为起始点（需要用户手动标记），从标记处开始进行淹没，则很多小区域都会被合并为一个区域，这被称为<strong>基于图像标记(mark)的分水岭算法</strong>。。</li>
</ol>
<p>分水岭算法常用的操作步骤：</p>
<ol>
<li>彩色图像灰度化；</li>
<li>求梯度图；</li>
<li>在梯度图的基础上进行分水岭算法，求得分段图像的边缘线。</li>
</ol>
<p><strong>Halcon算子</strong></p>
<ol>
<li><p>直接提取图像的盆地区域和分水岭区域算子如下：</p>
<p><code>watersheds(Image : Basins, Watersheds : : )</code></p>
</li>
<li><p>阈值化提取分水岭盆地区域算子如下：<br><code>watersheds_threshold(Image : Basins : Threshold : )</code></p>
</li>
</ol>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/watersheds_threshold.png" alt=""></p>
<pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">read_image (Br2, 'particle')
*对单通道图像进行高斯平滑处理，去除噪声
gauss_filter (Br2, ImageGauss, 9)
*将图像颜色进行反转
invert_image (ImageGauss, ImageInvert)
*对平滑后图像进行分水岭处理与阈值分割，提取出盆地区域
watersheds (ImageInvert, Basins, Watersheds)
watersheds_threshold (ImageInvert, Basins1,30)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h2><p>为了使计算机能够理解图像，我们需要从图像中提取有用的数据或信息，因此需要确定一个或多个特征量 。这些我们确定的特征量被称为特征，这一过程就是特征提取 。</p>
<p><strong>图像特征分类</strong></p>
<ul>
<li>自然特征：大小，亮度，颜色，轮廓，边缘，纹理等</li>
<li>人为特征：直方图、矩特征、熵等</li>
</ul>
<p><strong>特征提取的一般规则</strong></p>
<ul>
<li>良好的区别性：同类之间差异小，不同类之间差异大</li>
<li>稳定的可靠性：内容小规模变化时不受影响，如对噪声不敏感</li>
<li><p>特征信息不相关：相互独立、减少冗余</p>
</li>
<li><p>较小数据量：容易提取，维数不应过大，减少特征匹配的计算量</p>
</li>
</ul>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/特征.png" style="zoom: 33%;"> </p>
<h3 id="区域形状特征"><a href="#区域形状特征" class="headerlink" title="区域形状特征"></a>区域形状特征</h3><p>在场景中选择物体的特征是图像测量或者识别的重要基础。在特征提取中，区域的形状特征是非常常用的特征，包括区域面积、中心点坐标、区域的宽度和高度等特征量</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">特征</th>
<th style="text-align:center">算子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">面积 / 中心点</td>
<td style="text-align:center">area_center (Regions : : : Area, Row, Column)</td>
</tr>
<tr>
<td style="text-align:center">Area:对所有点的灰度值求和 /  (Row, Column) 重心</td>
<td style="text-align:center">area_center_gray (Regions, Image : : : Area, Row, Column)</td>
</tr>
<tr>
<td style="text-align:center">封闭区域（孔洞）的面积 (返回所有孔洞区域的面积之和)</td>
<td style="text-align:center">area_holes (Regions : : : Area)</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">* 获取图像                           
read_image (Image, 'fabrik')
* 关闭窗口                           
dev_close_window ()
* 打开窗口                           
dev_open_window (0, 0, 512, 512, 'black', WindowID)
* 设置输出字体，14号字，Courier字体，粗体       
set_display_font (WindowID, 14, 'mono','true', 'false')
* 设置输出颜色                    
dev_set_colored (6)
* 进行区域生长操作              
regiongrowing (Image, Regions, 1, 1, 3, 200)
* 显示区域                          
dev_display (Regions)
* 计算所有不相连区域的面积和中心点坐标       
area_center (Regions, Area, Row, Column)
* 获取一个字符串的空间大小 (显示5位字符串的宽和高)
get_string_extents (WindowID, 12345, Ascent, Descent, TxtWidth, TxtHeight)
* 将面积计算结果以字符串形式显示在窗口中    
disp_message (WindowID, Area, 'image',Row - TxtHeight / 2, Column - TxtWidth / 2, 'white', 'false')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">* 关闭窗口                        
dev_close_window ()
* 读取图像                        
read_image (Image, 'rings_and_nuts')
* 打开适应图像大小的窗口
dev_open_window_fit_image (Image, 0, 0, -1, -1, WindowHandle)
* 设置输出颜色                 
dev_set_color ('red')
* 设置输出字体，14号字，Courier字体，粗体       
set_display_font (WindowHandle, 14, 'mono', 'true', 'false')
* 显示图像                        
dev_display (Image)
* 进行阈值操作 (提取白色区域)                
threshold (Image, Region, 128, 255)
* 计算区域中孔的面积       
area_holes (Region, Area)
* 将面积计算结果以字符串形式显示在窗口中       
disp_message (WindowHandle, 'Size of enclosed area (holes): ' + Area + ' pixel', 'window', 12, 12, 'black', 'true')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>根据特征值选择区域</strong></p>
<p>区域的常用特征</p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/区域特征.png" style="zoom:50%;"></p>
<p>根据特征值选择区域</p>
<p><code>Select_shape(Regions: SelectedRegions: Features, Operation, Min, Max: )</code></p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/select_shape.png" alt=""></p>
<pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">* 读取图像
read_image (Image, 'monkey')
threshold (Image, Region, 128, 255)
* 将非连通区域分割成一组区域的集合
connection (Region, ConnectedRegions)
* 利用面积以及椭圆长轴与短轴的比值特征，将眼睛部分区域提取出来
* 'anisometry'宽和高的比值
select_shape (ConnectedRegions, SelectedRegions,['area','anisometry'], 'and', [500,1], [2000,1.7])
* 显示结果区域
dev_display (SelectedRegions)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>根据灰度特征值选择区域 select_gray</strong></p>
<p><code>select_gray(Regions, Image : SelectedRegions : Features, Operation, Min, Max : )</code></p>
<p><img src="/2022/11/20/ji-qi-shi-jue-halcon/select_gray.png" alt=""></p>
<p><strong>根据特征值创建区域</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">含义</th>
<th style="text-align:center">算子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">区域内接圆</td>
<td style="text-align:center">inner circle(Regions: : : Row, Column, Radius)</td>
</tr>
<tr>
<td style="text-align:center">平行坐标最小外包矩形</td>
<td style="text-align:center">smallest_rectangle1(Regions : : : Row1, Column1, Row2, Column2)</td>
</tr>
<tr>
<td style="text-align:center">最小外包矩形 (可旋转)</td>
<td style="text-align:center">smallest_rectangle2(Regions : : : Row, Column, Phi, Length1, Length2)</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">*读取图像                        
read_image (Image, 'fabrik')
get_image_size (Image, Width, Height)
*关闭窗口                        
dev_close_window () 
dev_open_window (0, 0, Width, Height, 'black', WindowID)
*设置输出颜色为白色       
dev_set_color ('white')
*设置图像模式为填充模式
dev_set_draw ('fill')
*使用regiongrowing算子寻找颜色相近的邻域 
regiongrowing (Image, Regions, 1, 1, 3, 500)
*找出每个区域的最大内接圆以及内接圆的中心坐标和半径
inner_circle (Regions, Row, Column, Radius)
*设置输出颜色为红色       
dev_set_color ('red')
*显示每个区域的内接圆   
disp_circle (WindowID, Row, Column, Radius)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">*关闭窗口                                  
dev_close_window ()
*读取图像                                  
read_image (Shubiao,'shubiao.jpg')
*获取图像尺寸                          
get_image_size (Shubiao, Width, Height)
*打开适应图像大小的窗口          
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
*灰度化                                     
rgb1_to_gray (Shubiao, GrayImage)
*使用阈值处理提取较暗的部分   
threshold (GrayImage, Regions, 0, 253)
*求平行坐标的最小外接矩形       
smallest_rectangle1 (Regions, Row1, Column1, Row2, Column2)
*填充模式为轮廓                        
dev_set_draw ('margin')
*根据矩形参数绘制矩形的轮廓   
gen_rectangle1 (Rectangle, Row1, Column1, Row2, Column2)
*求区域的最小外接矩形             
smallest_rectangle2 (Regions, Row, Column, Phi, Length1, Length2)
*根据矩形参数绘制矩形的轮廓   
gen_rectangle2 (Rectangle1, Row, Column, Phi, Length1, Length2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="区域的灰度特征值"><a href="#区域的灰度特征值" class="headerlink" title="区域的灰度特征值"></a>区域的灰度特征值</h3><p><strong>典型的灰度值特征</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">灰度区域面积 (area)</td>
<td style="text-align:center">中心点的行坐标和列坐标 (row colum)</td>
<td style="text-align:center">椭圆的长轴 (ra)</td>
<td style="text-align:center">椭圆的短轴 (rb)</td>
<td style="text-align:center">等效椭圆的角度 (phi)</td>
</tr>
<tr>
<td style="text-align:center">灰度的最小值（min）</td>
<td style="text-align:center">灰度的最大值（max）</td>
<td style="text-align:center">灰度的均值（mean）</td>
<td style="text-align:center">灰度值的偏差（deviation）</td>
<td style="text-align:center">近似平面的偏差（plane_deviation）</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">含义</th>
<th style="text-align:center">算子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">计算指定区域的灰度特征值</td>
<td style="text-align:center">gray_features (Regions, Image : : Features : Value)</td>
</tr>
<tr>
<td style="text-align:center">计算区域的灰度值平均值和偏差</td>
<td style="text-align:center">intensity (Regions, Image : : : Mean, Deviation)</td>
</tr>
<tr>
<td style="text-align:center">基于灰度直方图计算最大/最小灰度值</td>
<td style="text-align:center">min_max_gray (Regions, Image: : Percent: Min, Max, Range)</td>
</tr>
</tbody>
</table>
</div>
<p><code>min_max_gray</code>算子的原理是基于灰度直方图，取波峰和谷底之间的区域，区域两端各向内收缩一定的百分比，然后在这段范围内计算出最小灰度值和最大灰度值。</p>
<pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">* 读取图片
read_image (Image, 'monkey')
* 对图像进行阈值处理，将图像转化为区域
threshold (Image, Region, 210, 255)
connection (Region, ConnectedRegions)
select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 27500, 28849.2)
* 提取区域中最小灰度值
gray_features (Region, Image, 'min',MinDisp)
* 提取区域中最大灰度值
gray_features (Region, Image, 'max', MaxDisp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">* 读取图像                                                    
read_image (Image, 'mreut')
* 关闭窗口                                                    
dev_close_window ()
* 获得图像尺寸                                              
get_image_size (Image, Width, Height)
* 打开适应图像大小的窗口                             
dev_open_window (0, 0, Width, Height, 'black', WindowID)
* 显示图像                                                    
dev_display (Image)
* 设置填充模式为轮廓                                    
dev_set_draw ('margin')
* 创建两个矩形区域                                      
gen_rectangle1 (Rectangle1, 350, 100, 450, 200)
gen_rectangle1 (Rectangle2, 100, 200, 200, 300)
* 提取区域1中灰度值的平均值与偏差              
intensity (Rectangle1, Image, Mean1, Deviation1)
* 提取区域2中灰度值的平均值与偏差              
intensity (Rectangle2, Image, Mean2, Deviation2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">* 读取图像                                                    
read_image (Image, 'mreut')
* 关闭窗口                                                    
dev_close_window ()
* 获得图像尺寸                                              
get_image_size (Image, Width, Height)
* 打开适应图像大小的窗口                             
dev_open_window (0, 0, Width, Height, 'black', WindowID)
* 显示图像                                                    
dev_display (Image)
* 设置填充模式为轮廓                                    
dev_set_draw ('margin')
* 创建两个矩形区域                                      
gen_rectangle1 (Rectangle1, 350, 100, 450, 200)
gen_rectangle1 (Rectangle2, 100, 200, 200, 300)
* 提取区域1中最大与最小灰度值以及跨度         
min_max_gray (Rectangle1, Image, 5, Min1, Max1, Range1)
* 提取区域2中最大与最小灰度值以及跨度              
min_max_gray (Rectangle2, Image, 5, Min2, Max2, Range2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">zss</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://lumoszss.github.io/2022/11/20/ji-qi-shi-jue-halcon/">https://lumoszss.github.io/2022/11/20/ji-qi-shi-jue-halcon/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">zss</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/">
                                    <span class="chip bg-color">机器视觉</span>
                                </a>
                            
                                <a href="/tags/Halcon/">
                                    <span class="chip bg-color">Halcon</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/11/20/ji-qi-shi-jue-ying-jian/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="机器视觉硬件">
                        
                        <span class="card-title">机器视觉硬件</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-11-20
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" class="post-category">
                                    图像处理
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/">
                        <span class="chip bg-color">机器视觉</span>
                    </a>
                    
                    <a href="/tags/%E7%9B%B8%E6%9C%BA%E3%80%81%E9%95%9C%E5%A4%B4%E3%80%81%E5%85%89%E6%BA%90/">
                        <span class="chip bg-color">相机、镜头、光源</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/08/11/dong-tai-gui-hua-xue-xi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="动态规划学习">
                        
                        <span class="card-title">动态规划学习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-08-11
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" class="post-category">
                                    算法学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">
                        <span class="chip bg-color">动态规划</span>
                    </a>
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2024</span>
            
            <a href="/about" target="_blank">zss</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/lumoszss" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:736832556@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=736832556" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 736832556" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
