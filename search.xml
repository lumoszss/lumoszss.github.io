<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器视觉硬件</title>
      <link href="/2022/11/20/ji-qi-shi-jue-ying-jian/"/>
      <url>/2022/11/20/ji-qi-shi-jue-ying-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="机器视觉硬件"><a href="#机器视觉硬件" class="headerlink" title="机器视觉硬件"></a>机器视觉硬件</h2><ul><li>机器视觉系统组成：光源、镜头、相机、图像采集模块、图像处理模块、交互界面等。</li><li>机器视觉的工作流程</li></ul><p><img src="/2022/11/20/ji-qi-shi-jue-ying-jian/工作流程图.jpg" alt=""></p><p>视觉系统</p><ul><li><p>模拟相机</p><p><img src="/2022/11/20/ji-qi-shi-jue-ying-jian/模拟相机.png" alt=""></p></li><li><p>数字相机</p><p><img src="/2022/11/20/ji-qi-shi-jue-ying-jian/数字相机.png" alt=""></p></li><li><p>智能摄像机</p><p><img src="/2022/11/20/ji-qi-shi-jue-ying-jian/智能摄像机.png" alt=""></p></li></ul><h3 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h3><ul><li>照明光源分类：高频荧光灯、卤素灯、<strong>LED灯</strong></li></ul><p><strong>LED光源特点</strong></p><ul><li>可制成各种形状、尺寸及各种照射角度；</li><li>可根据需要制成各种颜色，并可以随时调节亮度；</li><li>通过散热装置，散热效果更好，光亮度更稳定；</li><li>使用寿命长（约 3 万小时，间断使用寿命更长）；</li><li>反应快捷，可在 10us 或更短的时间内达到最大亮度；</li><li>电源带有外触发，可以通过计算机控制，起动速度快，可以用作频闪灯；</li><li>运行成本低、寿命长的 LED ，会在综合成本和性能方面体现出更大的优势；</li><li>可根据客户的需要，进行特殊设计。</li></ul><p><strong>照明技术 (颜色+打光方式)</strong></p><ol><li><p>亮视野与暗视野</p><p><img src="/2022/11/20/ji-qi-shi-jue-ying-jian/视野.png" alt=""></p></li><li><p>低角度照明：</p><ul><li>常应用于检测平滑表面上变化的部分如：划痕、刀痕、边缘</li></ul><p><img src="/2022/11/20/ji-qi-shi-jue-ying-jian/低角度照明.png" alt=""></p></li><li><p>前向光直射照明</p><p><img src="/2022/11/20/ji-qi-shi-jue-ying-jian/前向光直射.png" alt=""></p></li><li><p>照明技术：前向光漫射照明 (得到的图像不会由阴影和褶皱)</p><p><img src="/2022/11/20/ji-qi-shi-jue-ying-jian/前向光漫射.png" alt=""></p></li><li><p>照明技术：背光照明 (物体的轮廓)</p><p><img src="/2022/11/20/ji-qi-shi-jue-ying-jian/背光照明.png" alt=""></p></li><li><p>偏光技术</p><p><img src="/2022/11/20/ji-qi-shi-jue-ying-jian/偏光技术.png" alt=""></p></li></ol><h3 id="镜头"><a href="#镜头" class="headerlink" title="镜头"></a>镜头</h3><p>镜头是与相机配套使用的一种成像设备</p><p>镜头的作用：</p><ol><li>成像：没有镜头，摄像机不能采集到任何图像 , 输出被噪声淹没</li><li>聚焦：当镜头成像平面不在摄像机像面上时，输出图像模糊不清</li><li>曝光 ：改变光积分时间、曝光量 —&gt; 改变灰度</li><li>变焦 ：改变镜头的焦距 —&gt; 改变成像</li></ol><p><strong>镜头分类</strong></p><ul><li>标准镜头：视角约$50^{。}$</li><li>广角镜头：视角$90^{。}$以上，用于拍摄距离近且范围大的景物</li><li>长焦距镜头：适用于拍摄距离远的景物，景深小容易使背景模糊主体突出</li><li>微距镜头：极尽距离拍摄</li><li>远心镜头<ul><li>在测量系统中，物距常发生变化，从而使像高发生变化，所以测得的物体尺寸也发生变化，即产生了测量误差；</li><li>即使物距是固定的，也会因为CCD敏感表面不易精确调整在像平面上，同样也会产生测量误差。</li><li>采用远心物镜中的像方远心物镜可以消除物距变化带来的测量误差，而物方远心物镜则可以消除CCD位置不准带来的测量误差。</li></ul></li></ul><h4 id="成像基本原理"><a href="#成像基本原理" class="headerlink" title="成像基本原理"></a>成像基本原理</h4><p><strong>小孔成像</strong></p><ul><li>像的形状和小孔的形状无关，像距越大，物距越小，像越大</li></ul><p><img src="/2022/11/20/ji-qi-shi-jue-ying-jian/小孔成像.png" alt=""></p><ul><li>像的高度 $y^{‘} = y \frac{L^{‘}}{L}$</li><li>由于针孔太小，只有极少数的光线能够通过小孔到达像平面，因此必须采用足够长的曝光才能得到亮度足够的图像。镜头的作用就是收集光线，让光线聚集到成像芯片上</li></ul><p><strong>折射原理</strong></p><p>镜头是根据折射原理构造而成的</p><ul><li>光线在一定介质中的传播速度$v$小于真空中的传播速度$c$</li><li>空气的折射率约为1.0002926，接均于1</li><li>不同玻璃的折射率大约在1.48 ~ 1.62之间</li></ul><p>折射原理：自上而下的入射光在不同介质的分界处发生折射，两种介质的折射率分别为$n_1$和$n_2$，则$n_1 \sin\alpha_1 = n_2 \sin\alpha_2$</p><ul><li>从公式可知，折射率为非线性的，即镜头的成像是非线性的，通信光束通过镜头后将不能完全汇聚到一点，当入射角很小时，可以用$\alpha$代替$\sin\alpha$，通过这个近似可以得到线性的折射定律$n_1\alpha_1 = $n_2\alpha_2$</li></ul><p><strong>高斯光学 (理想光学系统)</strong></p><p>在高斯光学中同心光束通过由球面透镜构成的镜头后又汇聚到一点，高斯光学是理想化的光学系统，所有与高斯光学的背离称为<strong>像差</strong></p><p><strong>厚透镜模型</strong></p><p>镜头可以看作由两个球心位于同一直线的折射球面构成（真实的镜头要更加复杂），两个球面之间为均匀介质 (不折射)，镜头外两侧介质也是相同的，镜头有一定的厚度，这种模型称为厚透镜模型</p><p><img src="/2022/11/20/ji-qi-shi-jue-ying-jian/厚透镜模型.png" alt=""></p><p>像的尺寸完全取决于$F$, $F^{‘}$, $N$, $N^{‘}$，这四点称为镜头的基本要素</p><p>成像法则</p><ol><li>镜头前平行于光轴的直线过$F^{‘}$</li><li>过$F$点的光线通过镜头后平行于光轴</li><li>过$N$点的光线也会过$N^{‘}$点，并且通过镜头之前与通过镜头之后与光轴的夹角不变 (相似三角形)</li></ol><script type="math/tex; mode=display">\frac{y}{L} = \frac{y^{'}}{L^{'}} \rightarrow y^{'} = y \frac{L^{'}}{L} (同小孔成像) \  \ \beta=  \frac{L^{'}}{L}  =  \frac{y^{'}}{y} \\ \frac{y^{'}}{y} = \frac{f}{f-L} (左侧的相似三角形，注意方向相同) \ \frac{y^{'}}{y} = \frac{f^{'}-L^{'}}{f^{'}}(右侧相似三角形) \\由于\  f^{'} = -f  \rightarrow \frac{f}{f-L} = \frac{f^{'}-L^{'}}{f^{'}} = \frac{f+ L^{'}}{f} \rightarrow \frac{1}{L^{'}} - \frac{1}{L} = \frac{1}{f^{'}} \ (高斯成像公式)</script><p>从高斯成像公式可以看出：</p><ul><li>$f$固定，物距增加，像距减小</li><li>对于极端情况如果物距无穷远，所有的光线都会变成平行光，此时$L^{‘} = f^{‘}$</li><li>如果把物体向镜头移动，使其置于$F$之内，将会看到光线在成像端发散，其像为物体同一侧的虚像</li><li>放大倍率：$m = |\beta|$，调焦可以控制放大倍率</li><li><strong>焦距</strong>：$ \color{red} \beta=\frac{f^{‘}}{f^{‘}+L} \rightarrow = f^{‘} = |L|/(1+\frac{1}{|\beta|})$</li></ul><h4 id="镜头参数"><a href="#镜头参数" class="headerlink" title="镜头参数"></a>镜头参数</h4><p><strong>分辨率</strong></p><ul><li>与镜头结构、材质、加工精度、相对孔径有关</li><li>与光波长度有关，波长越短，分辨率越高</li></ul><p><strong>景深</strong></p><ul><li><p>在聚焦完成后，焦距前后的范围内都能形成清晰的像，这一前一后的距离范围叫做景深</p><p><img src="/2022/11/20/ji-qi-shi-jue-ying-jian/景深.jpg" alt=""></p></li></ul><p><strong>畸变 (失真)</strong></p><ul><li>不经过光轴的直线经过镜头后成的像不再是一条直线，从而产生了畸变</li></ul><p><strong>视场 (field of vision, FOV)</strong></p><ul><li>系统能够观察到的物体的物理尺寸的范围，也就是CCD芯片上所成图像最大时对应的物体的大小</li><li>$FOV = |L/m|$</li></ul><p><strong>工作距离</strong></p><ul><li>工业镜头与目标之间的距离称为工业镜头的工作距离 (物距)</li><li>$R = r/M$ ($r$为分辨率)</li></ul><p><strong>像面尺寸</strong></p><ul><li>一个工业镜头能清晰成像的范围是有限的，像面尺寸指它能支持的最大清晰成像范围（通常用其直径表示）</li></ul><p><strong>光圈</strong></p><ul><li>以镜头焦距$f$和通光孔径 (光圈有效口径)$D$的比值来衡量$F = f / D$</li><li>完整光圈值系列：F$_{1.0}$、F$_{1.4}$、F$_{2.0}$、F$_{2.8}$等</li><li>F后面的数值越小，光圈越大</li><li>光圈的作用在于决定镜头的进光量，光圈越大，进光量越多，画面越亮</li><li><strong>大光圈：景深浅，背景虚化；小光圈：景深大，背景清晰</strong></li></ul><h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><p>相机是一种将现场的影像转化为数字信号或者模拟信号的工具</p><p><strong>工业相机的分类</strong></p><p>按不同的芯片类型划分：</p><ol><li>CCD相机<ul><li>弱光低速的检测环境下可以选择CCD，有助于获得更丰富的图像细节</li></ul></li><li>CMOS相机 ( * 面阵，并行处理)</li></ol><div class="table-container"><table><thead><tr><th>CCD</th><th>CMOS</th></tr></thead><tbody><tr><td>串行处理</td><td>并行处理，可直接访问单像素</td></tr><tr><td>线性度好</td><td>高动态范围</td></tr><tr><td>低噪声</td><td>存在固定模式噪声</td></tr><tr><td>功耗一般</td><td>功耗较低</td></tr><tr><td>集成度较低</td><td>高集成度，芯片上集成了很多功能</td></tr></tbody></table></div><p>按传感器的像素排列方式划分：</p><ol><li>面阵相机：将图像以整幅画面的形式输出</li><li>线阵相机：将图像逐行输出，图像宽度与面阵相机无异，但高度只有1像素，适合检测的图像区域是条形或者高速运动的物体</li></ol><p><strong>相机的选型主要关注以下因素</strong></p><ol><li>分辨率：一般用$W \times H$的形式表示，$W$为图像水平方向上每一行的像素数，$H$为垂直方向上每一列的像素数</li><li>像素尺寸：每个像素的实际大小，即传感器中像元的大小，单位一般是mm</li><li>帧率：相机每一秒拍摄的帧数，帧率应与物体的运动速度相匹配</li><li>像素深度：色彩的丰富程度，一般来说8bits表示黑白图像，24bits表示彩色的RGB图像</li><li>数字接口：相机的接口是用来输出相机数据的，一般有GigE、USB2.0/3.0、CarmeraLink、FireWire等类型<ul><li>GigE接口：利用以太网传输图像数据，适合远距离的传输</li><li>USB2.0/3.0：使用距离需要比较近</li><li>CarmeraLink：图像采集卡接口。传输速度快，支持高分辨率</li><li>FireWire：用于连接嵌入式系统</li></ul></li><li><p>靶面尺寸：指图像传感器的大小，如1/2$^{‘’}$、1/3$^{‘’}$、2/3$^{‘’}$等。在分辨率固定的情况下，靶面尺寸越大，传感器的面积越大，图像的质量越好。<strong>靶面尺寸应与镜头匹配，镜头投影的图像面积应不小于相机的芯片尺寸</strong></p></li><li><p><strong>快门</strong></p><ul><li>控制相机曝光时间的长短</li><li>卷帘快门与全快门 (Rolling Shutter &amp; Global Shutter)<ul><li>全快门：模式曝光时，对于所有的扫描线，进行同时间一次性曝光，类似于将运动的物体冻结了，适合配合快速运动的物体</li><li>卷帘快门：模式曝光时，采用逐行顺序曝光，不适合运动物体的拍摄</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器视觉 </tag>
            
            <tag> 相机、镜头、光源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Halcon机器视觉</title>
      <link href="/2022/11/20/ji-qi-shi-jue-halcon/"/>
      <url>/2022/11/20/ji-qi-shi-jue-halcon/</url>
      
        <content type="html"><![CDATA[<h1 id="Halcon机器视觉"><a href="#Halcon机器视觉" class="headerlink" title="Halcon机器视觉"></a>Halcon机器视觉</h1><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/什么是HALCON.jpg" style="zoom:50%;"></p><p><strong>编程方式</strong></p><ol><li><p>在HDevelop 编写算法部分</p></li><li><p>使用C++ 或 C# 开发应用程序</p></li><li><p>从HDevelop 导出算法代码并集成到应用程序中</p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/解决方案.jpg" style="zoom:50%;"></p></li></ol><p><strong>视觉处理的常用框架</strong></p><ol><li>采集图像</li><li>预处理（中值滤波、均值滤波、高斯滤波、灰度变换、gray_range_rect等）</li><li>特征处理 (select_shape)</li><li>训练识别 (深度学习)</li><li>显示</li></ol><p><strong>快捷键</strong></p><ul><li>打开帮助窗口：F1</li><li>注释：F4</li><li>激活：F3</li><li>运行：F5</li><li>直接运行一个语句：Shift + 回车</li><li>打开算子窗口：Ctrl + Shift + 空格</li></ul><h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><ol><li><p>窗口：图形窗口、变量窗口 (<strong>Iconic</strong>、<strong>Control</strong>、<strong>Tuple</strong>)、算子窗口、程序窗口</p><ul><li><p>图像变量: Iconic (image , region, XLD)</p><ul><li><p>Region是图像处理里面的一大对象，该对象描述图像中的区域。图像可通过threshold（阈值分割）算子转换成区域，也可以手动画ROI （感兴趣区域）来定义区域。手动ROI跟阈值分割转换区域是不同的，前者基于窗口，后者基于像素灰度值</p></li><li><p>XLD，亚像素精度轮廓，指图像中某一块区域的轮廓，在 HALCON 中查看 XLD 的特征步骤与查看 Region 特征的步骤相似。点击工具栏中的特征检测选择XLD , 在图形窗口选择要查看的 XLD 特征，可看到 XLD 的特征属性及其相对应的数值</p></li></ul></li><li><p>控制类变量：Control (string, integer, real, handle)</p></li><li><p>注意：输入、输出数据严格分开，<strong>算子不会改变输入数据</strong></p></li><li><p>固定的参数顺序：Input Iconic —&gt; Output Iconic —&gt; Input Control  —&gt; Output Control </p><p><code>operator(Input iconic: Output iconic: Input control: Output control)</code></p></li></ul></li><li><p>HALCON自带图片素材位置：<code>C:\Users\Public\Documents\MVTec\HALCON-19.11-Progress\examples\images</code></p></li><li><p>打开一个窗口，获得窗口句柄</p><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">dev_close_window()dev_open_window (0, 0, 512, 512, 'black', WindowHandle)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>读取图像</p><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">第一种方式直接打开具体的图像：文件 ---&gt; 读取图像或者按住CTRL+R 打开读取图像对话窗口，在文件名称一栏中选择图像所在的文件路径，在语句插入位置点击确定，即可获得图像第二种方式：使用代码read_image(imgName,path) 打开图像dev_display(imgName) 在图形窗口显示图像选择可视化 ---&gt; 更新窗口 ---&gt; 总是 自动显示图像不需要上述的语句可以一次读取多张图像read_images(imgs,[path1,path2,...])使用算子 select_obj 选择某一张图像第三种方式助手 —&gt; 打开新的 Image Acquisition —&gt; 资源：选择文件 (选择具体的图像，同第一种)第四种方式助手 —&gt; 打开新的 Image Acquisition —&gt; 资源：选择路径 (选择图像所在的文件夹) ---&gt; 代码生成：点击插入代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>使用设备采集图像：</strong>助手 —&gt; 打开新的 Image Acquisition —&gt; 资源：自动检测接口 (相机自带的库、DirectShow) —&gt; 连接：颜色空间 (灰度采集、RGB采集) —&gt; 点击连接 —&gt; 点击实时 (实时采集) —&gt;  代码生成：采集模式 (异步采集) —&gt; 点击插入代码 (自动生成代码)</p><ul><li>相机主存 —&gt; 采集卡存储器 —&gt; 上位机内存</li><li>异步读取：图像从采集设备获取，非实时，取像与处理并行，对图像处理时间把控比较严</li><li>同步读取：通过相机取像，实时，取像与处理是串行的，取像周期长。</li></ul></li><li><p>查看图像/区域某一点的灰度值/坐标：Ctrl+鼠标定位</p></li><li><p>图像通道：在HALCON 中，把鼠标移动到 HALCON 变量窗口中的图像变量上会显示图像变量的类型、通道及尺寸</p><pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">read_image (Image, 'D:/picture/ship.png')* 计算图像通道count_channels(Image,Num)* 循环读取每个通道的图像for I := 1 to Num by 1* 获取多通道指定图像access_channel (Image, channel1, I)endfor* 分解通道decompose3 (Image, RedImage, GreenImage, BlueImage)* 合并通道compose2 (RedImage, GreenImage, MultiChannelImage)* 向图像附加通道append_channel (MultiChannelImage, BlueImage, ImageExtended)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>保存图像</p><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">read_image(Image, 'printer_chip/printer_chip_01')* 保存图像变量write_image (Image, 'tiff', 0, 'D://Tmp1')*  dump_window_image 在图像对象中写入窗口内容。dump_window_image( Image , WindowHandle)   //图像名，窗口句柄write_image( Image , 'tiff', 0, 'D://Tmp1 )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="Tuple及控制语句"><a href="#Tuple及控制语句" class="headerlink" title="Tuple及控制语句"></a>Tuple及控制语句</h2><div class="table-container"><table><thead><tr><th>运算符</th><th>符号</th><th>示例</th></tr></thead><tbody><tr><td>赋值运算符</td><td><code>:=</code></td><td>a := [2,4,6]</td></tr><tr><td>算数运算符</td><td><code>+</code>  <code>-</code>  <code>*</code>  <code>/</code>  <code>%</code></td><td>a1 % a2</td></tr><tr><td>按位左移</td><td><code>lsh</code></td><td>lsh (i1,i2)</td></tr><tr><td>按位右移</td><td><code>rsh</code></td><td>rsh (i1,i2)</td></tr><tr><td>按位与/或/异或</td><td><code>band</code> <code>bor</code> <code>bxor</code></td><td>i1 band/bor/bxor i2</td></tr><tr><td>按位非</td><td><code>bont</code></td><td>bnot i</td></tr><tr><td>比较运算符</td><td><code>&gt;</code> <code>&lt;</code>  <code>&gt;=</code>  <code>&lt;=</code> <code>=或==(等于)</code> <code>#(不等于)</code></td><td>t1 # t2 (不等于)</td></tr><tr><td>布尔运算符</td><td><code>and</code> <code>or</code> <code>not</code> <code>xor(异或)</code></td><td>not b</td></tr></tbody></table></div><p><strong>基本操作</strong></p><pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">a := 1  //  1a[1] := 2  // [1, 2]a[3] := 3  // [1,2,0,3]a := [a,[4, 5, 6]] // [1,2,0,3,4,5,6]len := |a| // 7 获取元组的长度 a := [4:len-1] // [4,5,6]获取索引从4到len-1的元素b := subset(a,0) // 4 选取索引为0的元素a := remove(a,0)  // [5,6] 移除a中索引为0的元素i := find(a,b) // -1 在a中查找b的位置并返回，找不到返回-1a := [a,6]  // [5,6,6]a := uniq(a)  // [5,6] 元组中相邻两个元素相同时只保留一个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>算子和数字函数</strong></p><pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">tuple_gen_const( : : Length, Const : Newtuple)* 创建一个长度为 Length ，元素为 Const 的元组 Newtuple。tuple_gen_const (5, 1, Newtuple)  * Newtuple结果为 [1, 1, 1, 1, 1]tuple_gen_sequence( : : Start, End, Step : Sequence)* 创建一个从 Start 开始，以 Step 为步长 的等差元组 Sequence。tuple_gen_sequence (1, 9, 2, Sequence)* Sequence结果为 [1, 3, 5, 7, 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">min(t)  // 最小元素max(t)  // 最大元素min2(t1,t2) // 两个元组里面选小的max2(t1,t2)  //  两个元组里面选大的sum(t)  // 返回元素所有元素的和mean(a)  // 返回平均值deviation(a) // 返回标准差cumul(a)  // 计算元组的累计和median(a)  // 返回中值select_rank(a,i) // 先对元组排序，然后选择排序后元组中索引号为i的元素sqrt(a)  // 平方根real(a)  // 整型转实数型int(a)  // 取整round(a) //  四舍五入得到整数abs(a)  //  绝对值fabs(a)  //  绝对值（浮点数）ceil(a)  //  向上取整floor(a) // 向下取整fmod(a1,a2) // 计算 a1/a2 的余数sgn(a)  // 计算元组的正负<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>字符数组的格式化</strong></p><pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">a:= 3.1415926 *取整int_a   := int(a)    //取整数部分，结果是3round_a := round(a)  //将输入元组转换为最接近的整数元组，结果是3a1 := number(a$'.1f')  //number()是将数字字符串转为数字，结果是3.1 *四舍五入，结果是字符串g0 := a$'.0f'  // '3' 保留0位 g1 := a$'.1f'  // '3.1' 保留1位g2 := a$'.2f'  // '3.14' 保留2位 *如果用算子的方式实现，则如下：tuple_string (a, '.1f', String)  //String等于'3.5'tuple_number (String, Number)    //Number等于3.5 *数字转化为字符串直接加''即可string_a := a + ''  //结果是'3.456' *保留N个有效数字，结果是字符串y  := 2018.11y1 := y$'.1'  //保留1位有效数字，结果是'2e+003'y2 := y$'.2'  //保留2位有效数字，结果是'2e+003'y3 := y$'.3'  //保留3位有效数字，结果是'2.02e+003'y4 := y$'.4'  //保留4位有效数字，结果是'2018'y5 := y$'.5'  //保留5位有效数字，结果是'2018.1'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>控制语句</strong></p><pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">* if 分支if(表达式)...elseif...else...endif* switch分支switch (Index)case 1:    breakcase 2:    breakdefault:    breakendswitch* for 循环for(index:=StartNumber to EndNumber by step)循环体endfor*index是循环的变量；StartNumber是开始的数值；EndNumber是结束的数值；step是步长* while 循环while(条件)    循环语句endwhile* repeat...untilrepeat    循环语句until(条件)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="阈值化处理"><a href="#阈值化处理" class="headerlink" title="阈值化处理"></a>阈值化处理</h2><p><strong>阈值化处理</strong>：得到变量结果是一个区域</p><ol><li>工具：灰度直方图（在工具栏中选择）</li><li>勾选阈值前的方框 </li><li>调整区域</li><li><p>插入代码：<code>threshold (GrayImage, Regions, min, max)</code></p><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">* 读取图像read_image(Image,'claudia')dev_display(Image)* RGB图像转为灰度图像rgb1_to_gray(Image,GrayImage)dev_display(GrayImage)* 选择合适的灰度范围* 依据灰度直方图确定参数threshold(GrayImage, Region, 0, 71)* 划分区域connection(Region,ConnectedRegions)* 选取面积最大的区域* 依据特征直方图确定参数select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 46071.4, 46468.3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="腐蚀与膨胀"><a href="#腐蚀与膨胀" class="headerlink" title="腐蚀与膨胀"></a>腐蚀与膨胀</h2></li></ol><ul><li>膨胀算法：<ul><li>扫描原图，找到第一个像素值为0的背景点；</li><li>将预先设定好形状以及原点位置的结构元素的原点移到该点；</li><li>判断该结构元素所覆盖的像素值是否存在为1的目标点：    </li><li>如果是，则膨胀后图像中的相同位置上的像素值为1；  </li><li>如果不是，则膨胀后图像中的相同位置上的像素值为0；</li><li>重复2）和3），直到所有原图中像素处理完成。</li></ul></li><li>腐蚀算法：<ul><li>扫描原图，找到第一个像素值为1的目标点；</li><li>将预先设定好形状以及原点位置的结构元素的原点移到该点；</li><li>判断该结构元素所覆盖的像素值是否全部为1：      </li><li>如果是，则腐蚀后图像中的相同位置上的像素值为1；      </li><li>如果不是，则腐蚀后图像中的相同位置上的像素值为0；</li><li>重复2）和3），直到所有原图中像素处理完成</li></ul></li></ul><h2 id="ROI-Region-Of-Interest-生成"><a href="#ROI-Region-Of-Interest-生成" class="headerlink" title="ROI (Region Of Interest) 生成"></a>ROI (Region Of Interest) 生成</h2><ul><li>感兴趣区域，即ROI 。ROI 就是从被处理的图像以方框、圆、椭圆、不规则多边形等方式勾勒出需要处理的区域，这个区域是图像分析所关注的重点。使用ROI可以减少计算量，加快图像处理速度，提高效率</li><li><p>选择ROI 的步骤 </p><ul><li>选择关注区域：在采集到原始图像后，即可通过图像处理得出特定区域，常规的有矩形、圆形以及椭<br>圆。此时，选择的区域还不能称为 ROI, 它还只是形状或者说是像素范围。</li><li>裁剪区域：如果要将这选择的区域变成独立的图像，还需要将其从原图上裁剪出来。在<br>Halcon 中可以通过 reduce_domain 算子将其截取出来成为单独的一幅图片。</li></ul><p>示例：</p><pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">read_image(Image,'claudia')* 获取图像的尺寸get_image_size (Image, Width, Height)* 获取窗口句柄dev_open_window(0, 0, Width, Height, 'black', WindowHandle)dev_display(Image)* 左上角坐标(50,100)，右下角坐标(120,250)* gen_rectangle1(Rectangle, 50, 100, 120, 250) * 裁剪出感兴趣区域* reduce_domain(Image, Rectangle, ImageReduced)* 交互式算子* 画一个长方形* draw_rectangle1(WindowHandle, Row1, Column1, Row2, Column2)* gen_rectangle1(Rectangle, Row1, Column1, Row2, Column2) * 画一个圆* 圆心坐标(Row, Column) 半径Radiusdraw_circle(WindowHandle, Row, Column, Radius)gen_circle(Circle, Row, Column, Radius)* 裁剪出感兴趣区域reduce_domain(Image, Circle, ImageReduced)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>也可以使用工具生成一个ROI </p></li></ul><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/ROI生成.jpg" style="zoom:70%;"></p><h2 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h2><p><strong>图像的平移旋转和缩放</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">变换</th><th style="text-align:center">算子</th></tr></thead><tbody><tr><td style="text-align:center">平移</td><td style="text-align:center">hom_mat2d_translate(: HomMat2D, Tx, Ty: HomMat2DTranslate)</td></tr><tr><td style="text-align:center">旋转</td><td style="text-align:center">hom_mat2d_rotate(: : HomMat2D, Phi, Px, Py : HomMat2DRotate)</td></tr><tr><td style="text-align:center">缩放</td><td style="text-align:center">hom_mat2d_scale(: : HomMat2D, Sx, Sy, Px, Py : HomMat2DScale)</td></tr></tbody></table></div><p><strong>Halcon中仿射变换相关算子</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">算子</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">hom_mat2d_identity(: : HomMat2DIdentity)</td><td style="text-align:center">创建一个仿射变换单位矩阵</td></tr><tr><td style="text-align:center">hom_mat2d_translate(: : HomMat2D, Tx, Ty: HomMat2DTranslate)</td><td style="text-align:center">设置平移参数</td></tr><tr><td style="text-align:center">hom_mat2d_rotate(: : HomMat2D, Phi, Px, Py : HomMat2DRotate)</td><td style="text-align:center">设置旋转参数</td></tr><tr><td style="text-align:center">hom_mat2d_scale(: : HomMat2D, Sx , Sy, Px, Py : HomMat2DScale)</td><td style="text-align:center">设置缩放参数</td></tr><tr><td style="text-align:center">affine_trans_image(Image : ImageAffinTrans : HomMat2D, Interpolation, AdaptlmageSize:)</td><td style="text-align:center">进行仿射变换</td></tr></tbody></table></div><pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">read_image (Image, 'a01.png')* 获得图像尺寸，打开窗口，读取图片get_image_size (Image, Width, Height)dev_open_window (0, 0, Width, Height, 'black', WindowID)dev_display (Image)* 转灰度图像rgb1_to_gray(Image, GrayImage)* 图像二值化threshold (Image, Regions, 164, 245)* 获取图像面积，中心点坐标area_center(Regions, Area, Row, Column)* 定义仿射变换矩阵hom_mat2d_identity (HomMat2DIdentity)* 设置平移矩阵至中心点坐标hom_mat2d_translate (HomMat2DIdentity, Height/2-Row, Width/2-Column, HomMat2DTranslate)* 通过仿射变换将图形移至中心点位置并显示图像affine_trans_image(GrayImage, ImageAffinTrans , HomMat2DTranslate, 'constant', 'false')dev_display(ImageAffinTrans)* 旋转变换* (Height/2, Width/2)为基准点hom_mat2d_rotate (HomMat2DTranslate, 3.14/2, Height/2, Width/2, HomMat2DRotate)affine_trans_image (ImageAffinTrans, ImageAffineTrans1, HomMat2DRotate, 'constant', 'false')dev_display (ImageAffineTrans1)* 设置等比例缩放矩阵，缩放倍数为 1.5 倍hom_mat2d_scale(HomMat2DIdentity, 1.5, 1.5, Height/2, Width/2, HomMat2DScale)affine_trans_image (ImageAffineTrans1, ImageAffineTrans2, HomMat2DScale, 'constant', 'false')dev_display (ImageAffineTrans2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>hom_mat2d_rotate</code>参数</p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/仿射变换_旋转算子.png" alt=""></p></li><li><p><code>hom_mat2d_scale</code>换参数</p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/仿射变换_缩放算子.png" alt=""></p></li></ul><p>点$(P_x,P_y)$是转换的固定点，也就是说，这个点在进行转换时保持不变。首先在输入的变换矩阵中加入一个平移，将固定点移到全局坐标系的原点上。然后，加入变换，最后加入一个平移，将固定点移回其原始位置。</p><p><strong>投影变换</strong></p><ul><li><p><code>hom_vector_to_proj_hom_mat2d( : : Px, Py, Pw, Qx, Qy, Qw, Method : HomMat2D)</code></p><ul><li>得到变换矩阵HomMat2D</li></ul><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/投影变换算子.jpg" style="zoom:67%;"></p><ul><li>其中</li></ul><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/投影算子.png" alt="投影算子" style="zoom: 50%;"></p></li></ul><ul><li><p><code>projective_trans_image(Image : TransImage : HomMat2D, Interpolation, AdaptImageSize, TransformDomain : )</code></p><ul><li><p>进行投影变换</p></li><li><p>Interpolation：图像的插值方式</p></li></ul></li><li><p>插值算法：</p><ul><li><p>对图像进行 平移，旋转，缩放 等变换后，元素可能变成非整数，那么此时需要将这些非整数转为整数输出。</p></li><li><p>最近邻插值：选取离目标点最近的点的灰度值作为新的插入点的灰度值</p></li><li><p>线性插值</p></li><li><p>双线性插值：选取最近的四个像素点做三次线性插值</p></li><li><p>双三次插值：在双三次插值法中，选取最近的16 个像素点计算目标图像处像素值</p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/插值算法.jpg" style="zoom:67%;"></p></li></ul></li></ul><p>示例：</p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/投影变换.png" style="zoom: 50%;"></p><pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">read_image (Image, '4-3.jpg')* 打开适合图片的窗口dev_open_window_fit_image (Image, 0, 0, -1, -1, WindowHandle)dev_display (Image)* 设置输出颜色为红色dev_set_color ('red') * 定义输出线宽为2dev_set_line_width(2)stop()* 定义坐标变量X := [163, 280, 362, 75]Y := [125, 120, 361, 340]* 为每个输入点生成十字形状的 XLD 轮廓* 6代表组成十字横线的长度，0.78 代表角度gen_cross_contour_xld(Crosses, X, Y, 6, 0.78)dev_display (Crosses)* 得到单应性矩阵hom_vector_to_proj_hom_mat2d (X, Y, [1,1,1,1], [75,360,360,75], [110,110,360,360], [1,1,1,1], 'normalized_dlt', HomMat2D)* 进行投影变换projective_trans_image(Image, Image_rectified , HomMat2D , 'bilinear', 'false','false')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h2><h3 id="灰度变换算子"><a href="#灰度变换算子" class="headerlink" title="灰度变换算子"></a>灰度变换算子</h3><ol><li><p>图像取反算子：<code>invert_image (Image : ImageInvert : :)</code></p><ul><li>$g’ := 255 - g$</li></ul></li><li><p>增加图像对比度算子：<code>emphasize(Image : ImageEmphasize : MaskWidth, MaskHeight, Factor : )</code></p><ul><li>$res := round((orig - mean)* Factor) + orig$</li><li>maskwidth 低通掩膜宽，maskheight 低通掩膜高</li><li>掩膜：用选定的图像，图形或物体，对处理的图像（全部或局部）进行遮挡，来控制图像处理的区域或处理过程。用于覆盖的特定图像或物体称为掩模或模板。掩模是由0和1组成的一个二进制图像。</li></ul></li><li><p>缩放图像的灰度：<code>scale_image(Image : ImageScaled : Mult, Add : )</code></p><ul><li><p>$g’ := g * Mult + Add$</p></li><li><p>[GMin, GMax]  $\Rightarrow$ [0,255]</p><ul><li>$Mult = \frac{255}{\text{GMax} - \text{GMin}}$, $Add = - Mult * \text{GMin}$</li></ul></li></ul></li></ol><pre class="line-numbers language-Halcon" data-language="Halcon"><code class="language-Halcon">read_image (Image, 'claudia')get_image_size (Image, Width, Height)rgb1_to_gray (Image, GrayImage)dev_open_window (0, 0, Width, Height, 'black', WindowHandle)* dev_display (GrayImage)* 图像取反invert_image (GrayImage, ImageInvert)dev_display (ImageInvert)* 对比度增强emphasize (GrayImage, ImageEmphasize, Width, Height, 2)dev_display (ImageEmphasize)* 图像灰度缩放scale_image (GrayImage, ImageScaled, 0.5, 50)dev_display (ImageScaled)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>直方图修正算子</strong></p><p>直方图均衡化：<code>equ_histo_image(GrayImage , ImageEquHisto)</code></p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/直方图均衡化.png" style="zoom:70%;"></p><p>直方图规定化是使原图像灰度直方图变成规定形状的直方图 而对图像作修正的增强方法，以满足特定的效果。直方图均衡化处理只是直方图规定化的一个特例。</p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/直方图规定化.jpg" style="zoom:80%;"></p><h3 id="图像的平滑"><a href="#图像的平滑" class="headerlink" title="图像的平滑"></a>图像的平滑</h3><p><strong>噪声</strong></p><ol><li><p>高斯噪声</p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/高斯噪声.png" style="zoom:70%;"></p><ul><li><code>gauss_distribution( : : Sigma : Distribution)</code></li><li><code>add_noise_distribution(Image : ImageNoise : Distribution : )</code></li></ul></li><li><p>椒盐噪声</p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/椒盐噪声.png" style="zoom:70%;"></p><ul><li><code>sp_distribution( : : PercentSalt, PercentPepper : Distribution)</code></li><li><code>add_noise_distribution(Image : ImageNoise : Distribution : )</code></li></ul></li></ol><p><strong>均值滤波</strong></p><p>图像邻域平均法算法简单，计算速度快但它的主要缺点是在降低噪声的同时使图像产生模糊，特别在边缘和细节处。<br>图像所用的邻域半径越大，则图像的模糊程度越大。</p><ul><li><p><code>mean_image(Image : ImageMean : MaskWidth, MaskHeight : )</code></p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/均值滤波.png" style="zoom:60%;"></p></li></ul><p><strong>中值滤波</strong></p><ul><li><code>median_image(Image : ImageMedian : MaskType, Radius, Margin : )</code><ul><li>MaskType: 掩膜类型，Radius: 掩膜尺寸</li><li>Margin: 边界处理</li></ul></li></ul><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/中值滤波.png" style="zoom:60%;"></p><p><strong>多图像平均法</strong></p><ul><li>$g(x,y) = f(x,y) + e(x,y)$</li><li>$\bar{g}(x,y) = \frac{1}{M} \sum_{i=1}^{M}g_{i}(x,y)$</li></ul><h3 id="图像锐化"><a href="#图像锐化" class="headerlink" title="图像锐化"></a>图像锐化</h3><ul><li>在图像的识别中常需要突出边缘和轮廓信息</li><li>图像锐化就是增强图像的边缘或轮廓</li></ul><p>图像细节的灰度变化特性</p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/图像细节的灰度变化特性.jpg" style="zoom:90%;"></p><ul><li>因为边缘和轮廓都位于灰度突变的地方 , 所以锐化算法的实现是基于微分作用。<script type="math/tex; mode=display">\bigtriangledown f(x,y)=\begin{bmatrix}  G_x\\  G_y\end{bmatrix}=\begin{bmatrix}  \frac{\partial f}{\partial x} \\  \frac{\partial f}{\partial y} \end{bmatrix} \ (f(x,y)\text{的梯度})\\\left | \bigtriangledown f(x,y) \right | = mag(\bigtriangledown f)=\sqrt{G_x^{2}+G_y^{2}}=\sqrt{\left ( \frac{\partial f}{\partial x}  \right )^2+ \left ( \frac{\partial f}{\partial y}  \right )^2} \  (\text{边缘的强度}) \\\alpha (x,y)=\arctan\left ( \frac{G_y}{G_x}  \right ) \  (\text{边缘的趋势 梯度方向始终垂直于边缘方向}) \\G_x = f(i+1,j) - f(i,j) \ \ G_y = f(i,j+1) - f(i,j) \ (\text{相邻像素间插值为1})水平垂直差分法</script></li></ul><p><strong>水平垂直差分法</strong></p><ul><li>用小区域模板卷积来近似计算偏导数</li><li>对$G_x$和$G_y$各用1个模板</li><li>需要2个模板组合起来构成1个梯度算子</li></ul><script type="math/tex; mode=display">G_x = \begin{bmatrix}  1 & -1\\            0 & 0\end{bmatrix} \ \ \ G_y = \begin{bmatrix}  1 & 0\\            -1 & 0\end{bmatrix}</script><p><strong>Roberts梯度</strong></p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/梯度差分.png" style="zoom: 50%;"></p><script type="math/tex; mode=display">\left | \bigtriangledown f(x,y) \right | = \left | f(i+1,j+1) - f(i,j) \right | + \left | f(i+1,j) - f(i,j+1) \right | \\G_x = \begin{bmatrix}  -1 & 0\\            0 & 1\end{bmatrix} \ \ \ G_y = \begin{bmatrix}  0 & -1\\            1 & 0\end{bmatrix}</script><p><strong>Sobel算子</strong></p><ul><li><p>采用梯度微分锐化图像同时会使噪声、条纹等得到增强，Sobel 算子则在一定程度上克服了这个问题</p></li><li><p>锐化的边缘信息较强</p></li></ul><script type="math/tex; mode=display">A = \begin{bmatrix}  1 & 2 & 1\\ 0 & 0 & 0 \\ -1 & -2 & -1\end{bmatrix} \ \ \ \ B = \begin{bmatrix}  1 & 0 & -1\\ 2 & 0 & -2 \\ 1 & 0 & -1\end{bmatrix}</script><ul><li><p><code>sobel_amp(Image : EdgeAmplitude : FilterType, Size : )</code></p><p> <img src="/2022/11/20/ji-qi-shi-jue-halcon/sobel算子参数.png" alt=""></p></li><li><p>a和b表示用A和B对一个特定像素进行卷积的结果</p><p> <img src="/2022/11/20/ji-qi-shi-jue-halcon/sobel算子参数2.png" style="zoom:50%;"></p></li></ul><pre class="line-numbers language-Halcon" data-language="Halcon"><code class="language-Halcon">read_image (Image, 'fabrik')* 边缘检测sobel_amp (Image, EdgeAmplitude, 'sum_abs', 3)* 阈值分割threshold (EdgeAmplitude, Regions, 15, 255)* 提取边缘框架skeleton (Regions, Skeleton)* 显示图片dev_display (Image)* 显示边缘框架dev_display (Skeleton)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Laplace算子</strong></p><ul><li>Sobel 算子获得的边界是比较粗略的边界，反映的边界信息较少，但是所反映的边界比较清晰</li><li>Laplace 算子获得的边界是比较细致的边界。反映的边界信息包括了许多的细节信息，但是所反映的边界不是太清晰。</li></ul><script type="math/tex; mode=display">\bigtriangledown ^2f=\frac{\partial^{2}f }{\partial x^2}+\frac{\partial^{2}f }{\partial y^2}=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)</script><ul><li><p>Laplace掩膜</p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/laplace掩膜.png" style="zoom:50%;"></p></li><li><p>把原图像和拉普拉斯图像叠加在一起的简单方法可以保护拉普拉斯锐化处理的效果，同时又能复原背景信息。</p><script type="math/tex; mode=display">g(x,y)=f(x,y)+\bigtriangledown ^2f(x,y)</script></li><li><p><code>laplace(Image : ImageLaplace : ResultType, MaskSize, FilterMask : )</code></p><p> <img src="/2022/11/20/ji-qi-shi-jue-halcon/laplace算子参数1.png" alt=""></p><p> <img src="/2022/11/20/ji-qi-shi-jue-halcon/laplace算子参数2.png" style="zoom: 40%;"></p></li></ul><pre class="line-numbers language-Halcon" data-language="Halcon"><code class="language-Halcon">* 获取图像read_image(Image, 'mreut')get_image_size (Image, Width, Height)dev_open_window (0, 0, Width, Height, 'black', WindowHandle)* 对图像进行拉普拉斯算子处理laplace(Image, ImageLaplace , 'signed',3, 'n_4')* 显示处理后的图像dev_display (ImageLaplace)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="频域处理"><a href="#频域处理" class="headerlink" title="频域处理"></a>频域处理</h3><ul><li>一幅图像灰度均匀的区域对应低频部分 (频域 — 亮)</li><li>图像中的噪声、边缘、细节对应高频部分 (频域 — 暗)</li></ul><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/频域处理.jpg" style="zoom: 60%;"></p><p>直接对数字图像进行二维 DFT 变换得到的频谱图是高频在中间低频在四角，为了把能量集中起来便于使用滤波器，可以利用二维<br>DFT 的平移性质对频谱进行中心化。</p><ul><li>$\mathscr{F}(f(x,y)(-1)^{x+y})=F(u-M/2,v-N/2)$</li><li>应用于将最亮的位置转移到图像中心</li></ul><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/频域处理.png" style="zoom:50%;"></p><div class="table-container"><table><thead><tr><th style="text-align:center">算子</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">fft_generic(Image : ImageFFT : <strong>‘to_freq’</strong>, Exponent, Norm, Mode, ResultType : )</td><td style="text-align:center">进行快速傅里叶变换</td></tr><tr><td style="text-align:center">gen_lowpass( : ImageLowpass : Frequency, Norm, Mode, Width, Height : )</td><td style="text-align:center">生成理想的低通滤波模型</td></tr><tr><td style="text-align:center">gen_highpass( : ImageHighpass : Frequency, Norm, Mode, Width, Height : )</td><td style="text-align:center">生成理想的高通滤波模型</td></tr><tr><td style="text-align:center">convol_fft(ImageFFT, ImageFilter : ImageConvol : : )</td><td style="text-align:center">在频域里卷积图像</td></tr><tr><td style="text-align:center">fft_generic(Image : ImageFFT : <strong>‘from_freq’</strong>, Exponent, Norm, Mode, ResultType : )</td><td style="text-align:center">进行快速傅里叶逆变换</td></tr></tbody></table></div><p><strong>fft_generic(Image : ImageFFT : Direction, Exponent, Norm, Mode, ResultType : )</strong></p><ul><li>方向参数Direction允许选择FFT的逻辑方向，可能的值是 “to_freq “(正变换)和 “from_freq”(逆变换)</li><li>参数Exponent用于确定指数的符号。可以设置为1(逆变换)或-1(正变换)</li><li>参数Norm用于设置归一化系数，可以取值为’none’、’sqrt’和’n’</li><li>参数Mode用于选择是否进行中心化处理，可以设置为 “dc_center “或 “dc_edge”。</li><li>参数ResultType用来指定逆变换( ‘from_freq’)的结果图像类型。在正变换中ResultType必须设置为’complex’</li></ul><pre class="line-numbers language-Halcon" data-language="Halcon"><code class="language-Halcon">* 低通滤波器示例* 读取图像 read_image (Image, 'panada')* 获取图像大小 get_image_size (Image, Width, Height)dev_open_window (0, 0, Width, Height, 'black', WindowHandle)* 显示图像dev_display (Image)* 得到低通滤波模型gen_lowpass (ImageLowpass, 0.1, 'none', 'dc_center', Width, Height)* 对图像进行傅里叶变换fft_generic (Image, ImageFFT, 'to_freq', -1, 'sqrt', 'dc_center', 'complex')* 对频率图像进行低通滤波convol_fft (ImageFFT, ImageLowpass, ImageConvol)* 对得到的频率图像进行傅里叶逆变换fft_generic (ImageConvol, ImageFFT1, 'from_freq', 1, 'sqrt', 'dc_center', 'real')dev_display (ImageFFT1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>同态滤波增强</strong></p><p>同态滤波是把图像的照明反射模型作为频域处理的基础，将<em>亮度范围压缩</em>和<em>对比度增强</em>的频域方法。</p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/同态滤波.jpg" alt=""></p><p>同态滤波是改善图像照度不均的一种方法，以便后续进行二值化处理。</p><h2 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h2><h3 id="阈值分割"><a href="#阈值分割" class="headerlink" title="阈值分割"></a>阈值分割</h3><p>阈值分割法是一种基于区域的图像分割技术，它不仅可以极大的压缩数据量 ，而且也大大 简化了分析和处理步骤。<br>阈值分割法是一种传统的最常用的图像分割方法，特别适用于目标和背景占据不同灰度级范围的图像。</p><p>图像的阈值分割是一种按图像像素灰度幅度进行分割的方法，把图像的灰度分成不同的等级，然后用设置灰度门限（阈值）的方法确定有意义的区域或要分割物体的边界。阈值分割操作被定义为：</p><ul><li>$S = \{(r,c)\in R|g_{min} \leq f_{r,c} \leq g_{max}\}$</li></ul><p><strong>根据直方图谷底确定阈值法</strong></p><p>如果图像由暗色背景上的较亮物体组成，以这样组成方式的图像的灰度直方图具有明显谷底，从背景中提取物体的一种很明显的方法就是选择两峰之间的谷底对应的灰度值 $T$ 作为阈值进行图像分割。</p><script type="math/tex; mode=display">g(x) = \left\{\begin{matrix} 255,\ f(x,y) \ge T\\  0 , f(x,y) < T\end{matrix}\right.</script><p>手动阈值分割算子：<code>threshold(Image : Region : MinGray, MaxGray : )</code></p><pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">read_image (Image, 'letters')get_image_size (Image, Width, Height)rgb1_to_gray (Image, GrayImage)dev_close_window ()dev_open_window (0, 0, Width, Height, 'black', WindowHandle)* 计算图像的灰度直方图* AbsoluteHisto 绝对灰度直方图* RelativeHisto 相对灰度直方图 (归一化)gray_histo (GrayImage, GrayImage, AbsoluteHisto, RelativeHisto)* 通过直方图得到灰度的阈值* Sigma高斯平滑的系数histo_to_thresh (RelativeHisto, 8, MinThresh, MaxThresh)dev_set_colored(12)threshold (GrayImage, Region, MinThresh[0], MaxThresh[0])dev_display (Region)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>基于直方图的自动阈值分割</strong></p><ul><li>算子：<code>auto_threshold (Image : Regions : Sigma)</code></li></ul><pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">read_image (Aegypt, 'egypt1')get_image_size (Aegypt, Width, Height)dev_close_window ()dev_open_window (0, 0, Width, Height, 'black', WindowHandle)* 自动阈值分割auto_threshold (Aegypt, Regions, 4)dev_display (Regions)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>局部阈值分割</strong></p><ul><li><p>适用于一些无法用单一灰度进行分割的情况</p><ul><li>背景灰度比较复杂，有的部分比前景目标亮，有的部分比前景目标暗</li><li>前景目标包含多种灰度，因而无法用全局阈值完成分割</li></ul></li><li><p>该算子利用邻域，通过局部灰度对比，找到一个合适的阀值进行分割</p></li></ul><p>算子：<code>dyn_threshold(OrigImage, ThresholdImage : RegionDynThresh : Offset, LightDark : )</code></p><ul><li><p>dyn_threshold算子的应用步骤一般分三步：</p><ol><li>读取原始图像；</li><li>使用平滑滤波器对原始图像进行适当平滑；</li><li>使用 dyn_threshold 算子比较原始图像与均值处理后的图像局部像素差异，将差异大于设定值的点提取出来。</li></ol></li><li><p>dyn_threshold从输入图像中选择那些像素满足阈值条件的区域。</p></li><li><p><code>g_{o} = g_{OrigImage}</code>，<code>g_{t} = g_{ThresholdImage}</code></p><ul><li><code>LightDark = 'light'</code>的条件为：$g_0 \ge g_t + offset$ (找到更亮的部分)</li><li><code>LightDark = 'dark'</code>的条件为：$g_0 \le g_t - offset$ (找到更暗的部分)</li><li><code>LightDark = 'equal'</code>的条件为：$g_t-offset \le g_0 &lt; g_t + offset$</li><li><code>LightDark = 'not_equal'</code>的条件为：$g_t-offset &gt; g_0 \vee g_0 &gt; g_t + offset$</li></ul></li></ul><pre class="line-numbers language-HALCON" data-language="HALCON"><code class="language-HALCON">read_image(Image,  'photometric_stereo/embossed_01')* 均值滤波mean_image (Image, ImageMean, 59, 59)* 局部阈值分割dyn_threshold (Image, ImageMean, RegionDynThresh, 15, 'not_equal')dev_display (Image)dev_display (RegionDynThresh)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h3><ul><li>运用一阶微分算子检测边缘：Robert、Sobel、Prewitt、Kirsch</li><li>运用二阶微分算子检测边缘：Laplace算子、Log算子、Canny算子</li></ul><p><strong>Prewitt算子</strong></p><script type="math/tex; mode=display">A = \begin{bmatrix}  -1 & -1 & -1\\ 0 & 0 & 0 \\ 1 & 1 & 1\end{bmatrix} \ \ \ \ B = \begin{bmatrix}  -1 & 0 & 1\\ -1 & 0 & 1 \\ -1 & 0 & 1\end{bmatrix}</script><p>利用像素点上下、左右邻点的灰度差，在边缘处达到极值检测边缘，去掉部分伪边缘，对噪声具有平滑作用</p><p>特点：与 Sobel 相比，有一定的抗干扰性。 能抑止噪声的影响， 图像效果比较干净。</p><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">read_image(Image,'fabrik')* 用Prewitt算子进行边缘提取prewitt_amp (Image, ImageEdgeAmp)* 阈值化操作threshold (ImageEdgeAmp, Region, 20, 255)* 骨骼化操作skeleton (Region, Skeleton)dev_display(Skeleton)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Kirsch算法</strong></p><p>Kirsch算法由$K_0 \sim K_7$八个方向的模板决定，将$K_0 \sim K_7$的模板元素分别与当前像素点的模板区域的像素点相乘，然后选八个值中最大的值作为中央像素的边缘强度。</p><script type="math/tex; mode=display">g(x, y)=\max \left(g_{0}, g_{1}, \cdots, g_{T}\right) \quad g_{i}(x, y)=\sum_{k=-1}^{1} \sum_{l=-1}^{1} K_{i}(k, l) f(x+k, y+l)</script><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/Kirsch.jpg" alt=""></p><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">read_image(Image,'fabrik')kirsch_amp (Image, ImageEdgeAmp)* 阈值化操作threshold (ImageEdgeAmp, Region, 70, 255)* 骨骼化操作skeleton (Region, Skeleton)dev_display(Skeleton)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Log算子</strong></p><ul><li><p>利用图像强度二阶导数零交叉点求边缘点的算法，对噪声十分敏感</p><script type="math/tex; mode=display">\begin{array}{l}f(x, y)=s(x, y)+n(x, y)  \ \ \ \ \ n(x)=a \sin (\omega x) \\\frac{\partial n(x)}{\partial x}=a \omega \cos (\omega x) \ \ \ \frac{\partial^{2} n(x)}{\partial x^{2}}=-a \omega^{2} \sin (\omega x)\end{array}</script></li><li><p>高斯 — 拉普拉斯 (LoG : Laplacianof a Gaussian) 边缘检测算子，先采用高斯算子对原图像进行平滑，然后再施以Laplacian 算子，可克服 Laplacian 算子对噪声敏感的缺点，减少噪声的影响。</p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/Log.jpg" alt=""></p></li><li><p>高斯函数的优点</p><ul><li>高斯函数具有旋转对称性 ，用其对图像进行平滑运算时在各个方向上的平滑程度相同 ，边缘检测等操作中不会偏袒某一方向上的图像的细节。</li><li>随着离高斯模板中心点越远，权值越小，这使得高斯滤波器比起普通的平滑滤波器更能更好地保留图像细节 。如果距离越远的点权值越重的话，那图像就会失真。</li><li>在平滑图像去除噪声和保留图像的信息间找到平衡点。sigma参数越大 ，高斯函数的图谱就越低矮平缓，表现在频谱上就是频带越宽， 平滑程度高；反之sigma参数越小，平滑程度越低 。</li><li>二维高斯函数的取值半径（即卷积核大小）越大，平滑程度越高。</li></ul></li><li>减少运算量 — $\frac{d}{d x}(f <em> g)=f </em> \frac{d}{d x} g$</li><li>二阶微分</li></ul><script type="math/tex; mode=display">\begin{array}{l} h(x, y)=\frac{1}{2 \pi \sigma^{2}} e^{-\frac{x^{2}+y^{2}}{2 \sigma^{2}}} \\\nabla^{2}(h(x, y) * f(x, y))=\nabla^{2} h(x, y)^{*} f(x, y) \\\nabla^{2} h(x, y)=\frac{\partial^{2} h(x, y)}{\partial x^{2}}+\frac{\partial^{2} h(x, y)}{\partial y^{2}}=\frac{1}{\pi \sigma^{4}}\left(\frac{x^{2}+y^{2}}{2 \sigma^{2}}-1\right) e^{-\frac{x^{2}+y^{2}}{2 \sigma^{2}}}\end{array}</script><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">read_image (Image, 'mreut')laplace_of_gauss (Image, ImageLaplace, 5)zero_crossing (ImageLaplace, RegionCrossing)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Canny算子</strong></p><p>John Canny 于 1986 年提出 Canny 算子，它与 LoG 算子类似，属于先平滑后求导方法。</p><p>Canny 边缘检测步骤</p><ul><li><p>用高斯滤波器平滑图像</p><script type="math/tex; mode=display">g(x, y)=h(x, y ; \sigma) * f(x, y)</script></li><li><p>用一阶偏导的有限差分来计算梯度的幅值和方向</p><script type="math/tex; mode=display">\begin{array}{l}G_{x}(x, y) \approx[g(x+1, y)-g(x, y)+g(x+1, y+1)-g(x, y+1)] / 2 \\G_{y}(x, y) \approx[g(x, y+1)-g(x, y)+g(x+1, y+1)-g(x+1, y)] / 2\end{array}</script><p>幅值和方向角</p><script type="math/tex; mode=display">\begin{array}{l}M(x, y)=\sqrt{G_{x}(x, y)^{2}+G_{y}(x, y)^{2}} \\\theta(x, y)=\arctan \left\lfloor G_{y}(x, y) / G_{x}(x, y)\right\rfloor\end{array}</script></li></ul><ul><li><p>对梯度幅值应用非极大值抑制 (Non-maximum sippression, NMS)</p><p><a href="https://blog.csdn.net/qq_45717425/article/details/120641010">https://blog.csdn.net/qq_45717425/article/details/120641010</a></p></li></ul><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/Non-maximum sippression.jpg" style="zoom: 50%;"></p><ul><li><p>用双阈值算法检测和连接边缘</p><p>将低于阈值的所有值赋零值，得到图像的边缘阵列。阈值$T$的大小对边缘的影响：</p><ul><li>阈值$T$ 取得太低时，阴影等形成假边缘 ;</li><li>阈值$T$ 取得太高时，部分轮廊丢失。</li></ul><p>选用两个阈值 : 更有效的阈值方案。</p><ul><li>取高低两个阈值作用在幅值图$M[i,j], \  T_2 = 2 T_1$ ,得到两个边缘图， 高阈值和低阈值边缘图。连接高阈值边缘图，出现断点时，在低阈值边缘图中的 8 邻点域搜寻边缘点。</li></ul><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">read_image (Image, 'fabrik')* 'canny' 使用canny算子, 'nms'非极大值抑制, 12 22 低阈值和高阈值* ImaAmp, ImaDir：幅值，方向edges_image (Image, ImaAmp, ImaDir, 'canny', 1, 'nms', 12, 22)threshold (ImaAmp, Edges, 1, 255)skeleton (Edges, Skeleton)* 亚像素轮廓提取gen_contours_skeleton_xld (Skeleton, Contours, 1, 'filter')dev_display (Image)dev_set_colored (6)dev_display (Contours)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>其他算子</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">滤波器</th><th style="text-align:center">函数</th><th style="text-align:center">与滤波系数关系</th></tr></thead><tbody><tr><td style="text-align:center">sobel</td><td style="text-align:center">/</td><td style="text-align:center">与滤波系数无关，速度最快，噪声干扰影响较大</td></tr><tr><td style="text-align:center">canny</td><td style="text-align:center">$g(x)=\frac{-x}{\sqrt{2 \pi} \sigma^{3}} e^{-x^{2} /\left(2 \sigma^{2}\right)}$</td><td style="text-align:center">滤波系数越大，轮廓越平滑</td></tr><tr><td style="text-align:center">deriche1</td><td style="text-align:center">$-\alpha^{2} x e^{-\alpha{\lvert x \rvert}}$</td><td style="text-align:center">滤波系数越小，轮廓越平滑，与canny相比，该方法更贴近真实轮廓</td></tr><tr><td style="text-align:center">deriche2</td><td style="text-align:center">$-2 \alpha \sin (\alpha x) e^{-\alpha{\lvert x \rvert}}$</td><td style="text-align:center">滤波系数越小，轮廓越平滑，与deriche1相比，收敛性比较好</td></tr><tr><td style="text-align:center">lanser1</td><td style="text-align:center">$-\alpha^{2} x e^{-\alpha{\lvert x \rvert}}$</td><td style="text-align:center">滤波系数越小，轮廓越平滑，与deriche相比，该算法是在角度幅值上进行轮廓提取，对角度进行修正</td></tr><tr><td style="text-align:center">lanser2</td><td style="text-align:center">$-\alpha^{2} x e^{-\alpha{\lvert x \rvert}}$</td><td style="text-align:center">滤波系数越小，轮廓越平滑，与lanser1相比，收敛性比较好</td></tr><tr><td style="text-align:center">shen</td><td style="text-align:center">$-\alpha e^{-\alpha{\lvert x \rvert}}$</td><td style="text-align:center">滤波系数越小，轮廓越平滑，精度方面比Canny高，精度没有deriche和lanser高，速度比deriche和lanser快</td></tr></tbody></table></div><p><strong>亚像素级别的边缘提取</strong></p><p>点与点之间的最小距离就是一个像素的宽度，但实际工程中可能会需要比一个像素宽<br>度更小的精度，因此就有了亚像素级精度的概念，用于提高分辨率。</p><p>Halcon中用 XLD(eXtended Line Descriptions) 表示亚像素的轮廓和多边形。提取<br>亚像素边缘常用的算子如下所示：</p><ul><li><code>edges_sub_pix (Image:Edges:Filter, Alpha, Low,High:)</code></li></ul><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/亚像素边缘提取.jpg" alt=""></p><h3 id="区域分割"><a href="#区域分割" class="headerlink" title="区域分割"></a>区域分割</h3><p>将具有相同属性的像素归为同一区域</p><p>传统的区域分割方法</p><ul><li>区域生长法</li><li>区域分割与合并法</li></ul><p><strong>区域生长法</strong></p><ul><li>首先，选择合适的种子，在图像上选定一个种子像素或者种子区域</li><li>然后，确定区域生长准则，从种子的邻域像素开始搜寻，将种子像素周围邻域中与种子像素有相同性质或相似性质的像素根据某种事先确定的生长或相似准则来判断合并到种子像素所在的区域中</li><li>最后，确定区域生长的终止条件，进一步将这些新像素作为新的种子像素继续进行上述操作，直到再没有满足条件的像素可被包括进来为止，图像分割随之完成 。</li></ul><p>Halcon中区域增长的算子</p><ul><li><p>regiongrowing (Image : Regions : Row, Column, Tolerance, MinSize :)</p><p>Row：测试的两个像素点间的垂直距离</p><p>Column：测试的两个像素点间的水平距离</p></li><li><p>regiongrowing_mean (Image : Regions : StartRows, StartColumns, Tolerance, MinSize :)</p></li></ul><p>条件</p><ul><li>区域边缘的灰度值与当前均值图中对应的灰度值的差小于Tolerance参数的值</li><li>区域包含的像素数应大于MinSize参数的值</li></ul><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">read_image (Image, 'fabrik')* 对图像进行均值处理，选用circle类型的中值滤波器median_image (Image, ImageMedian, 'circle', 2, 'mirrored')* 使用regiongrowing算子寻找颜色相近的邻域regiongrowing (ImageMedian, Regions, 1, 1, 2, 5000)* 对图像进行区域分割，提取满足各个条件的各个独立区域* skeleton (Regions, Skeleton)* 提取骨架上距离重心最近的一点shape_trans (Regions, Centers, 'inner_center')connection (Centers, SingleCenters)* 计算出初步提取的区域的中心点坐标area_center (SingleCenters, Area, Row, Column)* 以均值灰度图像为输入进行区域增长计算，计算起始坐标为上一步的各区域中心* Row, Column 种子点regiongrowing_mean (ImageMedian, RegionsMean, Row, Column, 25, 100)connection (RegionsMean, ConnectedRegions)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>区域分裂合并法</strong></p><ul><li>当事先完全不了解区域形状和区域数目时，可采用分裂合并法。</li><li>图像阈值分割法可以认为是从上到下对图像进行分割。区域生长法相当于从下往上不断对像素进行合并 。将这两种方法结合起来对图像进行划分，便是分裂合并算法 。</li><li><p>先把图像分成任意大小而且不重叠的区域，然后再合并或分裂这些区域以满足分割的要求 。</p></li><li><p>令$R$表示整幅图像区域，并选择一个属性$Q$。对$R$进行分割的一种方法是依次将它细分为越来越小的四象限区域，以便对于任何区域$R_i$有$Q(R_i) = TRUE$，从整个区域开始，如果$Q(R) = FALSE$，则将该区域再次细分为四个子象限区域，以此类推。</p></li></ul><p>前述讨论可以小结为如下过程：</p><ol><li><p>对$Q(R_i ) = FALSE$满足的任何区域$R_i$, 分裂为4个不相交的象限区域。</p></li><li><p>当不可能进一步分裂时，对满足$Q(R_j \cup R_k ) = TRUE$条件的任意两个邻接区域$R_j$和$R_k$进行聚合。</p></li><li>当无法进一步聚合时，终止算法。</li></ol><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/四叉树.png" alt=""></p><p>利用四叉树进行图像分割</p><ul><li>在图像四叉树分割时，需要用到图像区域内和区域间的均一性</li><li>均一性准则是区域是否合并的判断条件，可以选择的形式有<ol><li>区域中灰度最大值与最小值的方差小于某选定值；</li><li>两区域平均灰度之差及方差小于某选定值；</li><li>两区域的纹理特征相同；</li><li>两区域参数统计检验结果相同；</li><li>两区域的灰度分布函数之差小于某选定值。</li></ol></li></ul><h3 id="霍夫变换-Hough-Transformation"><a href="#霍夫变换-Hough-Transformation" class="headerlink" title="霍夫变换 (Hough Transformation)"></a>霍夫变换 (Hough Transformation)</h3><ul><li><p><a href="https://blog.csdn.net/leonardohaig/article/details/87907462">https://blog.csdn.net/leonardohaig/article/details/87907462</a></p></li><li><p>在实际中由于噪声和光照不均等因素，使得在很多情况下所获得的边缘点是不连续的。</p></li><li>典型的边缘检测算法遵循用链接过程把像素组装成有意义的边缘的方法。</li><li>一种寻找并链接图像中线段的处理方式是 Hough 变换。</li></ul><p><strong>Hough检测直线</strong></p><ul><li>==给定图像坐标空间的边缘点，就可以通过Hough变换确定连接这些点的直线方程==</li></ul><p>直线的极坐标表示</p><ul><li><p>$\rho = x\cos\theta + y\sin\theta$</p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/hough极坐标系.png" alt=""></p></li></ul><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/hough.png" style="zoom:50%;"></p><ul><li>$x-y$图像空间的一条直线，对应于$\rho-\theta$空间中的一点，这种线到点的变换就是Hough变换</li><li><p>$x-y$空间的一个特征点$(x_i,y_i)$对应于$\rho-\theta$空间的一条正弦曲线$\rho = x_i\cos\theta + y_i\sin\theta$</p></li><li><p>$x-y$空间中一条直线上的$n$个点对应于$\rho-\theta$空间中 经过一个公共点的$ n $条曲线；</p></li><li><p>$ρ - θ $空间中 一条正弦曲线上的$ m $点对应于$ x - y $空间中过一公共点的$ m $条直线。</p></li></ul><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/hough4.png"></p><p><strong>Hough变换直线检测算法</strong></p><ul><li>量化参数空间，建立二维累加数组，并初始化为$0$;</li><li>把图像空间的每一特征点的坐标代入直线极坐标方程</li><li>根据$ r $和$ θ $的值，在相应的数组元素上加$ 1$;</li><li>所有目标点处理完毕后，找出累加数组中最大元素值，即为直线模型参数$(r^<em>,θ^</em>)$</li></ul><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/hough直线检测算法.png" alt=""></p><p><strong>Halcon算子</strong></p><p><code>hough_lines_dir(ImageDir : HoughImage, Lines : DirectionUncertainty, AngleResolution, Smoothing, FilterSize, Threshold, AngleGap, DistGap, GenLines : Angle, Dist)</code></p><ul><li><p><code>ImageDir</code>：Image containing the edge direction. The edges are described by the image domain.</p></li><li><p><code>DirectionUncertainty</code>：Uncertainty of edge direction (in degrees) — 能够容忍的边缘角度的偏差值</p></li><li><p><code>AngleResolution</code>：Resolution in the angle area (in 1/degrees) — 角度区域的分辨率</p></li><li><p><code>Smoothing</code>：Smoothing filter for hough image</p></li><li><p><code>FilterSize</code>：Required smoothing filter size</p></li><li><p><code>Threshold</code>：$ r $和$ θ $出现次数的阈值，可以调整最终得到图像的个数</p></li><li><p><code>AngleGap</code>：Minimum distance of two maxima in the Hough image (direction: angle) — 约束$\theta$</p></li><li><p><code>DistGap</code>：Minimum distance of two maxima in the Hough image (direction: distance)— 约束$\rho$</p></li><li><p><code>GenLines</code>：Create line regions if ‘true’</p></li></ul><pre class="line-numbers language-Halcon" data-language="Halcon"><code class="language-Halcon">read_image (Image, 'fabrik')* 提取ROIrectangle1_domain (Image, ImageReduced, 170, 280, 310, 360)* Sobel边缘检测sobel_dir (ImageReduced, EdgeAmplitude, EdgeDirection, 'sum_abs', 3)threshold (EdgeAmplitude, Region, 55, 255)*截取图像reduce_domain (EdgeDirection, Region, EdgeDirectionReduced)* Hough变换hough_lines_dir (EdgeDirectionReduced, HoughImage, Lines, 4,2, 'mean', 3, 27, 5, 5, 'true', Angle, Dist)* 将Hough变换提取直线以普通形式描述的输入行存储为区域gen_region_hline (LinesHF, Angle, Dist)* 显示dev_display (Image)dev_set_colored (12)dev_set_draw ('margin') dev_display (LinesHF) dev_set_draw ('fill')dev_display (Lines)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Hough检测圆</strong></p><p>霍夫圆算法的实现一共可分为两个步骤：</p><ol><li>建立霍夫参数三维空间，并对空间内各个单元进行投票</li><li>设置阈值从投票结果中筛选合适的圆，并做非极大化抑制</li></ol><p><a href="https://blog.csdn.net/weixin_42044695/article/details/117793536">https://blog.csdn.net/weixin_42044695/article/details/117793536</a></p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/hough圆.png" style="zoom: 50%;"></p><p>​                          $\nabla I(x,y)$为$(x,y)$的梯度                                                   选择 $a,b,r $作为参数，变换到参数空间后，即对应一个圆锥</p><p>对$a,b,r $三维参数空间投票，计算量大</p><p>Hough梯度法</p><ul><li><p>梯度方向垂直于边缘方向</p></li><li><p>圆周上点的梯度方向相交于圆心</p></li><li><p>先找圆心，再由圆心确定半径</p></li></ul><p>算法：</p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/hough圆3.png" alt=""></p><script type="math/tex; mode=display">\begin{array}{l}a=x_{i}-r \cos \theta_{i} \quad r=\frac{x_{i}-a}{\cos \theta_{i}} \\b=y_{i}-r \sin \theta_{i} \\b=y_{i}-r \sin \theta_{i}=y_{i}-\left(x_{i}-a\right) \frac{\sin \theta_{i}}{\cos \theta_{i}} \\b=a \tan \theta_{i}-x_{i} \tan \theta_{i}+y_{i}\end{array}</script><p>变换圆检测算法操作步骤如下:</p><ol><li><p>根据精度要求, 量化参数空间 $ a  $和$  b $，由此建立二维累加数组$  A(a, b)$，并将其初始化为零。</p></li><li><p>计算边缘轮廓图像的梯度角正切值。</p></li><li><p>自上而下、自左向右扫描图像，如果检测到当前点$  (x, y) $ 是边缘点，查找当前点所对应的梯度角正切值，然后根据公式$  b=a \tan \theta_{i}-x_{i} \tan \theta_{i}+y_{i}  $计算出每一个$  a  $对应的$  b  $值。</p></li><li><p>根据 $ a  $和$  b  $的值, 执行$  A(a, b)=A(a, b)+1  $。 </p></li><li>循环执行步骤 3、4，直到所有点全部处理完毕。</li><li>找到累加数组中最大元素值对应坐标位置，该结果即为圆心坐标。</li><li>将圆心坐标代入图像空间中圆的方程式计算所有边缘点至圆心坐标的距离， 找到距离数据中出现频率最高的值，即为圆的半径参数。</li></ol><p><strong>Halcon算子</strong></p><ul><li><p>hough_circles — Centres of circles for a specific radius.</p><p><code>hough_circles(RegionIn : RegionOut : Radius, Percent, Mode : )</code></p><ul><li>Percent：圆在图中的面积占比</li><li>Mode：定义了圆的位置</li></ul></li><li><p>hough_circle_trans — Return the Hough-Transform for circles with a given radius</p><p><code>hough_circle_trans(Region : HoughImage : Radius : )</code></p></li></ul><h3 id="分水岭分割算法"><a href="#分水岭分割算法" class="headerlink" title="分水岭分割算法"></a>分水岭分割算法</h3><p>“分水岭”这个名字与一种地貌特点有关，它的思想是，把图像的灰度看作一张地形图，图像中的每一点像素的灰度值表示该点的海拔高度，高灰度值代表山脉，低灰度值代表盆地，每一个局部极小值及其影响区域称为集水盆，而集水盆的边界则形成分水岭。</p><p>分水岭算法</p><ol><li><strong>局部最小值点</strong>，该点对应一个盆地的最低点，当我们在盆地里滴一滴水的时候，由于重力作用，水最终会汇聚到该点。注意：可能存在一个最小值面，该平面内的都是最小值点。</li><li><strong>盆地的其它位置点</strong>，该位置滴的水滴会汇聚到局部最小点。</li><li><strong>盆地的边缘点</strong>，是该盆地和其它盆地交接点，在该点滴一滴水，会等概率的流向任何一个盆地。</li></ol><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/分水岭.png" alt=""></p><p>分水岭算法的整个过程：</p><ol><li>把梯度图像中的所有像素按照灰度值进行分类，并设定一个测地距离 (Geodesic Distance)阈值。</li><li>找到灰度值最小的像素点（默认标记为灰度值最低点），让threshold从最小值开始增长，这些点为起始点。</li><li>水平面在增长的过程中，会碰到周围的邻域像素，测量这些像素到起始点（灰度值最低点）的测地距离 (Geodesic Distance)，如果小于设定阈值，则将这些像素淹没，否则在这些像素上设置大坝，这样就对这些邻域像素进行了分类。</li><li>随着水平面越来越高，会设置更多更高的大坝，直到灰度值的最大值，所有区域都在分水岭线上相遇，这些大坝就对整个图像像素的进行了分区。</li></ol><p>在真实图像中，由于噪声点或者其它干扰因素的存在，使用分水岭算法常常存在过度分割的现象，这是因为很多很小的局部极值<br>点的存在，这样的分割效果是毫无用处的。</p><p>其中的解决方法：</p><ol><li>对图像进行高斯平滑操作，抹除很多小的最小值，这些小分区就会合并。</li><li>不从最小值开始增长，可以将相对较高的灰度值像素作为起始点（需要用户手动标记），从标记处开始进行淹没，则很多小区域都会被合并为一个区域，这被称为<strong>基于图像标记(mark)的分水岭算法</strong>。。</li></ol><p>分水岭算法常用的操作步骤：</p><ol><li>彩色图像灰度化；</li><li>求梯度图；</li><li>在梯度图的基础上进行分水岭算法，求得分段图像的边缘线。</li></ol><p><strong>Halcon算子</strong></p><ol><li><p>直接提取图像的盆地区域和分水岭区域算子如下：</p><p><code>watersheds(Image : Basins, Watersheds : : )</code></p></li><li><p>阈值化提取分水岭盆地区域算子如下：<br><code>watersheds_threshold(Image : Basins : Threshold : )</code></p></li></ol><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/watersheds_threshold.png" alt=""></p><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">read_image (Br2, 'particle')*对单通道图像进行高斯平滑处理，去除噪声gauss_filter (Br2, ImageGauss, 9)*将图像颜色进行反转invert_image (ImageGauss, ImageInvert)*对平滑后图像进行分水岭处理与阈值分割，提取出盆地区域watersheds (ImageInvert, Basins, Watersheds)watersheds_threshold (ImageInvert, Basins1,30)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h2><p>为了使计算机能够理解图像，我们需要从图像中提取有用的数据或信息，因此需要确定一个或多个特征量 。这些我们确定的特征量被称为特征，这一过程就是特征提取 。</p><p><strong>图像特征分类</strong></p><ul><li>自然特征：大小，亮度，颜色，轮廓，边缘，纹理等</li><li>人为特征：直方图、矩特征、熵等</li></ul><p><strong>特征提取的一般规则</strong></p><ul><li>良好的区别性：同类之间差异小，不同类之间差异大</li><li>稳定的可靠性：内容小规模变化时不受影响，如对噪声不敏感</li><li><p>特征信息不相关：相互独立、减少冗余</p></li><li><p>较小数据量：容易提取，维数不应过大，减少特征匹配的计算量</p></li></ul><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/特征.png" style="zoom: 33%;"> </p><h3 id="区域形状特征"><a href="#区域形状特征" class="headerlink" title="区域形状特征"></a>区域形状特征</h3><p>在场景中选择物体的特征是图像测量或者识别的重要基础。在特征提取中，区域的形状特征是非常常用的特征，包括区域面积、中心点坐标、区域的宽度和高度等特征量</p><div class="table-container"><table><thead><tr><th style="text-align:center">特征</th><th style="text-align:center">算子</th></tr></thead><tbody><tr><td style="text-align:center">面积 / 中心点</td><td style="text-align:center">area_center (Regions : : : Area, Row, Column)</td></tr><tr><td style="text-align:center">Area:对所有点的灰度值求和 /  (Row, Column) 重心</td><td style="text-align:center">area_center_gray (Regions, Image : : : Area, Row, Column)</td></tr><tr><td style="text-align:center">封闭区域（孔洞）的面积 (返回所有孔洞区域的面积之和)</td><td style="text-align:center">area_holes (Regions : : : Area)</td></tr></tbody></table></div><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">* 获取图像                           read_image (Image, 'fabrik')* 关闭窗口                           dev_close_window ()* 打开窗口                           dev_open_window (0, 0, 512, 512, 'black', WindowID)* 设置输出字体，14号字，Courier字体，粗体       set_display_font (WindowID, 14, 'mono','true', 'false')* 设置输出颜色                    dev_set_colored (6)* 进行区域生长操作              regiongrowing (Image, Regions, 1, 1, 3, 200)* 显示区域                          dev_display (Regions)* 计算所有不相连区域的面积和中心点坐标       area_center (Regions, Area, Row, Column)* 获取一个字符串的空间大小 (显示5位字符串的宽和高)get_string_extents (WindowID, 12345, Ascent, Descent, TxtWidth, TxtHeight)* 将面积计算结果以字符串形式显示在窗口中    disp_message (WindowID, Area, 'image',Row - TxtHeight / 2, Column - TxtWidth / 2, 'white', 'false')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">* 关闭窗口                        dev_close_window ()* 读取图像                        read_image (Image, 'rings_and_nuts')* 打开适应图像大小的窗口dev_open_window_fit_image (Image, 0, 0, -1, -1, WindowHandle)* 设置输出颜色                 dev_set_color ('red')* 设置输出字体，14号字，Courier字体，粗体       set_display_font (WindowHandle, 14, 'mono', 'true', 'false')* 显示图像                        dev_display (Image)* 进行阈值操作 (提取白色区域)                threshold (Image, Region, 128, 255)* 计算区域中孔的面积       area_holes (Region, Area)* 将面积计算结果以字符串形式显示在窗口中       disp_message (WindowHandle, 'Size of enclosed area (holes): ' + Area + ' pixel', 'window', 12, 12, 'black', 'true')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>根据特征值选择区域</strong></p><p>区域的常用特征</p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/区域特征.png" style="zoom:50%;"></p><p>根据特征值选择区域</p><p><code>Select_shape(Regions: SelectedRegions: Features, Operation, Min, Max: )</code></p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/select_shape.png" alt=""></p><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">* 读取图像read_image (Image, 'monkey')threshold (Image, Region, 128, 255)* 将非连通区域分割成一组区域的集合connection (Region, ConnectedRegions)* 利用面积以及椭圆长轴与短轴的比值特征，将眼睛部分区域提取出来* 'anisometry'宽和高的比值select_shape (ConnectedRegions, SelectedRegions,['area','anisometry'], 'and', [500,1], [2000,1.7])* 显示结果区域dev_display (SelectedRegions)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>根据灰度特征值选择区域 select_gray</strong></p><p><code>select_gray(Regions, Image : SelectedRegions : Features, Operation, Min, Max : )</code></p><p><img src="/2022/11/20/ji-qi-shi-jue-halcon/select_gray.png" alt=""></p><p><strong>根据特征值创建区域</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">含义</th><th style="text-align:center">算子</th></tr></thead><tbody><tr><td style="text-align:center">区域内接圆</td><td style="text-align:center">inner circle(Regions: : : Row, Column, Radius)</td></tr><tr><td style="text-align:center">平行坐标最小外包矩形</td><td style="text-align:center">smallest_rectangle1(Regions : : : Row1, Column1, Row2, Column2)</td></tr><tr><td style="text-align:center">最小外包矩形 (可旋转)</td><td style="text-align:center">smallest_rectangle2(Regions : : : Row, Column, Phi, Length1, Length2)</td></tr></tbody></table></div><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">*读取图像                        read_image (Image, 'fabrik')get_image_size (Image, Width, Height)*关闭窗口                        dev_close_window () dev_open_window (0, 0, Width, Height, 'black', WindowID)*设置输出颜色为白色       dev_set_color ('white')*设置图像模式为填充模式dev_set_draw ('fill')*使用regiongrowing算子寻找颜色相近的邻域 regiongrowing (Image, Regions, 1, 1, 3, 500)*找出每个区域的最大内接圆以及内接圆的中心坐标和半径inner_circle (Regions, Row, Column, Radius)*设置输出颜色为红色       dev_set_color ('red')*显示每个区域的内接圆   disp_circle (WindowID, Row, Column, Radius)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">*关闭窗口                                  dev_close_window ()*读取图像                                  read_image (Shubiao,'shubiao.jpg')*获取图像尺寸                          get_image_size (Shubiao, Width, Height)*打开适应图像大小的窗口          dev_open_window (0, 0, Width, Height, 'black', WindowHandle)*灰度化                                     rgb1_to_gray (Shubiao, GrayImage)*使用阈值处理提取较暗的部分   threshold (GrayImage, Regions, 0, 253)*求平行坐标的最小外接矩形       smallest_rectangle1 (Regions, Row1, Column1, Row2, Column2)*填充模式为轮廓                        dev_set_draw ('margin')*根据矩形参数绘制矩形的轮廓   gen_rectangle1 (Rectangle, Row1, Column1, Row2, Column2)*求区域的最小外接矩形             smallest_rectangle2 (Regions, Row, Column, Phi, Length1, Length2)*根据矩形参数绘制矩形的轮廓   gen_rectangle2 (Rectangle1, Row, Column, Phi, Length1, Length2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="区域的灰度特征值"><a href="#区域的灰度特征值" class="headerlink" title="区域的灰度特征值"></a>区域的灰度特征值</h3><p><strong>典型的灰度值特征</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th></tr></thead><tbody><tr><td style="text-align:center">灰度区域面积 (area)</td><td style="text-align:center">中心点的行坐标和列坐标 (row colum)</td><td style="text-align:center">椭圆的长轴 (ra)</td><td style="text-align:center">椭圆的短轴 (rb)</td><td style="text-align:center">等效椭圆的角度 (phi)</td></tr><tr><td style="text-align:center">灰度的最小值（min）</td><td style="text-align:center">灰度的最大值（max）</td><td style="text-align:center">灰度的均值（mean）</td><td style="text-align:center">灰度值的偏差（deviation）</td><td style="text-align:center">近似平面的偏差（plane_deviation）</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">含义</th><th style="text-align:center">算子</th></tr></thead><tbody><tr><td style="text-align:center">计算指定区域的灰度特征值</td><td style="text-align:center">gray_features (Regions, Image : : Features : Value)</td></tr><tr><td style="text-align:center">计算区域的灰度值平均值和偏差</td><td style="text-align:center">intensity (Regions, Image : : : Mean, Deviation)</td></tr><tr><td style="text-align:center">基于灰度直方图计算最大/最小灰度值</td><td style="text-align:center">min_max_gray (Regions, Image: : Percent: Min, Max, Range)</td></tr></tbody></table></div><p><code>min_max_gray</code>算子的原理是基于灰度直方图，取波峰和谷底之间的区域，区域两端各向内收缩一定的百分比，然后在这段范围内计算出最小灰度值和最大灰度值。</p><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">* 读取图片read_image (Image, 'monkey')* 对图像进行阈值处理，将图像转化为区域threshold (Image, Region, 210, 255)connection (Region, ConnectedRegions)select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 27500, 28849.2)* 提取区域中最小灰度值gray_features (Region, Image, 'min',MinDisp)* 提取区域中最大灰度值gray_features (Region, Image, 'max', MaxDisp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">* 读取图像                                                    read_image (Image, 'mreut')* 关闭窗口                                                    dev_close_window ()* 获得图像尺寸                                              get_image_size (Image, Width, Height)* 打开适应图像大小的窗口                             dev_open_window (0, 0, Width, Height, 'black', WindowID)* 显示图像                                                    dev_display (Image)* 设置填充模式为轮廓                                    dev_set_draw ('margin')* 创建两个矩形区域                                      gen_rectangle1 (Rectangle1, 350, 100, 450, 200)gen_rectangle1 (Rectangle2, 100, 200, 200, 300)* 提取区域1中灰度值的平均值与偏差              intensity (Rectangle1, Image, Mean1, Deviation1)* 提取区域2中灰度值的平均值与偏差              intensity (Rectangle2, Image, Mean2, Deviation2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-halcon" data-language="halcon"><code class="language-halcon">* 读取图像                                                    read_image (Image, 'mreut')* 关闭窗口                                                    dev_close_window ()* 获得图像尺寸                                              get_image_size (Image, Width, Height)* 打开适应图像大小的窗口                             dev_open_window (0, 0, Width, Height, 'black', WindowID)* 显示图像                                                    dev_display (Image)* 设置填充模式为轮廓                                    dev_set_draw ('margin')* 创建两个矩形区域                                      gen_rectangle1 (Rectangle1, 350, 100, 450, 200)gen_rectangle1 (Rectangle2, 100, 200, 200, 300)* 提取区域1中最大与最小灰度值以及跨度         min_max_gray (Rectangle1, Image, 5, Min1, Max1, Range1)* 提取区域2中最大与最小灰度值以及跨度              min_max_gray (Rectangle2, Image, 5, Min2, Max2, Range2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器视觉 </tag>
            
            <tag> Halcon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划学习</title>
      <link href="/2022/08/11/dong-tai-gui-hua-xue-xi/"/>
      <url>/2022/08/11/dong-tai-gui-hua-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><strong>动态规划题目特点</strong></p><ol><li>计数<ul><li>有多少种方式走到右下角</li><li>有多少种方法选出k个数使得和是sum</li></ul></li><li>求最大值最小值<ul><li>从左上角走到右下角路径的最大数字和</li><li>最长上升子序列长度</li></ul></li><li>求存在性<ul><li>取石子游戏，先手是否必胜</li><li>能不能选出k个数使得和是sum</li></ul></li></ol><p><strong>动态规划组成部分：</strong></p><ol><li><p>确定状态 f[x]</p><p>解动态规划的时候需要开一个数组，数组的每个f[i]或f[i][j]代表什么</p><ul><li>最后一步</li><li>子问题</li></ul></li><li><p>转移方程</p><ul><li>根据子问题写出转移方程</li></ul></li><li><p>初始条件和边界情况</p><ul><li>初始条件：用转移方程算不出来的，需要手工定义</li><li>边界情况：数组不能越界</li></ul></li><li><p>计算顺序的确定</p><ul><li>从小到大</li><li>从大到小</li></ul></li></ol><h2 id="求最值型动态规划"><a href="#求最值型动态规划" class="headerlink" title="求最值型动态规划"></a>求最值型动态规划</h2><p>leetcode322：给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。</p><p>问题分析：</p><p>​    假设 coins = [2, 3, 5], amount = 27</p><ol><li><p>确定状态 f[x] = 最少用多少枚硬币拼出x</p><ul><li><p>考虑子问题和最后一步</p></li><li><p>假设最优策略为k枚硬币a_1,a_2,…,a_k，所以一定有一枚最后的硬币a_k，前面硬币的总面值为27-a_k</p></li><li><p>因为是最优策略所以拼出27-a_k的硬币数一定最少</p></li><li><p>原问题：最少用多少枚硬币拼出a_k </p></li><li><p>子问题：最少用多少枚硬币拼出27-a_k</p></li><li><p>对于任意的x f[x] = min{f[x-2]+1, f[x-5]+1, f[x-7]+1}</p></li></ul></li><li><p>转移方程 </p><ul><li>f[x] = min{f[x-2]+1, f[x-5]+1, f[x-7]+1}</li></ul></li><li><p>初始条件和边界情况</p><ul><li><p>初始条件：f[0] = 0</p></li><li><p>边界情况：如果不能拼出Y， 定义f[Y] = 正无穷</p></li></ul></li><li><p>计算顺序的确定</p><ul><li><p>初始条件：f[0] = 0</p></li><li><p>计算：f[1], f[2],…, f[27]</p></li><li><p>当计算f[x]时,f[x-2],f[x-5],f[x-7]都已经有结果了</p></li></ul></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> coins<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type coins: List[int]        :type amount: int        :rtype: int        """</span>        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>coins<span class="token punctuation">)</span>  <span class="token comment"># number of kinds of coins</span>        <span class="token comment"># 初始化</span>        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment"># 计算f[1],f[2],...,f[amount]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>             <span class="token comment"># 最后一枚硬币</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> coins<span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token operator">-</span> c <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>                    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span>c<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">if</span> math<span class="token punctuation">.</span>isinf<span class="token punctuation">(</span>f<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">else</span> f<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="求计数型动态规划"><a href="#求计数型动态规划" class="headerlink" title="求计数型动态规划"></a>求计数型动态规划</h2><p>LC62不同路径：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？</p><p>问题分析:</p><ol><li><p>确定状态 f[i][j]为机器人有多少种方式走到[i][j]</p><ul><li>考虑子问题和最后一步<ul><li>最后一步：无论机器人用何种方式到达右下角，总有最后挪动的一步（向右或者向下）</li><li>设右下角坐标为(m-1,n-1)，那么前一步机器人一定在(m-2,n-1)或者(m-1,n-2)</li><li>假设机器人有X种方式从左上角走到(m-2,n-1)，有Y种方式走到(m-1,n-2)，则机器人有X+Y种方式走到(m-1,n-1)</li><li>问题转化为，机器人有 多少种方式从左上角走到(m-2,n-1)和(m-1,n-2)</li></ul></li></ul></li><li><p>转移方程 </p><ul><li>f[i][j] = f[i-1][j] + f[i][j-1]</li></ul></li><li><p>初始条件和边界情况</p><ul><li><p>初始条件：f[0][0]=1</p></li><li><p>边界情况：i=0或j=0，f[i][j] = 1</p></li></ul></li><li><p>计算顺序的确定</p><ul><li>初始条件：f[0][0]=1</li><li>计算第0行：f[0][0]，f[0][1]，…，f[0][n-1]</li><li>计算第1行：f[1][0]，f[1][1]，…，f[1][n-1]</li><li>​        …</li><li>答案是 f[m-1][n-1]</li></ul></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type m: int        :type n: int        :rtype: int        """</span>        <span class="token comment"># 初始化</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment"># 计算每一个dp[i][j]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="求存在型动态规划"><a href="#求存在型动态规划" class="headerlink" title="求存在型动态规划"></a>求存在型动态规划</h2><p><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a>：给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。</p><p>问题分析:</p><ol><li><p>确定状态 f[i]能否到达下标i</p><ul><li>考虑子问题和最后一步<ul><li>最后一步：如果能到达最后一个下标n-1，考虑最后一步</li><li>如果最后一步是从下标i的位置跳过来，需要满足两个条件：<ol><li>可以跳跃到下标i的位置</li><li>最后一步不超过跳跃的最大距离：$n-1-i&lt;=nums[i]$</li></ol></li><li>原问题：能否到达最后一个下标$n-1$</li><li>子问题：能否到达下标$i\ (i&lt;n-1)$</li></ul></li></ul></li><li><p>转移方程 </p><ul><li>$f[j] = OR_{0&lt;=i<j}(f[i]\ and="" \="" i="" +="" nums[i]="">= j)$</j}(f[i]\></li></ul></li><li><p>初始条件和边界情况</p><ul><li>初始条件：f[0] = True</li></ul></li><li><p>计算顺序的确定</p><ul><li>初始条件：f[0] = True</li><li>计算：f[1],f[2],…,f[n-1]</li></ul></li><li>时间复杂度o($N^2$),空间复杂度o($N$)</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canJump</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: bool        """</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">True</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>            <span class="token comment"># previous step</span>            <span class="token comment"># last jump from i to j</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">and</span> i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> j<span class="token punctuation">:</span>                    f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>                    <span class="token keyword">break</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动态规划重点内容"><a href="#动态规划重点内容" class="headerlink" title="动态规划重点内容"></a>动态规划重点内容</h2><h3 id="坐标型动态规划"><a href="#坐标型动态规划" class="headerlink" title="坐标型动态规划"></a>坐标型动态规划</h3><ul><li>给定一个<strong>序列</strong>或<strong>网格</strong>，需要找到某个/些子序列或网格中的某条路径<ul><li>某种性质最大/最小</li><li>计数</li><li>存在性</li></ul></li><li>动态规划方程f[i]中的下标i表示以$a_i$结尾的满足某条件的子序列的性质，f[i][j]中的下标i,j表示以格子(i,j)为结尾的满足条件的路径的性质</li></ul><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II</a>：一个机器人位于一个 m x n 网格的左上角 。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p>问题分析:</p><ol><li>f[i][j] = 机器人有多少种方式走到[i][j]</li><li><p>转移方程 f[i][j] = f[i-1][j] + f[i][j-1]</p></li><li><p>如果左上角(0,0)格或者右下角(m-1,n-1)格有障碍，直接输出0</p></li><li>如果(i,j)格有障碍，f[i][j] = 0，表示机器人不能到达此格（0种方式）</li><li>初始条件：f[0][0] = 1</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">uniquePathsWithObstacles</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> obstacleGrid<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type obstacleGrid: List[List[int]]        :rtype: int        """</span>        m <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>obstacleGrid<span class="token punctuation">)</span>  <span class="token comment"># row</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># column</span>        <span class="token comment"># 如果左上角(0,0)格或者右下角(m-1,n-1)格有障碍，直接输出0</span>        <span class="token keyword">if</span> obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">or</span> obstacleGrid<span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment"># 初始化</span>        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment"># 计算f[i][j]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> j <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 第一行</span>                        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>                    <span class="token keyword">elif</span> i <span class="token operator">!=</span><span class="token number">0</span> <span class="token keyword">and</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 第一列</span>                        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                    <span class="token keyword">elif</span> i<span class="token operator">!=</span><span class="token number">0</span> <span class="token keyword">and</span> j <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a>:给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p>问题分析:</p><ol><li>f[i][j] = 到达[i][j]的最小数字总和是f[i][j]</li><li>转移方程 f[i][j] =min{ f[i-1][j] + grid[i][j], f[i][j-1] + grid[i][j]}</li><li>f[0][0] = grid[0][0]</li><li>f[i][0] = f[i-1][0] + grid[i][0]; f[0][j] = f[0][j-1] + grid[0][j]</li></ol><p>优化：用滚动数组实现（空间优化）— 只需要开两行数组</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>grid <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> grid<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> old <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> now <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>t1<span class="token punctuation">,</span>t2<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            old <span class="token operator">=</span> now<span class="token punctuation">;</span>            now <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> now<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    f<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                f<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    t1 <span class="token operator">=</span> f<span class="token punctuation">[</span>old<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span><span class="token punctuation">{</span>                    t1 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    t2 <span class="token operator">=</span> f<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span><span class="token punctuation">{</span>                    t2 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>t1 <span class="token operator">&lt;</span> t2<span class="token punctuation">)</span><span class="token punctuation">{</span>                    f<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> t1<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                 <span class="token keyword">else</span><span class="token punctuation">{</span>                    f<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> t2<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a>：给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。连续递增的子序列可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p><p> 示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,3,5,4,7]输出：3解释：最长连续递增序列是 [1,3,5], 长度为3。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 问题分析：</p><ol><li><p>确定状态 : f[j] = 以a[j]结尾的最长连续上升子序列长度</p><ul><li>考虑子问题和最后一步</li><li>最后一步：对于最优策略，一定有最后一个元素a[j]<ul><li>第一种情况：最优策略中最长上升子序列就是{a[j]}，答案是1</li><li>第二种情况：子序列长度大于1，那么最优策略中a[j]前一个元素a[j-1]&lt;a[j]</li><li>因为是最优策略，那么a[j-1]结尾的连续上升子序列一定是最长的</li></ul></li><li>要求以a[j-1]结尾的最长连续上升子序列</li></ul></li><li><p>转移方程 </p><ul><li>f[j] = max{1, f[j-1]+1|j&gt;0 and a[j-1]&lt;a[j]}</li></ul></li><li><p>初始条件和边界情况</p><ul><li><p>初始条件：f[0] = 1</p></li><li><p>边界情况：边界情况</p></li></ul></li><li><p>计算顺序的确定</p><ul><li>计算f[0],…,f[n-1]</li><li>答案是max{f[0],…,f[n-1]}</li></ul></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findLengthOfLCIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> result<span class="token punctuation">)</span><span class="token punctuation">{</span>                result <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findLengthOfLCIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp <span class="token operator">=</span>  <span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findLengthOfLCIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        <span class="token comment"># 滑动窗口版本</span>        length <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> length <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> length <span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> length        left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>        max_len <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> right <span class="token operator">&lt;</span> length<span class="token punctuation">:</span>            sub_len <span class="token operator">=</span> <span class="token number">1</span>            <span class="token keyword">while</span> right <span class="token operator">&lt;</span> length <span class="token keyword">and</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>right<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                sub_len <span class="token operator">+=</span> <span class="token number">1</span>                right <span class="token operator">+=</span> <span class="token number">1</span>            max_len <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>max_len<span class="token punctuation">,</span> sub_len<span class="token punctuation">)</span>            left <span class="token operator">=</span> right            right <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> max_len<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="序列型动态规划"><a href="#序列型动态规划" class="headerlink" title="序列型动态规划"></a>序列型动态规划</h3><ul><li>给定一个序列，f[i]中的下标i表示前i个元素a[0],a[1],…,a[i-1]的某种性质。</li><li>初始化中，f[0]，表示空序列的性质</li></ul><p><strong>…前i个…最小/方式数/可行性</strong></p><p><strong>序列 + 状态</strong></p><p>[LeetCode] 256. 粉刷房子：假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。<br> 例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请计算出粉刷完所有房子最少的花费成本。<br> 输入: costs = [[17,2,17],[16,16,5],[14,3,19]] 输出: 10 解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。<br>     最少花费: 2 + 5 + 3 = 10。</p><p> 问题分析：</p><ol><li><p>确定状态 : 设油漆<strong>前i栋</strong>房子并且房子i-1是红色、蓝色、绿色的最小花费分别为f[i][0], f[i][1], f[i][2]</p><ul><li>考虑子问题和最后一步</li><li>最后一步：房子n-1一定染成了红、蓝、绿中的一种，且前一步中刷的房子颜色不能与最后一步相同</li><li>因此需要记录房子颜色</li></ul></li><li><p>转移方程 </p><ul><li>f[i][0] = min{f[i-1][1] + cost[i-1][0], f[i-1][2] + cost[i-1][0] }<ul><li>f[i-1][1] + cost[i-1][0]: 油漆前i-1栋房子并且房子i-2是蓝色的最小花费 + 油漆房子i-1的花费</li></ul></li><li>f[i][1] = min{f[i-1][0] + cost[i-1][1], f[i-1][2] + cost[i-1][1]}</li><li>f[i][2] = min{f[i-1][0] + cost[i-1][2], f[i-1][1] + cost[i-1][2]}</li></ul></li><li><p>初始条件和边界情况</p><ul><li><p>初始条件：f[0][0] = f[0][1] = f[0][2] = 0 即不油漆任何房子的花费</p></li><li><p>边界情况：无边界情况</p></li></ul></li><li><p>计算顺序的确定</p><ul><li>初始化：f[0][0] = f[0][1] = f[0][2] = 0</li><li>计算：f[1][0]，f[1][1]，f[1][2]</li><li>计算：f[2][0]，f[2][1]，f[2][2]</li><li>​        …</li><li>计算：f[n][0]，f[n][1]，f[n][2]</li><li>答案: min{f[n][0]，f[n][1]，f[n][2]}</li></ul></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minCost</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> costs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type costs: List[List[int]]        :rtype: int        """</span>        <span class="token comment"># 初始化</span>        house_num <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>costs<span class="token punctuation">)</span>        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>house_num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>house_num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token builtin">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>house_num<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>house_num<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>house_num<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设有K种颜色</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//如果最小值是第i个元素，次小值是第j个元素</span><span class="token comment">//1. 只要除掉的元素不是第i个，剩下的最小值就是第i个元素</span><span class="token comment">//2. 如果除掉的元素是第i个，剩下的最小值就是第j个元素</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minCost</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> costs<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>costs <span class="token operator">==</span> <span class="token keyword">null</span><span class="token operator">||</span>costs<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">int</span> n <span class="token operator">=</span> costs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// house number</span>     <span class="token keyword">int</span> <span class="token class-name">K</span> <span class="token operator">=</span> costs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// paint number</span>     <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">K</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>     <span class="token keyword">int</span> min1<span class="token punctuation">,</span>min2<span class="token punctuation">,</span>j1<span class="token punctuation">,</span>j2<span class="token punctuation">;</span> <span class="token comment">// min1最小值，min2次小值,j1最小值下标，j2次小值下标</span>     j1 <span class="token operator">=</span> j2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token class-name">K</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment">// 计算每一个f[i][j]</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         min1 <span class="token operator">=</span> min2 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token comment">//求最小值和次小值</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>min1<span class="token punctuation">)</span><span class="token punctuation">{</span>                 min2 <span class="token operator">=</span> min1<span class="token punctuation">;</span>                 j2 <span class="token operator">=</span> j1<span class="token punctuation">;</span>                 min1 <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                 j1 <span class="token operator">=</span> j<span class="token punctuation">;</span>             <span class="token punctuation">}</span>             <span class="token keyword">else</span><span class="token punctuation">{</span>                 <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min2<span class="token punctuation">)</span><span class="token punctuation">{</span>                     min2 <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                     j2 <span class="token operator">=</span> j<span class="token punctuation">;</span>                 <span class="token punctuation">}</span>             <span class="token punctuation">}</span>         <span class="token punctuation">}</span>         <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">!=</span> j1<span class="token punctuation">)</span><span class="token punctuation">{</span>         f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j1<span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">else</span><span class="token punctuation">{</span>         f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j2<span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> res<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a>：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</strong>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。<br>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。&nbsp;    偷窃到的最高金额 = 1 + 3 = 4 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token operator">==</span><span class="token keyword">null</span> <span class="token operator">||</span> nums<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// the number of house</span>        <span class="token comment">// 初始化</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">// 计算每一个f[i][j]</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">// 第i-1间偷了，第i-2间一定没偷</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 第i-1间没偷，第i-2间可能没偷也可能偷了</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>序列 + 位操作型动态规划</p><ul><li>&amp;与，|或，^异或，！非</li></ul><p><a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a>:给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。<br>示例 1：<br></p><pre class="line-numbers language-none"><code class="language-none">输入：n = 2输出：[0,1,1]解释：0 --&gt; 01 --&gt; 12 --&gt; 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><ul><li>二进制表示算法：<ul><li>第一步：i mod 2 是最低位的bit</li><li>第二步：i /2，如果i=0结束，否则回到第一步</li></ul></li><li><p>和位操作有关的，一般用值做状态</p><p>问题分析：</p></li></ul><ol><li><p>确定状态 :  f[i] = i的二进制表示中有多少个1</p><ul><li>考虑子问题和最后一步</li><li>要求N的二进制中有多少1</li><li>在N的二进制去掉最后一位N mod 2，设新的数是Y = (X&gt;&gt;1)（右移一位）</li><li>子问题：要知道Y的二进制表示中有多少1</li></ul></li><li><p>转移方程 </p><ul><li>f[i] = f[i&gt;&gt;1] + i mod 2</li></ul></li><li><p>初始条件和边界情况</p><ul><li><p>初始条件：f[0]=1</p></li><li><p>边界情况：如果i=1只看最后一个数字</p></li></ul></li><li><p>计算顺序的确定</p><ul><li>初始化：f[0]=0</li><li>计算：f[1], f[2], …, f[N]</li></ul></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">countBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 初始化</span>        f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">&gt;&gt;</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> f<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="划分型动态规划"><a href="#划分型动态规划" class="headerlink" title="划分型动态规划"></a>划分型动态规划</h3><p><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a>：<br>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><pre class="line-numbers language-none"><code class="language-none">'A' -&gt; 1'B' -&gt; 2...'Z' -&gt; 26<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>"11106"</code> 可以映射为：</p><ul><li><code>"AAJF"</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>"KJF"</code> ，将消息分组为 <code>(11 10 6)</code></li></ul><p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>"06"</code> 不能映射为 <code>"F"</code> ，这是由于 <code>"6"</code> 和 <code>"06"</code> 在映射中并不等价。</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p><p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p><p><strong>示例 ：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：s = "226"输出：3解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 问题分析：</p><ol><li><p>确定状态 :  设数字串S<strong>前i个</strong>数字解密成字母串有f[i]种方式</p><ul><li>考虑子问题和最后一步</li><li>最后一步：一定有最后一个字母 A, B,…, Z，这个字母加密时变成1,2,…,26</li><li>设数字串长度为N，要求数字串前N 个数字的解密方式数，需要知道数字串前N-1和N-2个字符的解密方式数</li></ul></li><li><p>转移方程 </p><ul><li>f[i] = f[i-1]|S[i-1]对应一个字母(非0) + f[i-2]|S[i-2]S[i-1]对应一个字母</li></ul></li><li><p>初始条件和边界情况</p><ul><li><p>初始条件：f[0]=1</p></li><li><p>边界情况：如果i=1只看最后一个数字</p></li></ul></li><li><p>计算顺序的确定</p><ul><li>初始化：f[0]=1</li><li>计算：f[1], f[2], …, f[N]</li></ul></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numDecodings</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s <span class="token operator">=</span> ss<span class="token punctuation">.</span><span class="token function">toCharArrary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 初始化</span>        f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> t <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">&gt;=</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> t<span class="token operator">&lt;=</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&gt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                t <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">&gt;=</span><span class="token number">10</span> <span class="token operator">&amp;&amp;</span> t<span class="token operator">&lt;=</span><span class="token number">26</span><span class="token punctuation">)</span>                    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numDecodings</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        length <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">if</span> length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> length <span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">if</span> <span class="token builtin">int</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            num <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span> <span class="token operator">+</span> <span class="token builtin">int</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> num <span class="token operator">&gt;=</span><span class="token number">10</span> <span class="token keyword">and</span> num <span class="token operator">&lt;=</span><span class="token number">26</span><span class="token punctuation">:</span>                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理学习笔记</title>
      <link href="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/"/>
      <url>/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="数字图像处理"><a href="#数字图像处理" class="headerlink" title="数字图像处理"></a>数字图像处理</h1><p><strong>图像</strong></p><p>二维图像<code>f(x,y)</code></p><ul><li><code>x,y</code>: 空间坐标</li><li><code>(x,y)</code>上的负值<code>f</code>：该点图像的强度或者灰值</li></ul><p><strong>数字图像</strong></p><ul><li><code>x,y</code>和幅值<code>f(x,y)</code>为有限的离散数值</li><li>像素pixel是数字图像的基本元素</li></ul><p><strong>图像的采样&amp;量化</strong></p><ul><li>取样 (Sampling)</li><li>量化 (Quantization，模数转换)</li></ul><p>图像的数字化过程</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/图像数字化.jpg" style="zoom:50%;"></p><ul><li>采样间隔越大，所得图像像素数越少，图像空间分辨率低，质量差</li><li>采样间隔越小，所得图像像素数越多，图像空间分辨率高，质量好，但数据量大</li><li>量化等级越多，所得图像层次越丰富，灰度分辨率越高，质量越好，但数据量大；</li><li>量化等级越少，图像层次欠丰富，灰度分辨率低，质量变差，会出现假轮廓现象，但数据量小。</li></ul><p><strong>邻域关系</strong></p><ul><li><p>4邻域、D邻域、8邻域</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/邻域关系.png" style="zoom:23%;"></p></li></ul><p><strong>邻接性</strong></p><ul><li><p>4 邻接、8邻接、m邻接</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/邻接关系.png" alt=""></p></li></ul><p><strong>m邻接实质</strong>：当像素间同时存在4 邻接和 8 邻接时，优先采用 4 邻接屏蔽两个和同一像素间存在4 邻接的像素之间的 8 邻接</p><p><strong>连通性</strong></p><ul><li><p>从具有坐标(x,y)的像素p到具有坐标(s,t)的像素q的通路（或曲线）是特定的像素序列，其坐标为</p></li><li><p>$(x_0,y_0),(x_1,y_1),…,(x_n,y_n)$</p></li><li>其中$(x_0,y_0)=(x,y)$并且像素$(x_i,y_i)$和$(x_{i-1},y_{i-1})$(对于$1 \leq i \leq n$)是邻接的。在这种情况下，n是通路的长度。如果$(x_0,y_0)=(x_n,y_n)$，则通路是闭合通路。</li></ul><p>如果要从像素s 到像素 t</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/连通性.png" style="zoom:25%;"></p><ul><li>在 4 连通 的条件下：s 不能到 t</li><li>在8 连通 的条件下：s 可以到 t</li><li>在 m 连通 的条件下：s 可以到 t</li></ul><p><strong>区域和边界</strong></p><ul><li>区域的定义是建立在连通集的基础上的，令R 是图像中的像素子集</li><li>如果 R 是连通集，则称 R 为一个区域</li><li>如果一个点的 8 邻域都是 1 ，则可以认为这个点是内部的点 而不是边界上的点，可以删除这类点，剩下的就是边界上的点</li><li>根据腐蚀的特性，使用 3*3 的结构元素对图像进行腐蚀，可以得到内部的点，那么再用原图减去腐蚀图 ，就得到了图像的边界</li></ul><p><strong>像素之间的距离</strong></p><ul><li><p>欧式距离：$D_e(p,q) = \sqrt{(x-s)^{2}+(y-t)^{2}}$</p></li><li><p>城市街区距离</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/城市街区距离.jpg" alt=""></p></li><li><p>棋盘距离</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/棋盘距离.jpg" alt=""></p><ul><li>围着 P 点的所有元素都是相邻的，它下一步可以走到包围它的八个点的任何一个，也就是横竖和斜向。</li><li>对于可以横竖和斜向走的最短距离，就是横向或竖向的距离的最大值。</li><li>实质上是凑成一个正方形的对角线</li></ul></li></ul><h2 id="图像变换与矫正"><a href="#图像变换与矫正" class="headerlink" title="图像变换与矫正"></a>图像变换与矫正</h2><ul><li><p>由于多种因素的影响，应用中实际获得的画面可能会与想象中有所差异，因此需要进行调整、把画面复原。</p></li><li><p>图像的变换与校正是指用数学建模方法来描述图像位置、大小、形状等已知条件，利用这些条件进行确定模型参数，根据模型对图像进行几何校正。</p></li></ul><h3 id="图像的平移、旋转和缩放"><a href="#图像的平移、旋转和缩放" class="headerlink" title="图像的平移、旋转和缩放"></a>图像的平移、旋转和缩放</h3><p><strong>平移</strong></p><p>齐次坐标 (<strong>Homogenous Coordinate</strong>)</p><p>点$p_{0}(x_{0},y_{0})$平移至$p_{t}(x_{0}+T_{x},y_{0}+T_{y})$</p><script type="math/tex; mode=display">\begin{cases}x_{1} = x_{0}+T_{x}\\y_{1} = y_{0}+T_{y}\end{cases}</script><script type="math/tex; mode=display">\begin{bmatrix} x_{1}\\ y_{1}\\ 1\end{bmatrix}=\begin{bmatrix}  1 & 0 & T_{x}\\  0 & 1 & T_{y}\\  0 & 0 & 1\end{bmatrix}\begin{bmatrix}x_{0}\\y_{0}\\1\end{bmatrix}</script><p>记为如下的形式：</p><script type="math/tex; mode=display">p_{t} = T \cdot p_0 = \begin{bmatrix}1 & 0 & x_{t}\\0 & 1 & y_{t}\\ 0 & 0 & 1\end{bmatrix} \cdot p_0</script><p><strong>旋转</strong></p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/旋转.png" style="zoom: 50%;"></p><ul><li><p>$x_0 = r \cos \alpha$</p></li><li><p>$y_0 = r \sin \alpha$</p></li><li>$x = r\cos(\alpha - \gamma) = r\cos{\alpha}\cos{\gamma}+r\sin{\alpha}\sin{\gamma} = x_0\cos{\gamma} + y_0\sin{\gamma}$</li><li>$y = r\sin(\alpha - \gamma) = r\sin{\alpha}\cos{\gamma}-r\cos{\alpha}\sin{\gamma} = y_0\cos{\gamma} - x_0\sin{\gamma}$</li></ul><script type="math/tex; mode=display">p_{r} = R \cdot p_0 = \begin{bmatrix} \cos{\gamma}  & -\sin{\gamma} & 0\\ \sin{\gamma} & \cos{\gamma} & 0\\ 0 & 0 & 1\end{bmatrix} \cdot p_0</script><p><strong>缩放</strong></p><p>缩放前后两点$A_0(x_0, y_0)$和$A_1(x_1, y_1)$之间的关系</p><script type="math/tex; mode=display">\begin{cases}x_1 = \alpha x_{0}\\y_1 = \alpha y_{0}\end{cases}</script><p>用矩阵形式可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix} x_{1}\\ y_{1}\\ 1\end{bmatrix}=\begin{bmatrix}  \alpha & 0 & 0\\  0 & \alpha & 0\\  0 & 0 & 1\end{bmatrix}\begin{bmatrix}x_{0}\\y_{0}\\1\end{bmatrix}</script><script type="math/tex; mode=display">p_{s} = S \cdot p_0 = \begin{bmatrix} S_{x} & 0 & 0\\0 & S_{y} & 0\\ 0 & 0 & 1\end{bmatrix} \cdot p_0</script><h3 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h3><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/几何变换.jpg" alt=""></p><p><strong>相似变换 (Similarity Transformation)</strong></p><p>相似变换：由一个平面立体图形变换到另一个平面立体图形，在改变的过程中<strong>保持形状不变(大小方向和位置可变)</strong>，任何相似变换都可以分解为<strong>等比例缩放</strong>、 <strong>平移</strong> 、 <strong>旋转</strong>的组合</p><script type="math/tex; mode=display">\begin{bmatrix}  1 & 0 & T_{x}\\  0 & 1 & T_{y}\\  0 & 0 & 1\end{bmatrix}\begin{bmatrix} \cos{\gamma}  & -\sin{\gamma} & 0\\ \sin{\gamma} & \cos{\gamma} & 0\\ 0 & 0 & 1\end{bmatrix}\begin{bmatrix} S & 0 & 0\\0 & S & 0\\ 0 & 0 & 1\end{bmatrix}</script><p>可记为</p><script type="math/tex; mode=display">\begin{bmatrix}      sR& T\\   0 & 1\\\end{bmatrix}</script><p><strong>仿射变换 (Affine Transformation)</strong></p><p>仿射变换：由一个平面立体图形变换到另一个平面立体图形，在改变的过程中<strong>保持直线和平行线不变</strong> (平行线映射为平行线），任何仿射变换都可以分解为<strong>缩放</strong> 、 <strong>平移</strong> 、 <strong>旋转</strong>和<strong>切变 (Shearing)</strong>的组合</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/仿射变换.jpg" style="zoom:80%;"></p><p>仿射变换允许图形任意倾斜，而且允许图形在两个方向上任意伸缩变换</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/Affine Transformation1.jpg" alt=""></p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/Affine Transformation2.jpg" alt=""></p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/Affine Transformation3.jpg" alt=""></p><p><strong>投影变换 (Projective Transformation)</strong></p><p>又称为单应性变换</p><p>投影变换 ：把空间三维立体投射到投影面上得到二维平面图形的过程。</p><ul><li>中心投影（透视投影）图</li></ul><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/投影变换.jpg" style="zoom: 67%;"></p><p>单应性不严谨定义：用无镜头畸变的相机从不同位置拍摄同一平面物体的图像之间存在单应性，可以用投影变换表示。</p><ul><li><p>单应性变换 (投影变换)：不同视角的同一物体，在像素坐标系中的变换。</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/单应性.jpg" style="zoom:33%;"></p></li></ul><script type="math/tex; mode=display">H_{3 \times 3} = \begin{bmatrix}   A_{2 \times 2}& T_{2 \times 1}\\   V^{T} & s\\\end{bmatrix} = \begin{bmatrix}   a_{11} & a_{12} & t_x\\ a_{21} & a_{22} & t_y \\   v_{1} & v_{2} & s\\\end{bmatrix}</script><ul><li><p>其中$A_{2 \times 2}$代表仿射变换的参数，$T_{2 \times 1}$代表了平移变换的参数</p></li><li><p>$V^{T} = [v_1,v_2]$表示一种“变换后边缘交点”关系</p></li><li><p>$s$是一个与$V^{T} = [v_1,v_2]$相关的缩放因子</p><script type="math/tex; mode=display">\begin{bmatrix}  1 & 0 & 0\\  0 & 1 & 0\\  v_{1} & v_{2} & s\end{bmatrix}\begin{bmatrix}x\\y\\1\end{bmatrix} =\begin{bmatrix} x\\ y\\ v_{1}x+v_{2}y+s\end{bmatrix} \Rightarrow \begin{bmatrix} \frac{x}{v_{1}x+v_{2}y+s}\\ \frac{y}{v_{1}x+v_{2}y+s}\\\end{bmatrix}</script></li><li><p>单应性矩阵$H$虽然有9个未知数，但是只有8个自由度</p><ul><li>单应性矩阵$H$与$aH$完全相同</li><li>令 $a = 1/s$</li></ul></li><li><p>仿射变换是投影变换的特例</p></li><li><p>单应性在计算机视觉领域是一个非常重要的概念，它在 图像校正、图像拼接、相机位姿估计、视觉 SLAM 等领域有非常重要的作用。</p></li></ul><h2 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h2><p>增强的主要目的是对图像进行处理，使结果图像比原始图像更适用于某一<strong>特定</strong>应用。<strong>特定</strong>意味着技术是非常面向问题的</p><p>图像增强方法可以分为两大类：<strong>空域方法</strong>和<strong>频域方法</strong></p><ul><li>空域方法是基于图像中的像素直接进行局部处理</li><li>频域方法是基于图像的傅立叶变换进行处理</li></ul><h3 id="空域方法"><a href="#空域方法" class="headerlink" title="空域方法"></a>空域方法</h3><p>空间域处理的数学表示：</p><ul><li>$g(x,y) = T[f(x,y)]$<ul><li>$f(x,y)$：输入图像</li><li>$g(x,y)$: 输出图像</li><li>$T$: 在$f(x,y)$上的操作，定义在$(x,y)$的某个邻域上</li></ul></li><li>$T$可以在一组图像上进行操作，例如噪声消除</li><li>方形和矩形邻域是使用最多的，因为它们易于实现，也可使用圆形区域</li></ul><h4 id="灰度变换-亮度变换"><a href="#灰度变换-亮度变换" class="headerlink" title="灰度变换 (亮度变换)"></a>灰度变换 (亮度变换)</h4><ul><li>$T$最简单的情况是邻域大小为$1 \times 1$，此时$g$只依赖于$f$在$(x,y)$处的值，即</li><li>$s=T(r)$</li><li>称之为灰度变换或者亮度变换，其中s和r分别为输出与输入的亮度值</li></ul><ol><li>幂律变换$s=cr^{\gamma}$，其中$c$和$\gamma$为正常数（伽马矫正，对比度增强）</li><li>分段线性函数（对比度增强，灰度级分层）</li><li><p>比特位面图像</p><ul><li>突出特定位对图像总外观的贡献</li><li>图像中的每个像素由8位二进制数(灰度分为256阶：0-255)表示</li><li>图像由8个1位平面(二值图像)组成，最小有效位平面为0位平面，最大有效位平面为7位平面</li></ul></li><li><p>对数变换$s=clog(1+r)$</p><ul><li>其中$c$是常数</li><li>该变换的形状类似于$\gamma$曲线</li><li>$\gamma$曲线的形状是可变的，而对数函数的形状是固定的</li><li>$(1+r)$ —&gt; $r=0,s=0$</li><li>对数变换的主要用途之一是压缩动态范围</li></ul></li><li><p>对比拉伸变换</p><ul><li>$s=T(r)=\frac{1}{1+(m/r)^E}$</li><li>将小于$m$的输入值压缩到输出图像中较窄的暗区范围内</li><li>类似的，将$m$以上的值压缩成输出中的窄带亮区</li><li>其中$r$为输入图像的强度，$s$为输出图像中对应的强度值，$E$控制函数的斜率，$m$为参数</li><li>$E$越大，函数图像的倾斜度越高</li></ul></li></ol><p><strong>直方图处理</strong></p><ul><li><p>亮度变换通常是基于从图像亮度直方图中提取的信息进行的，直方图在很多图像处理方面（图像增强、压缩、分割和描述）都起到基础作用</p></li><li><p>一副亮度取值在$[0,G]$范围内的数字图像，将它量化为$L$个亮度级别的直方图，可以定义为一个离散函数</p><ul><li>$h(r_k)=n_k$</li><li>其中$r_k$为区间$[0,G]$中第$k$个强度级别，$n_k$为图像中强度级别为$r_k$的像素数目。</li><li>uint8类图像的$G$值为255，unit16类图像的$G$值是65535，double类图像的$G$值为1.0</li></ul></li><li><p>一副图像的直方图$h(r_k)$可以表示为一个向量，将其所有分量处以该图像的像素总数，可以得到归一化直方图</p><ul><li>$p(r_k)=\frac{h(r_k)}{N}=\frac{n_k}{N}, N=\sum_{k=1}^{L}n_k$</li><li>$p(r_k)$可看作为在一副图像中强度级$r_k$发生概率的估计值</li></ul></li><li><p>matlab中的图像直方图函数</p><ul><li><code>h=imhist(f,b)</code></li><li>f为输入图像，h为输入图像的直方图，b为生成直方图所用量化级别的数目</li></ul></li></ul><p><strong>直方图均衡</strong></p><ul><li>目的：改善图像对比度</li><li>结果：均衡后的图像具有几乎均匀的像素值分布（服从均匀分布）</li><li>优点：无参数的算法</li></ul><p>寻找变换函数</p><ul><li>假设$r$被归一化为区间$[0,1]$，$r=0$表示黑色，$r=1$表示白色<ul><li>$s=T(r), 0 \le r \le 1$</li></ul></li><li>转换函数$T$要求满足下列条件：<ul><li>$T(r)$在区间$[0,1]$上是单值($r_1 \ne r_2, s_1\ne s_2$)的且单调递增</li><li>对于$0 \le r \le 1$，$0 \le T(r) \le 1$</li></ul></li><li>直方图均衡化是基于一个随机变量的概率密度函数的变换</li><li>令$p_s(s)$和$p_r(r)$分别为随机变量$s$和$r$的概率密度函数 (归一化直方图函数)</li><li><p>如果$p_r(r)$和$T(r)$是已知的，则可得到变换后的变量$s$的概率密度函数$p_s(s)$通过下面的计算得到</p><ul><li>$p_s(s)=p_r(r)|dr/ds|$</li><li>分析<ul><li>对于连续型随机变量$X$的概率密度函数$f(x)$</li><li>$p\{X=x\}=f(x)dx$</li><li>$p_s(s)$和$p_r(r)$是一一映射的关系，每一点出现的概率均相等</li><li>所以$p_s(s)ds=p_r(r)dr$</li></ul></li></ul></li><li><p>定义一个转换函数</p><ul><li>$s=T(r)=\int_{0}^{r}p_r(\omega) d\omega$</li><li>其中$\omega$是积分的虚变量，方程的右边可看作随机变量的累积分布函数</li><li>分析<ul><li>$s=T(r)=\int_{0}^{r}p_r(\omega) d\omega$</li><li>$\frac{ds}{dr}= \frac{dT(r)}{dr}= \frac{d[\int_{0}^{r}p_r(\omega) d\omega]}{dr}= p_r(r)$</li><li>$p_s(s)=p_r(r)|\frac{dr}{ds}|= p_r(r)|\frac{1}{p_r(r)}|=1,0\le s\le1$</li></ul></li><li>由分析可知，在给定的映射变换下，输出随机变量$s$服从均匀分布</li><li>$T(r)$虽然依赖于$p_r(r)$，但是得到的$p_s(s)$总是均匀的</li></ul></li><li>对于离散的情况，图像中亮度级$r_k$出现的概率为<ul><li>$p_k(r_k)=n_k/n, k = 0,1,2,…,L-1$</li><li>其中$n_k$为输入图像中$r_k$级的像素数目，$n$为图像中总的像素数目</li></ul></li><li>此时，变换函数为<ul><li>$s_k=T(r_k)=\sum_{j=0}^{k}p_r(r_j)=\sum_{j=0}^{k}n_j/n$</li><li>利用该映射，可将输入图像$r_k$级的每个像素映射到$s_k$级对应的像素，从而得到均衡后输出图像</li></ul></li><li>直方图均衡化是通过Matlab中的函数<code>g=histeq(f,nlev)</code>实现<ul><li>其中f为输入图像，g为均衡后的输出图像，nelv为输出图像指定的亮度级别数</li></ul></li></ul><p><strong>直方图均衡算法</strong></p><ul><li>对输入图像计算其直方图，并计算归一化直方图</li><li>利用累积映射计算输入图像中每个灰度级$r_k$对应的输出图像的灰度级$s_k$<ul><li>$s_k=T(r_k)=\sum_{j=0}^{k}n_j/n, k = 0,1,2,…,L-1$</li></ul></li><li>这时$s_k$为区间$[0,1]$的浮点数，可以通过$m_k=[s_k\times (L-1)]$将$s_k$转化为一个整数的灰度级别，其中符号<code>[]</code>代表某种取整操作</li><li>取整运算可能会导致多个输入灰度级对应同一个灰度级的输出，即$m_p=m_{p+1}=…=m_k=…=m_q$这时输出图线的灰度级$m_k$对应的归一化直方图中的概率值为对应的多个输入灰度级的概率值之和</li></ul><p><strong>直方图匹配</strong></p><ul><li>直方图匹配类似于直方图均衡化，只不过希望输出图像的直方图具有指定的形状</li><li>考虑标准化到区间$[0,1]$的连续亮度级，令$r$和$z$分别表示输入和输出图像的亮度级。输入图像的亮度分布服从概率密度函数$p_r(r)$，输出图像的亮度分布服从指定的概率密度函数$p_z(z)$</li><li>首先由$s=T(r)=\int_{0}^{r}p_r(\omega) d\omega$可以得到理想的均衡化直方图$p_s(s)$</li><li>假设变量$z$具有如下属性$H(z)=\int_{0}^{z}p_z(\omega) d\omega=s$</li><li>由上面两个等式可以推出$z=H^{-1}(s)=H^{-1}(T(r))$</li><li>从输入图像可以找到$T(r)$，只要找到$H^{-1}$，就可以得到变换后的亮度值z,它具有指定的概率密度函数$p_z(z)$</li></ul><h4 id="空域滤波技术"><a href="#空域滤波技术" class="headerlink" title="空域滤波技术"></a>空域滤波技术</h4><ul><li>$g(x,y)$在$(x,y)$处的输出值与$f(x,y)$在$(x,y)$处邻域内的像素有关，相关技术称为空域滤波器技术</li><li>在空域滤波中，输出图像中的每个输出像素值直接通过对输入图像同位置以及周围邻域内像素的简单计算得到的</li><li>空间滤波可以是线性的，也可以是非线性的</li><li>线性滤波应用更为广泛，主要通过卷积运算来实现</li></ul><p><strong>线性空域滤波</strong></p><ul><li><p>一般来说，一副大小为$M \times N$的图像被一个尺寸为$m \times n$的滤波器滤波可以通过下面的计算来获得</p><ul><li>$g(x,y)=\sum_{s=-a}^{a}\sum_{t=-b}^{b}\omega(s,t)f(x+s,y+t)$</li><li>其中，$a=(m-1)/2, b=(n-1)/2$</li><li>这个概念叫卷积（其实是相关）。滤波器掩码有时被称为卷积掩码或卷积核(<strong>destination pixel</strong>)</li><li>卷积操作需要先旋转180度$f(x,y) \rightarrow f(-x,-y)$</li></ul></li><li><p>相关与卷积</p><ul><li>相关：$(f\ast g)(t)=\int_{-\infty}^{+\infty}f^{\ast}(\tau)g(t+\tau)d\tau$,  $f^{\ast}(t)$表示 $f(t)$的共轭</li><li>卷积：$(f*g)(t)=\int_{-\infty}^{+\infty}f(\tau)g(t-\tau)d\tau$</li><li>相关：$(f\ast g)[n]=\sum_{m=-\infty}^{+\infty}f^{\ast} [m]g[n+m]$</li><li>卷积：$(f*g)[n]=\sum_{m=-\infty}^{+\infty}f[m]g[n-m]$</li></ul></li><li><p>卷积</p><ul><li><p>卷积相关运算是“动态”的点积运算，度量信号与参考信号或者模板的相似度</p></li><li><p>卷积的运算过程：置换变量 —&gt; 反转 —&gt; 平移 —&gt; 相乘 —&gt; 积分</p></li><li>卷积的性质<ul><li>交换性：$f(x)\ast g(x)=g(x)\ast f(x)$</li><li>结合性：$f(x)\ast g(x)\ast h(x)=f(x)\ast (g(x)\ast h(x))$</li><li>分配性：$(f(x)+g(x))\ast h(x)=f(x)\ast h(x)+g(x)\ast h(x)$</li><li>$a*\delta = a$</li></ul></li><li>相关与卷积相差一个旋转180度</li></ul></li><li><p>平滑线性滤波器</p><ul><li><p>盒式滤波器</p></li><li><p>加权均值滤波器</p></li><li><p>高斯滤波器（最常用）</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/平滑滤波器.png" alt=""></p></li></ul></li></ul><p><strong>线性移不变系统与卷积</strong></p><ul><li><p>线性系统$H$</p><ul><li>可叠加性：$H(f_1(x,y)+f_2(x,y))=H(f_1(x,y))+H(f_2(x,y))$</li><li>伸缩性：$H(af(x,y))=aH(f(x,y))$</li></ul></li><li><p>移不变系统$H$</p><ul><li>移不变性：若$H(f(x,y))=g(x,y)$，则$H(f(x-a,y-a))=g(x-a,y-a)$</li></ul></li><li>对于一个线性移不变系统来说，它的单位脉冲响应刻画了该系统的响应特性。换句话说，一旦知道了该系统的单位脉冲响应，可以推断出该系统对任何输入的响应</li><li>卷积用于计算线性移不变系统输入与输出的数学模型。具体地，若知道该系统的单位脉冲响应$h(x,y)$，则该系统的输入$f(x,y)$与输出$g(x,y)$之间可以用下式来表示。<ul><li>$g(x,y)=f(x,y)**h(x,y)$</li></ul></li><li>示例<ul><li>首先若已知$z[t]=x[t]<em>y[t]=[1]</em> [2,0,-2]=[2,0,-2]$</li><li>现有输入$x[t]=[1,2,3]=1\times[1,0,0]+2\times[0,1,0]+3\times[0,0,1]$</li><li>当用信号$x_0=1\times[1,0,0]$刺激系统时，有响应$z_0=[1\times 2,1\times 0,1\times (-2),{\color{Red} 0}  ,{\color{Red} 0} ]$</li><li>当用信号$x_1=2\times[0,1,0]$刺激系统时，有响应$z_1=[{\color{Red} 0} ,2\times 2,2\times 0,2\times (-2) ,{\color{Red} 0} ]$</li><li>当用信号$x_2=3\times[0,0,1]$刺激系统时，有响应$z_0=[{\color{Red} 0} ,{\color{Red} 0},3\times 2,3\times 0,3\times (-2)  ]$</li><li>把信号$x_0,x_1,x_2$叠加起来刺激系统时，响应为对应响应的叠加$z[t]+z_0+z_1+z_2=[2,4,4,-4,-6]$</li></ul></li></ul><p>锐化空间滤波器</p><ul><li>锐化的主要目标是突出图像中的细节(边缘)，或者增强模糊的细节</li><li>锐化通常是通过空间差分来完成的</li><li>数字图像函数的导数是通过差分来定义的</li><li>要求一阶导数必须满足<ul><li>平坦段必须为0 (灰度值恒定的区域)</li><li>在灰度阶跃或斜坡开始时必须非0</li><li>斜坡上一定是非0</li></ul></li><li>对于二阶导数必须满足<ul><li>在平坦段(灰度值恒定的区域)中必须为0</li><li>在灰度级阶跃或者斜坡的开始和结束时，必须是非0的</li><li>在坡度恒定的斜坡上必须为0</li></ul></li><li>一维函数$f(x)$一阶导数的一个基本定义就是差分<ul><li>$\frac{\partial f(x) }{\partial x} =f(x+1)-f(x)$ — 离散情况下相邻两个像素之间的距离为1</li><li>一阶差分一般用于边缘检测；因为在边缘处，差的绝对值是比较大的，检测值大的位置就是边缘，这样就可以把边缘提取出来。一阶导数通常对灰度阶跃(边缘)有更强的响应。</li></ul></li><li>同样地，定义二阶导数为<ul><li>$\frac{\partial^{2}f(x) }{\partial x^2}=f(x+1)-f(x)-(f(x)-f(x-1)) =f(x+1)+f(x-1)-2f(x)$</li><li>二阶差分一般用于图像锐化；因为经过两次差分之后，仍然留下的比较大的数值是特征点部分。二阶导数对细节有更强的响应</li><li>二阶差分的时候非零的只有一类，就是在变化开始和结束的时候，也就是特征点处</li></ul></li></ul><p>拉普拉斯滤波器</p><ul><li>拉普拉斯算子定义为<ul><li>$\bigtriangledown ^2f=\frac{\partial^{2}f }{\partial x^2}+\frac{\partial^{2}f }{\partial y^2}=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)$</li></ul></li><li>这里算出的结果只是<strong>差分结果</strong>(Mask)，并不是中间像素要被赋值的结果，赋值的结果应该是原本中间像素的值再<strong>减去</strong>Mask。</li><li>假如中间是一个灰度较大的值，周围灰度都很小，那么这个点就是一个特征点，需要被保存，现在经过拉普拉斯计算的值就是一个负的很大的值。因为我们是要<strong>增强</strong>特征点，所以原来的灰度大我们要让他<strong>更大</strong>，所以应该是原本灰度<strong>减</strong>差分结果。</li><li>拉普拉斯滤波器进行图像增强<ul><li>$g(x,y)=f(x,y)-\bigtriangledown ^2f(x,y)$</li><li>$=f(x,y)-(f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y))$</li><li>$=5f(x,y)-f(x+1,y)-f(x-1,y)-f(x,y+1)-f(x,y-1)$</li></ul></li></ul><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/Laplace滤波器.png" alt=""></p><p>反锐化掩模和高提升滤波</p><ul><li><p>以前印刷业经常用到的锐化方法，先将一张图平滑，也就是模糊掉，然后用原图减去模糊的图得到特征图Mask，然后原图加特征图得到锐化图</p></li><li><p>反锐化掩模是通过图像本身减去图像的模糊版本来实现的，即</p><ul><li>$f_s(x,y)=f(x,y)-\bar{f}(x,y)$</li><li>$\bar{f}(x,y)$表示原图$f(x,y)$的一个模糊版本</li></ul></li><li><p>对反锐化掩模的一种轻微推广称为高提升滤波，高提升滤波图像$h_{hb}(x,y)$定义为</p><ul><li>$h_{hb}(x,y)=f(x,y)+Af_s(x,y)$</li><li>$A \ge 1$</li></ul></li><li><p>$f(x,y)$的梯度表示为$(\frac{\partial f }{\partial x},\frac{\partial f }{\partial y})$</p></li></ul><p><strong>非线性空域滤波</strong></p><ul><li>非线性滤波通常也使用邻域，但是使用其他一些数学运算。例如，让每个中心点的响应等于其邻域内的最大像素值便是一种非线性滤波操作。</li><li>数字图像处理中最著名的阶序统计滤波器是中值滤波器</li></ul><h3 id="频域方法"><a href="#频域方法" class="headerlink" title="频域方法"></a>频域方法</h3><h4 id="傅立叶变换"><a href="#傅立叶变换" class="headerlink" title="傅立叶变换"></a>傅立叶变换</h4><p><strong>傅立叶级数</strong></p><ul><li><p>三角函数系:$\{0,1,sinx,cosx,sin2x,cos2x,…,sinnx,cosnx\}$</p></li><li><p>正交：</p><ul><li><p>$\int_{-\pi}^{+\pi}\sin nx\cos mxdx=0$</p></li><li><p>$\int_{-\pi}^{+\pi}\cos nx\cos mxdx=0, n \neq m$</p></li></ul></li><li><p>周期为$\color{red}2\pi$的函数展开为傅立叶级数</p><ul><li><p>$T=2\pi,f(x)=f(x+2\pi)$</p></li><li><p>$f(x)=\sum_{n=0}^{\infty}a_ncosnx+\sum_{n=0}^{\infty}b_nsinnx$ </p><p>​          $=a_0+\sum_{n=1}^{\infty}(a_n\cos nx+b_n\sin nx)$ </p></li><li><p>求解$a_0$，等式两边同时在$[-\pi,+\pi]$上积分</p></li><li><p>$\int_{-\pi}^{+\pi}f(x)dx=\int_{-\pi}^{+\pi}a_0dx+\int_{-\pi}^{+\pi}\sum_{n=1}^{\infty}(a_n\cos nx+b_n\sin nx)dx=2\pi a_0$</p><p>$\Rightarrow a_0=\frac{1}{2\pi}\int_{-\pi}^{+\pi}f(x)dx$</p></li><li><p>求解$a_n$，同乘$\color{red}{\cos mx}$后在$[-\pi,+\pi]$上积分</p></li><li><p>$\int_{-\pi}^{+\pi}f(x){\color{red}\cos mx}dx=\int_{-\pi}^{+\pi}a_0{\color{red}\cos mx}dx+\int_{-\pi}^{+\pi}\sum_{n=1}^{\infty}(a_n\cos nx{\color{red}\cos mx}+b_n\sin nx{\color{red}\cos mx})dx$</p></li><li><p>$\int_{-\pi}^{+\pi}f(x){\color{red}\cos mx}dx=\int_{-\pi}^{+\pi}a_n\cos nx{\color{red}\cos nx}dx=a_n\pi$ (积化和差)</p></li><li><p>$\Rightarrow a_n=\frac{1}{\pi}\int_{-\pi}^{+\pi}f(x)\sin nxdx$</p></li><li><p>同理求解$b_n$，同乘$\color{red}{\sin mx}$后在$[-\pi,+\pi]$上积分</p></li><li><p>$b_n=\frac{1}{\pi}\int_{-\pi}^{+\pi}f(x)\cos nxdx$</p></li></ul></li><li><p>周期为$\color{red}2L$的函数展开为傅立叶级数</p><ul><li>对于$f(t+2L)=f(t)$函数</li><li>换元$x=\frac{\pi}{L}t,\ t=\frac{L}{\pi}x \Rightarrow f(t)=f(\frac{L}{\pi}x)=g(x)$</li><li>$g(x)=a_0+\sum_{n=1}^{\infty}(a_n\cos nx+b_n\sin nx)$ </li><li>$f(t)=a_0+\sum_{n=1}^{\infty}(a_n\cos\frac{n\pi}{L}t+b_n\sin \frac{n\pi}{L}t)$<ul><li>$a_0=\frac{1}{2L}\int_{-L}^{+L}f(t)dt$</li><li>$ a_n=\frac{1}{L}\int_{-L}^{+L}f(x)\sin \frac{n\pi}{L}tdt$</li><li>$b_n=\frac{1}{L}\int_{-L}^{+L}f(x)\cos \frac{n\pi}{L}tdt$</li></ul></li><li>工程中$t$从$0$开始，周期为$T=2L$，$\omega =\pi/L=2\pi/T$ (<strong>基频率</strong>)<ul><li>$f(t)=a_0+\sum_{n=1}^{\infty}(a_n\cos n\omega t+b_n\sin  n\omega t)$</li><li>$a_0=\frac{1}{T}\int_{0}^{T}f(t)dt$</li><li>$ a_n=\frac{2}{T}\int_{0}^{T}f(t)\sin n\omega tdt$</li><li>$b_n=\frac{2}{T}\int_{0}^{T}f(t)\cos n\omega tdt$</li></ul></li></ul></li><li><p>傅立叶级数的复数形式</p><ul><li><p>欧拉公式：$e^{j\theta}=cos\theta+jsin\theta$</p><ul><li>$\cos\theta=\frac{1}{2}(e^{j\theta}+e^{-j\theta})$</li><li>$\sin\theta=-\frac{1}{2}j(e^{j\theta}-e^{-j\theta})$</li></ul></li><li><p>$f(t)=a_0+\sum_{n=1}^{\infty}(a_n\cos n\omega t+b_n\sin  n\omega t)$</p><p>​         $=a_0+\sum_{n=1}^{\infty}(\frac{1}{2}a_n(e^{jn\omega t}+e^{-jn\omega t})-\frac{1}{2}jb_n(e^{jn\omega t}-e^{-jn\omega t}))$</p><p>​         $=a_0+\sum_{n=1}^{\infty}\frac{a_n-jb_n}{2}e^{jn\omega t}+\color{red}{\sum_{n=1}^{\infty}\frac{a_n+jb_n}{2}e^{-jn\omega t}}$</p><p>​         $=a_0+\sum_{n=1}^{\infty}\frac{a_n-jb_n}{2}e^{jn\omega t}+\color{red}{\sum_{n=-\infty}^{-1}\frac{a_{-n}+jb_{-n}}{2}e^{jn\omega t}(n\to -n)}$</p><p>​         $=\sum_{n=0}^{\color{red}0}a_0e^{jn\omega t}+\sum_{\color{red}n=1}^{\color{red}\infty}\frac{a_n-jb_n}{2}e^{jn\omega t}+\sum_{\color{red}n=-\infty}^{\color{red}-1}\frac{a_{-n}+jb_{-n}}{2}e^{jn\omega t}$</p><p>​         $=\sum_{n=-\infty}^{+\infty}C_ne^{jn\omega t}$</p><ul><li><p>$C_0=a_0=\frac{1}{T}\int_{0}^{T}f(t)dt$</p></li><li><p>$C_n(n=1,2,…)=\frac{a_n-jb_n}{2}=\frac{1}{T}\int_{0}^{T}f(t)(\cos n\omega t-j\sin n\omega t)dt$</p><p>​                                 $=\frac{1}{T}\int_{0}^{T}f(t)e^{-jn\omega t}dt$</p></li><li><p>$C_n(n=1,2,…)=\frac{a_{-n}+jb_{-n}}{2}=\frac{1}{T}\int_{0}^{T}f(t)(\cos n\omega t-j\sin n\omega t)dt$</p><p>​                                 $=\frac{1}{T}\int_{0}^{T}f(t)e^{-jn\omega t}dt$</p></li></ul></li><li><p>$f(t)=\sum_{n=-\infty}^{+\infty}C_ne^{jn\omega t},C_n=\frac{1}{T}\int_{0}^{T}f(t)e^{-jn\omega t}dt$</p></li></ul></li></ul><p><strong>傅立叶变换</strong></p><ul><li>满足条件(狄利克雷条件)的任何周期函数可以由一系列不同频率的正弦(余弦)函数叠加而成。这种相加形式又称为级数，所以也称为傅立叶级数。</li><li>即使不是周期性的函数也可以表示为正弦(余弦)函数叠加而成(傅立叶变换)</li><li>频域是指将一个信号经过傅立叶变换后所得到的信号表示形式</li><li>傅立叶变换的目的是将信号表示为各种频率正余弦信号的线性组合</li><li>距离原点越近的频率成分越低频，越偏离远点的频率成分越高频</li><li>图像的平滑区域与细节区域分别对应于频谱图的低频成分与高频成分</li></ul><p>连续傅立叶变换</p><ul><li><p>一维傅立叶变换及其逆变换</p><ul><li>傅立叶变换：$F(u)=\int_{-\infty}^{+\infty}f(x)e^{-j2\pi ux}dx$, $j=\sqrt{-1}$</li><li>傅立叶逆变换：$f(x)=\int_{-\infty}^{+\infty}F(u)e^{j2\pi ux}du$</li><li>$e^{-j2\pi ux}$和$e^{j2\pi ux}$互为共轭函数</li><li>A为一个正交阵$AA^{H}=E$，定义正交变换$Y=AX$，则$X=A^{H}Y$</li></ul></li><li>傅立叶变换就是在用一种特殊的正交基(正交函数$e^{j2\pi ux}$)在对原函数做线性变换<br> <img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/欧拉.png" alt=""></li><li><p>二维傅立叶变换及其逆变换</p><ul><li>傅立叶变换：$F(u,v)=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}f(x,y)e^{-j2\pi(ux+vy)} dxdy$</li><li>傅立叶逆变换：$f(x,y)=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}F(u,v)e^{j2\pi(ux+vy)} dudv$</li></ul></li></ul><p>离散傅立叶变换(DFT)</p><ul><li><p>傅立叶变换：$F(u)=\sum_{x=0}^{M-1}f(x)e^{-\frac{j2\pi ux}{M}},u=0,1,2,…,M-1$</p><ul><li>由于$e^{j\theta}=cos\theta+jsin\theta$</li><li>$F(u)=\sum_{x=0}^{M-1}f(x)(cos(2\pi ux/M)-jsin(2\pi ux/M))$</li></ul></li><li><p>逆变换：$f(x)=\frac{1}{M}\sum_{u=0}^{M-1}F(u)e^{\frac{j2\pi ux}{M}},x=0,1,2,…,M-1$</p></li><li>频域：函数$F(u)$的自变量$u$的定义域范围，$u$描述变换中对应的频率分量的频率</li><li>频率分量：$F(u)$的$M$项中的每一项</li><li><p>$F(u)$可以用极坐标来表示</p><ul><li>$F(u)=|F(u)|e^{j\phi (u)}$</li><li>其中，$|F(u)|=(R^{2}(u)+I^{2}(u))^{\frac{1}{2}}$(幅度谱或频谱)<ul><li>由于$F(u)$为复函数形式，总是使用频谱表示傅里叶变换的结果</li><li>频谱描述了图像中某种频率的成分数量</li></ul></li><li>频率中出现的明亮线反映了原始图像的灰度级变化方向 (即图像的轮廓线或由灰度急剧变化来表征的内容，其方向与频谱中的明亮线相互垂直)</li><li>$\phi (u)=tan^{-1}\frac{I(u)}{R(u)}$(相位角或相位谱)</li><li>$I(u)$：$F(u)$的虚部；$R(u)$：$F(u)$的实部</li></ul></li><li><p>功率谱$P(u)=|F(u)|^{2}=R^{2}(u)+I^{2}(u)$</p></li></ul><p>二维离散傅立叶变换(2D DFT)</p><ul><li><p>傅立叶变换：$F(u,v)=\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)e^{-j2\pi( \frac{ux}{M}+\frac{vy}{N})}$</p><ul><li>$u=0,1,2,…,M-1,v=0,1,2,…,N-1$</li></ul></li><li><p>逆变换：$f(x,y)=\frac{1}{MN}\sum_{u=0}^{M-1}\sum_{v=0}^{N-1}F(u,v)e^{j2\pi( \frac{ux}{M}+\frac{vy}{N})}$</p><ul><li>$x=0,1,2,…,M-1,y=0,1,2,…,N-1$</li></ul></li><li>$u,v$：频率变量</li><li><p>$x,y$：空间变量</p></li><li><p>$|F(u,v)|=(R^{2}(u,v)+I^{2}(u,v))^{\frac{1}{2}}$(幅度谱或频谱)</p></li><li>$\phi (u,v)=tan^{-1}\frac{I(u,v)}{R(u,v)}$(相位角或相位谱)</li><li>$P(u,v)=|F(u,v)|^{2}=R^{2}(u,v)+I^{2}(u,v)$(功率谱)</li></ul><p><strong>二维离散傅立叶变换的性质</strong></p><ul><li>对于$\mathscr{F}(f(x,y))=F(u,v)$</li></ul><ol><li><p>空域平移性质</p><ul><li>$\mathscr{F}(f(x-x_0,y-y_0))=F(u,v)e^{-j2\pi( \frac{ux_0}{M}+\frac{vy_0}{N})}$</li><li>空域上的平移操作相当于在频域上围绕原点发生旋转，幅度频谱不改变</li></ul></li><li><p>频域平移性质</p><ul><li>$\mathscr{F}(f(x,y)e^{j2\pi( \frac{u_0x}{M}+\frac{v_0y}{N})})=F(u-u_0,v-v_0)$</li><li>$\mathscr{F}(f(x,y)(-1)^{x+y})=F(u-M/2,v-N/2),(u_0=M/2,v_0=N/2)$<ul><li>原式$=e^{j\pi(x+y)}=\cos(x+y)\pi+j\sin(x+y)\pi=(-1)^{x+y}$</li><li>应用于将最亮的位置转移到图像中心</li></ul></li></ul></li><li><p>平均和对称性质</p><ul><li><p>$\bar f(x,y)=\frac{1}{MN}F(0,0)=\frac{1} {MN}\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)$ </p></li><li><p>$F(u,v)=F^{*}(-u,-v)$ (共轭对称)</p><ul><li><p>数字图像$f(x,y)$是实函数</p></li><li><p>数字图像的傅里叶变换是中心对称的</p></li></ul></li><li><p>$|F(u,v)|=|F(-u,-v)|$ (幅度谱中心对称)</p></li></ul></li><li><p>可分离性质</p><ul><li><p>$F(u,v)=\mathscr{F}(f(x,y))$</p><p>​               $=\sum_{y=0}^{N-1}(\sum_{x=0}^{M-1}f(x,y)e^{-j2\pi{ux}/{M}})e^{-j2\pi {vy}/{N}}$</p><p>​               $=\sum_{y=0}^{N-1}F(u,y)e^{-j2\pi {vy}/{N}}$</p></li><li><p>$F(u,v)$的二维离散傅立叶变换可以通过一下计算方式得到</p><ul><li>对图像$f(x,y)$的每一行计算其一维傅立叶变换得到$F(u,y)$</li><li>对图像$F(u,y)$再进行一维离散傅立叶变换</li></ul></li></ul></li><li><p>旋转性质</p><ul><li>令，$x=rcos\theta,y=rsin\theta,u=\omega\cos\phi,v=\omega\sin\phi$</li><li>则，$f(r,\theta+\theta_0)\Leftrightarrow F(\omega,\phi+\theta_0)$</li></ul></li><li>周期性<ul><li>$f(x,y)=f(x+M,y)=f(x,y+N)=f(x+M,y+N)$</li><li>$F(u,v)=F(u+M,v)=F(u,v+N)=F(u+M,v+N)$</li></ul></li><li><p>线性</p><ul><li>$\mathscr{F}(af(x,y)+bg(x,y))=a\mathscr{F}(f(x,y))+b\mathscr{F}(g(x,y))$</li></ul></li><li>微分性质<ul><li>$\mathscr{F}(\frac{\partial^{n}f(x,y) }{\partial x^n})=(j2\pi u)^n\mathscr{F}(f(x,y))=(j2\pi u)^nF(u,v)$</li><li>$\mathscr{F}((-j2\pi u)^{n}f(x,y))=\frac{\partial^{n}F(u,v) }{\partial u^n}$</li><li>$\mathscr{F}(\bigtriangledown ^2f(x,y))=-4\pi^{2}(u^{2}+v^{2})F(u,v)$</li></ul></li><li><p>卷积定理</p><ul><li>$\mathscr{F}(f(x,y)*g(x,y))=F(u,v)G(u,v)$</li><li>$\mathscr{F}(f(x,y)g(x,y))=F(u,v)*G(u,v)$</li></ul></li><li><p>相关定理</p><ul><li>$\mathscr{F}(f(x,y)\circ g(x,y))=F^{*}(u,v)G(u,v)$</li><li>$\mathscr{F}(f(x,y)\circ f(x,y))=|F(u,v)|^{2}$</li><li>$\mathscr{F}(f^{*}(x,y) g(x,y))=F(u,v)\circ G(u,v)$</li><li>$\mathscr{F}(|f(x,y)|^{2})=F(u,v)\circ F(u,v)$</li></ul></li><li><p>伸缩性质</p><ul><li>$\mathscr{F}(f(ax,by))=\frac{1}{|ab|}F(\frac{u}{a},\frac{v}{b})$</li></ul></li></ol><p><strong>傅立叶变换对</strong></p><ul><li>$\delta(x,y)\Leftrightarrow 1$</li><li>$A2\pi\sigma^{2}e^{-2\pi^{2}\sigma^{2}(x^2+y^2)}\Leftrightarrow Ae^{-(u^2+v^2)/2\sigma^2}$<ul><li><em>高斯函数的傅立叶变换仍是高斯函数</em></li><li>$e^{-\pi(x^2+y^2)}\Leftrightarrow e^{-\pi(u^2+v^2)}$</li></ul></li><li>$\cos(2\pi u_0x+2\pi v_0y) \Leftrightarrow \frac{1}{2}(\delta(u+u_0,v+v_0)+(\delta(u-u_0,v-v_0))$<ul><li>$\cos\theta=\frac{1}{2}(e^{j\theta}+e^{-j\theta})$</li><li>频域上对称的两个脉冲信号</li></ul></li><li>$\sin(2\pi u_0x+2\pi v_0y) \Leftrightarrow \frac{1}{2}j(\delta(u+u_0,v+v_0)-(\delta(u-u_0,v-v_0))$</li></ul><h4 id="频域滤波"><a href="#频域滤波" class="headerlink" title="频域滤波"></a>频域滤波</h4><ul><li>空间域和频域中线性滤波的基础是卷积定理，它可以写成<ul><li><script type="math/tex; mode=display">f(x,y)*h(x,y)\Leftrightarrow F(u,v)H(u,v)</script></li></ul></li><li>频域滤波器的基本想法是选择一个特定的滤波器传递函数来修改输入图像的傅里叶变换$F(u,v)$</li><li>基于卷积定理，可以知道为了在空域中获得相应的滤波图像，只需要简单的计算输入图像的傅里叶变换与滤波器乘积$H(u,v)F(u,v)$的逆傅里叶变换</li><li>如果周期相对于函数的非零部分的长度非常接近，则周期函数的卷积可能带来相邻周期内的非零部分信号的干扰，这种干扰称为混叠误差(卷积后的大小为$L+l-1$)，可以用零填充的技术手段消除 </li></ul><p>频率域滤波的基本步骤</p><ol><li>用$(-1)^{x+y}$乘以输入图像$f(x,y)$，使其原点中心化</li><li>对步骤1的结果执行DFT，得到关于中心对称的频谱$F(u,v)$</li><li>生成实的、中心对称的频域滤波器$H(u,v)$</li><li>对滤波器$H(u,v)$、频谱$F(u,v)$阵列相乘(对应元素逐个进行相乘)，形成乘积$G(u,v)=H(u,v)F(u,v)$，其中$G(m,n)=H(m,n)F(m,n)$</li><li>对步骤4的结果$G(u,v)$执行反DFT，并取其结果的实部</li><li><p>用$(-1)^{x+y}$乘以步骤5的反DFT结果的实部，得到滤波结果$g(x,y)$</p><p>如何获取频域滤波器</p></li><li><p>从空域滤波器获取频域滤波器</p></li><li>频域中直接构造滤波器</li></ol><p><strong>频域中直接构造滤波器</strong></p><p><strong>低通滤波器（平滑）</strong></p><ul><li><p>使频谱的低频成分通过，同时使其高频成分衰减</p></li><li><p>理想的低通滤波器(<strong>ILPF</strong>)</p><ul><li><script type="math/tex; mode=display">H(u,v) = \begin{cases}1,if\  D(u,v)\le  D_0\\0,if\  D(u,v) >  D_0\end{cases}</script></li><li><p>其中，$D(u,v)$表示从点$(u,v)$到频率矩形中心的距离</p><script type="math/tex; mode=display">D(u,v)=\sqrt{(u-M/2)^2+(v-N/2)^2}</script></li><li><p>$D_0$称为截止频率，$D_0$越小保留的信息越少越模糊</p></li><li><p>截止频率可以通过频谱中通过的功率占比选择</p><ul><li><p>总功率: <script type="math/tex">P_{T}=\sum_{0}^{M-1}\sum_{0}^{N-1}P(u,v)</script></p></li><li><p>通过截止频率为$D_0$低通滤波器：<script type="math/tex">P_{pass}=\sum_{0}^{\hat{M} -1}\sum_{0}^{\hat{N}-1}P(u,v),\ \hat{M}<M,\ \hat{N}<N</script></p></li><li><script type="math/tex">\frac{P_{pass}}{P_T}\times 100 = \alpha</script>表示频域中心半径为$D_0$包含$\alpha%$的功率</li></ul></li><li><p>ILPF通常带有振铃效应(出现带有波纹的模糊图像)</p></li></ul></li><li><p>巴特沃斯低通滤波器(<strong>BLPF</strong>)</p><ul><li><script type="math/tex; mode=display">H(u,v) =\begin{pmatrix}1+(D(u,v)/D_0)^{2n}\end{pmatrix}^{-1}</script></li><li>阶数n越大越趋于理想的低通滤波器</li><li>高阶BLPF会出现振铃效应</li></ul></li><li>高斯低通滤波器(<strong>GLPF</strong>)<ul><li><script type="math/tex; mode=display">H(u,v)=e^{-D^{2}(u,v)/2D_0^2}</script></li><li>高斯低通滤波器不能达到相同截止频率的BLPF低通滤波器的平滑效果</li><li>高斯低通滤波器没有振铃效果(高斯函数的傅里叶逆变换仍是高斯函数)</li></ul></li></ul><p><strong>高通滤波器（锐化）</strong></p><ul><li>使频谱的高频成分通过，同时使其低频成分衰减</li><li><p>通用高通频域滤波器 </p><ul><li><script type="math/tex; mode=display">H_{hp}(u,v) = 1-H_{lp}(u,v)</script></li></ul></li><li><p>理想的高通滤波器 (<strong>IHPF</strong>)</p><ul><li><script type="math/tex; mode=display">H(u,v) = \begin{cases}0,if\  D(u,v)\le  D_0\\1,if\  D(u,v) >  D_0\end{cases}</script></li></ul></li><li><p>巴特沃斯高通滤波器 (<strong>BHPF</strong>)</p><ul><li><script type="math/tex; mode=display">H(u,v) =\begin{pmatrix}1+(D_0/D(u,v))^{2n}\end{pmatrix}^{-1}</script></li></ul></li><li>高斯高通滤波器 (<strong>GHPF</strong>)<ul><li><script type="math/tex; mode=display">H(u,v)=1-e^{-D^{2}(u,v)/2D_0^2}</script></li></ul></li><li>图像经过高通滤波后，其背景的平均强度减少到接近黑色 (高通滤波器除去了傅里叶变换的零频率成分)</li><li>解决方法：把原始图像加到滤波后的结果图像中，即高频提升滤波或高频加强滤波</li><li>高频加强滤波(*)<ul><li><script type="math/tex; mode=display">H_{hfe}(u,v)=a+bH_{hp}(u,v)</script></li><li>在高通滤波器函数前乘以一个常数，再增加一个偏移量以便使零频率不被滤波器滤除掉</li></ul></li></ul><p><strong>同态滤波</strong></p><ul><li><p>同态滤波基于图像的成像模型，在频域压缩灰度动态范围，增强对比度</p><ul><li><script type="math/tex; mode=display">f(x,y)=I(x,y)\times R(x,y)</script></li><li><script type="math/tex">I(x,y)</script>表示照射分量，<script type="math/tex">R(x,y)</script>表示反射分量</li></ul></li><li><p>人眼对于图像亮度的响应具有类似于对数运算</p><ul><li><script type="math/tex; mode=display">lnf(x,y)=lnI(x,y)+lnR(x,y)</script></li><li>照射分量在整个空间区域缓慢变化</li><li>反射分量在物体间的交界处急剧变化</li></ul></li><li><p>对成像模型的对数形式做傅里叶变换</p><ul><li><script type="math/tex; mode=display">\hat{F}(u,v)= \hat{I}(u,v)+\hat{R}(u,v)</script></li><li><script type="math/tex">\hat{I}(u,v)</script>低频分量</li><li><script type="math/tex">\hat{R}(u,v)</script>高频分量</li></ul></li><li><p>令<script type="math/tex">\hat{G}(u,v)= H(u,v)\times\hat{F}(u,v)</script></p><ul><li><script type="math/tex; mode=display">\hat{G}(u,v)= H(u,v)\times\hat{I}(u,v)+ H(u,v)\times\hat{R}(u,v)</script></li></ul></li><li><p>傅里叶逆变换</p><ul><li><script type="math/tex; mode=display">g(x,y)= \hat{I}(x,y)+ \hat{R}(x,y)</script></li></ul></li><li><p>指数变换</p><ul><li><script type="math/tex; mode=display">g(x,y)= \exp {(\hat{I}(x,y)+ \hat{R}(x,y))}</script></li></ul></li><li><p><script type="math/tex">H(u,v)</script>的设计</p><ul><li>抑制低频，压缩图像的动态范围</li><li>增强高频，加大各部分间的对比度</li></ul></li></ul><p>基于Retinex滤波</p><ul><li>Retina：视网膜</li><li>Cortex：大脑皮层</li></ul><p>Retinex理论</p><ul><li>物体颜色：物体表面对长波、中波、短波的反射特性</li><li>人眼视觉：观察物体时首先寻找标准的“白光”；计算色差，从而得到物体的信息</li><li>入射光决定了图像灰度级的动态范围</li><li><strong>反射光</strong>决定了图片具有的内在本质</li><li><script type="math/tex; mode=display">f(x,y)=I(x,y)\times \color{red}R(x,y)</script><ul><li><script type="math/tex; mode=display">\ln f(x,y)=\ln I(x,y)+ \color{red}\ln R(x,y)</script></li><li><script type="math/tex; mode=display">{\color{red}\ln R(x,y)}=\ln f(x,y)-\ln I(x,y)</script><ul><li>$\ln f(x,y)$已知；$\ln I(x,y)$估算</li></ul></li><li>入射分量具有缓和平滑性</li><li>入射分量与反射光具有一定的弱相关性</li></ul></li><li>环绕函数法<ul><li>$I(x,y)=f(x,y)*h(x,y)$</li><li><script type="math/tex; mode=display">h(x,y)=\frac{1}{2\pi\sigma_x\sigma_y}e^{-\frac{1}{2}(\frac{x^{2}}{\sigma_x^{2}}+\frac{y^{2}}{\sigma_y^{2}})}</script></li><li><script type="math/tex; mode=display">R(x,y)=\exp(\ln f(x,y)-\ln (f(x,y*h(x,y))))</script></li></ul></li></ul><h2 id="图像复原"><a href="#图像复原" class="headerlink" title="图像复原"></a>图像复原</h2><ul><li><p>图像复原：以某种预定义的方式改善给定图像</p></li><li><p>图像退化与复原的数学模型</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/复原模型.png" alt=""></p><ul><li><script type="math/tex; mode=display">g(x,y)=H(f(x,y))+\eta(x,y)</script></li><li><script type="math/tex; mode=display">g(x,y)=h(x,y)*f(x,y)+\eta(x,y)</script><ul><li>($H$线性移不变系统)</li></ul></li><li><script type="math/tex; mode=display">G(u,v)=H(u,v)F(u,v)+N(u,v)</script></li></ul></li></ul><h3 id="噪声模型"><a href="#噪声模型" class="headerlink" title="噪声模型"></a>噪声模型</h3><p><strong>独立同分布的空域随机噪声</strong></p><ul><li>如果$\omega$是区间$(0,1)$上服从均匀分布的随机变量，那么我们可以通过求解方程得到一个具有指定累积分布函数(CDF)$F_z$的随机变量$z$<ul><li>$z=F_z^{-1}(\omega)$</li><li>设$z$为服从任意分布的随机变量，根据直方图均衡中的结果$\omega=F_z(z)$服从$(0,1)$的均匀分布</li></ul></li><li>例：用瑞利CDF生成随机数z<ul><li><script type="math/tex; mode=display">F_z(z)=\begin{cases}1-e^{(z-a)^{2}/b},\ if\  z \ge a\\0,\ if\  z < a\end{cases}</script></li><li>$\omega=1-e^{(z-a)^{2}/b}$</li><li>$z=a+\sqrt{-b+ln(1-\omega)}$</li></ul></li></ul><p><strong>周期噪声</strong></p><ul><li>$r(x,y)=A\sin (2\pi u_0(x+B_x)/M+2\pi v_0(y+B_y)/N)$</li></ul><p><strong>估算噪声参数</strong></p><ul><li><p>通过对图像的傅里叶频谱的审视来估计周期性噪声的参数，例如通过肉眼去发现频谱中的频域尖峰</p></li><li><p>尝试直接从图像推断噪声分量的周期性通常仅在简单的情况下是可行的</p></li><li><p>在噪声尖峰非常明显，或者具有对于干扰的频率分量一般位置的先验知识的情况下，才可以进行自动分析。</p></li><li><p>噪声PDF的参数可以部分从传感器规范中得知，但通常需要针对特定的成像环境估计它们，例如，一组“平坦”环境</p></li><li><p>当仅有生成的图像可用时，通常可以从相对恒定灰度级的图像小区域中估计噪声PDF的参数</p></li><li><p>最简单的方法就是利用图像中的采样数据来估计噪声的均值和方差</p></li><li><p>通过直方图的形状来辨识最接近的PDF匹配</p></li></ul><p>统计矩和中心距</p><ul><li>$\mu_n=\sum_{i=0}^{L-1}(z_i-m)^np(z_i),\ m=\sum_{i=0}^{L-1}z_ip(z_i)$</li><li>where $n=0$, $\mu_0=\sum_{i=0}^{L-1}(z_i-m)^0p(z_i)=1$</li><li>where $n=1$, $\mu_1=\sum_{i=0}^{L-1}(z_i-m)p(z_i)=\sum_{i=0}^{L-1}z_ip(z_i)-m\sum_{i=0}^{L-1}p(z_i)=0$</li><li>where $n=2$, $\mu_2=\sum_{i=0}^{L-1}(z_i-m)^2p(z_i)=Var(z)$</li></ul><h3 id="只存在噪声的复原"><a href="#只存在噪声的复原" class="headerlink" title="只存在噪声的复原"></a>只存在噪声的复原</h3><h4 id="空域滤波"><a href="#空域滤波" class="headerlink" title="空域滤波"></a>空域滤波</h4><p>如果只有噪声，图像退化模型可以表示为</p><ul><li>$g(x,y) = f(x,y) + \eta(x,y)$</li><li>$G(u,v) = F(u,v) +N(u,v)$</li></ul><p><strong>空域噪声滤波器</strong></p><p>均值滤波器</p><ul><li><p>算数平均滤波器</p><ul><li><p>$\hat{f}(x,y)=\frac{1}{mn}\sum_{(s,t)\in S_{xy}}g(s,t)$</p></li><li><p>$S_{xy}表示以(x,y)为中心的一个邻域$</p></li></ul></li><li><p>几何均值滤波器</p><ul><li>$\hat{f}(x,y)=\sqrt[mn]{ {\textstyle \prod_{(s,t)\in S_{xy}}} g(s,t)}$</li></ul></li><li>谐波均值滤波器<ul><li>$\hat{f}(x,y)=\frac{mn}{\sum_{(s,t)\in S_{xy}}1/g(s,t)}$</li><li>谐波均值滤波器不能消除椒盐噪声，对高斯噪声效果很好</li></ul></li><li>逆谐波均值滤波器<ul><li>$\hat{f}(x,y)=\frac{\sum_{(s,t)\in S_{xy}}g(s,t)^{Q+1}}{\sum_{(s,t)\in S_{xy}}g(s,t)^{Q}}$<ul><li>设$A=\sum_{(s,t)\in S_{xy}}g(s,t)^{Q}$</li><li>$原式=\sum_{(s,t)\in S_{xy}}\frac{g(s,t)^{Q}}{A}g(s,t)$</li><li>因此，原式可以看做$g(s,t)$的加权求和</li><li>$Q&gt;0$时，$g$越大权重系数越大，可消除椒噪声</li><li>$Q&lt;0$时，$g$越大权重系数越小，可消除盐噪声</li></ul></li><li>$Q$称为滤波器的阶数</li><li>$Q=0$简化为算数均值滤波器</li><li>$Q=-1$简化为谐波均值滤波器</li><li>椒盐噪声又叫冲击噪声（或者脉冲噪声）。在图像中的表现为离散分布的纯白色或者黑色像素点。由于在正常情况下，在图像中不太可能出现最大/最小值的灰度像素，因此这样的像素点可以被当成噪点。</li><li>逆谐波均值滤波器非常适合消除椒盐噪声的影响。当$Q&gt;0$时，该滤波器可消除椒噪声；当$Q&lt;0$时，适合消除盐噪声。它不能同时消除两种噪声</li></ul></li></ul><p>统计排序滤波器</p><ul><li><p>中值滤波器</p><ul><li><script type="math/tex; mode=display">\hat{f}(x,y)={\mbox{ median}}_{(s,t)\in S_{xy}}g(s,t)</script></li></ul></li><li><p>最大、最小滤波器</p><ul><li><script type="math/tex; mode=display">\hat{f}(x,y)= \max_{(s,t)\in S_{xy}} g(s,t)</script></li><li><script type="math/tex; mode=display">\hat{f}(x,y)=\min_{(s,t)\in S_{xy}} g(s,t)</script></li></ul></li><li><p>中点滤波器</p><ul><li><script type="math/tex; mode=display">\hat{f}(x,y)=(\max_{(s,t)\in S_{xy}} g(s,t)+\min_{(s,t)\in S_{xy}} g(s,t))/2</script></li></ul></li><li><p>$\alpha$均值滤波器</p><ul><li><p>$\hat{f}(x,y)=\frac{1}{mn-d}\sum_{(s,t)\in S_{xy}}g_r(s,t)$</p></li><li><p>在邻域$S_{xy}$内去掉$g(s,t)$最低灰度值的$d/2$和最高灰度值的$d/2$</p></li></ul></li></ul><p>自适应空域中值滤波器</p><ul><li><p>符号</p><ul><li>$z_{\min} = S_{xy}中的最小灰度值$</li><li>$z_{\max} = S_{xy}中的最大灰度值$</li><li>$z_{med} = S_{xy}中的灰度值的中值$</li><li>$z_{xy} = 坐标(x,y)处的灰度值$</li><li>$S_{\max}=S_{xy}允许的最大尺度$</li></ul></li><li><p>自适应中值滤波算法以两个进程工作，表示为Level A和Level B，如下所示</p><p>Level A：</p><ul><li>$A_1=z_{med} - z_{\min}$</li><li>$A_2=z_{med} - z_{\max}$</li><li>if $A_1&gt;0$ and $A_2&lt;0$ (中值介于最大值和最小值之间，不是椒噪声也不是盐噪声), go to Level B</li><li>else increase the window size</li><li>if window size $\le S_{\max}$, repeat Level A</li><li>else output $z_{med}$</li></ul><p>Level B:</p><ul><li>$B_1=z_{xy} - z_{\min}$</li><li>$B_2=z_{xy} - z_{\max}$</li><li>if $B_1&gt;0$ and $B_2&lt;0$ (当前值不是椒噪声也不是盐噪声), output $z_{xy}$</li><li>else output $z_{med}$</li></ul></li></ul><h4 id="频域滤波-1"><a href="#频域滤波-1" class="headerlink" title="频域滤波"></a>频域滤波</h4><ul><li>用频率域技术可以有效地分析并滤除周期噪声。在傅里叶变换中，周期噪声在对应于周期干扰的频率处，以集中的能量脉冲形式出现</li></ul><p><strong>带阻滤波器</strong></p><ol><li>理想带阻滤波器<ul><li><script type="math/tex; mode=display">H(u,v) = \begin{cases} 1,if\  D(u,v) <  D_0 -\frac{W}{2}\\ 0,if\  D_0 -\frac{W}{2}< D(u,v)<  D_0 +\frac{W}{2} \\ 1,if\ D(u,v)>  D_0 +\frac{W}{2} \end{cases}</script></li></ul></li><li>巴特沃斯带阻滤波器<ul><li><script type="math/tex; mode=display">H(u,v) =\begin{pmatrix} 1+(\frac{D(u,v)W}{D^2(u,v)-D^2_0})^{2n} \end{pmatrix}^{-1}</script></li></ul></li><li>高斯带阻滤波器<ul><li><script type="math/tex; mode=display">H(u,v) = 1-\exp{ (-\frac{1}{2}(\frac{D^2(u,v)-D^2_0}{D(u,v)W})^{2}})</script></li></ul></li></ol><p><strong>带通滤波器</strong></p><ul><li><script type="math/tex; mode=display">H_{bp}(u,v) = 1 - H_{br}(u,v)</script></li><li>使用带通滤波器可以提取噪声信号</li></ul><p><strong>陷波滤波器</strong></p><ol><li>理想陷波滤波器<ul><li><script type="math/tex; mode=display">H(u,v)=\begin{cases} 0,\ if\  D_1(u,v) \le D_0 \ or \ D_2(u,v) \le D_0\\ 1, \ else \end{cases}</script></li><li><script type="math/tex; mode=display">D_1(u,v)=\sqrt{(u-\frac{M}{2}-u_0)^2-(v-\frac{N}{2}-v_0)^2}</script></li><li><script type="math/tex; mode=display">D_2(u,v)=\sqrt{(u-\frac{M}{2}+u_0)^2-(v-\frac{N}{2}+v_0)^2}</script></li><li>假设0频率在图像中心$(\frac{M}{2},\frac{N}{2})$</li></ul></li><li>巴特沃斯陷波滤波器<ul><li><script type="math/tex; mode=display">H(u,v) =\begin{pmatrix} 1+(\frac{D^2_0}{D_1(u,v)D_2(u,v)}) \end{pmatrix}^{-1}</script></li></ul></li><li>高斯陷波滤波器<ul><li><script type="math/tex; mode=display">H(u,v) = 1-\exp{ (-\frac{1}{2}(\frac{D_1(u,v)D_2(u,v)}{D^2_0}))}</script></li></ul></li></ol><p><strong>最佳陷波滤波算法</strong></p><ul><li><p>当存在多个干扰分量时，由于滤波过程去除的图像信息过多，上述方法的滤波效果并不总是可以接受的</p></li><li><p>这里讨论的方法的最优是在<em>最小化被复原图像局部方差</em>意义下的</p><ul><li>邻域内方差很小，意味着邻域内所有的信号值比较相近，没有发生突变</li></ul></li><li><p>首先通过如下计算获得对噪声的初始估计</p><ul><li>$N(u,v)=F_N(u,v)G(u,v)$</li><li>$\eta(x,y)={\mathscr{F}}^{-1}(F_N(u,v)G(u,v))$</li><li>$F_N(u,v)$是获取噪声干扰模式的陷波滤波器</li></ul></li><li><p>令$\hat{f}(x,y)=g(x,y)-\omega(x,y)\eta(x,y)$</p><ul><li>寻找调制函数$\omega(x,y)$，来最小化$\hat{f}(x,y)$的局部方差</li></ul></li><li><p>目标函数</p><ul><li><script type="math/tex; mode=display">\min\sigma^{2}(x,y)=\frac{1}{(2a+1)(2b+1)}\sum_{s=-a}^{a}\sum_{t=-b}^{b}(\hat{f}(x+s,y+t)-\bar{f})^2</script></li><li><script type="math/tex; mode=display">\bar{f}=\frac{1}{(2a+1)(2b+1)}\sum_{s=-a}^{a}\sum_{t=-b}^{b}\hat{f}(x+s,y+t)</script></li></ul></li></ul><ul><li><p>由(1)式可得</p><ul><li><p>$\sigma^{2}(x,y)=\frac{1}{(2a+1)(2b+1)}\sum_{s=-a}^{a}\sum_{t=-b}^{b}(g(x+s,y+t)-$</p><p>$\omega(x+s,y+t)\eta(x+s,y+t)-(\bar{g}(x,y)-\overline{\omega(x,y)\eta(x,y)}))^2$</p></li></ul></li><li><p>假设$\omega(x,y)$在整个邻域内基本保持不变，即$\omega(x+s,y+t)=\omega(x,y)$，有</p><ul><li><p>$\sigma^{2}(x,y)=\frac{1}{(2a+1)(2b+1)}\sum_{s=-a}^{a}\sum_{t=-b}^{b}(g(x+s,y+t)-$</p><p>$\omega(x,y)\eta(x+s,y+t)-(\bar{g}(x,y)-\omega(x,y)\bar{\eta}(x,y)))^2$</p></li></ul></li><li><p>为了最小化$\sigma^{2}(x,y)$，求解方程</p><ul><li><script type="math/tex; mode=display">\frac{\partial\sigma^2(x,y)}{\partial\omega (x,y)}=0</script></li></ul></li><li><p>求得的结果为</p><ul><li><script type="math/tex; mode=display">\omega(x,y)=\frac{\overline{g(x,y)\eta(x,y)}-\bar{g}(x,y)\bar{\eta}(x,y)}{\bar{\eta^2}(x,y)-\bar{\eta}^2(x,y)}</script></li></ul></li></ul><h3 id="含有退化函数的复原"><a href="#含有退化函数的复原" class="headerlink" title="含有退化函数的复原"></a>含有退化函数的复原</h3><h4 id="估计退化函数"><a href="#估计退化函数" class="headerlink" title="估计退化函数"></a>估计退化函数</h4><ul><li><p>图像观察估计法</p><ul><li>设$g_s(u,v)$为观测到图像的子图像，$\hat{f}_s(x,y)$为原始子图像的估计值，假设选择的是强信号区域，因此噪声可以忽略，有<ul><li><script type="math/tex; mode=display">H_s(u,v)=\frac{G_s(u,v)}{\hat{F}_s(u,v)}</script></li></ul></li><li>然后可以从$H_s(u,v)$推导出完整的函数$H(u,v)$</li><li>实验估计方法 </li></ul></li><li><p>实验估计方法</p><ul><li><script type="math/tex; mode=display">H(u,v)=\frac{G(u,v)}{A}</script></li><li>$G(u,v)$是观察图像的傅里叶变换</li><li>$A$是一个描述冲激强度的常量</li></ul></li><li><p>建模估计法</p><ul><li>基于大气湍流的物理特征提出</li></ul><ul><li><script type="math/tex; mode=display">H(u,v)=e^{-k(u^2+v^2)^{5/6}}</script></li><li><p>$k$是与湍流的性质有关的常数</p></li><li>$k \rightarrow 0, \ H(u,v)\rightarrow 1$，无退化</li></ul></li><li><p>建模运动带来的图像模糊退化</p><ul><li><p>$g(x,y)= \int_{0}^{T}f(x-x_0(t),y-y_0(t))dt$</p><ul><li>$g(x,y)$为模糊后的图像</li></ul></li><li><p>对其进行傅里叶变换有</p><script type="math/tex; mode=display">G(u,v)=\int_{-\infty}^{-\infty}\int_{-\infty}^{-\infty} g(x,y)e^{-j2\pi( ux+vy)}dxdy</script><script type="math/tex; mode=display">=\int_{-\infty}^{-\infty}\int_{-\infty}^{-\infty}\left ( \int_{0}^{T}f(x-x_0(t),y-y_0(t))dt \right ) e^{-j2\pi( ux+vy)}dxdy</script><script type="math/tex; mode=display">=\int_{0}^{T}\left ( \int_{-\infty}^{-\infty}\int_{-\infty}^{-\infty}f(x-x_0(t),y-y_0(t))e^{-j2\pi( ux+vy)}dxdy \right )dt</script></li><li><p>根据傅里叶变换的平移性质</p><script type="math/tex; mode=display">原式= \int_{0}^{T}F(u,v)e^{-j2\pi( ux_0(t)+vy_0(t))}dt</script><p>$= F(u,v)\int_{0}^{T}e^{-j2\pi( ux_0(t)+vy_0(t))}dt$</p></li><li><p>因此</p><script type="math/tex; mode=display">H(u,v)=\int_{0}^{T}e^{-j2\pi( ux_0(t)+vy_0(t))}dt</script></li><li><p>若$x_0(t)=at/T,y_0(t)=0$，(水平方向匀速运动，垂直方向不变)那么</p><script type="math/tex; mode=display">H(u,v)=\int_{0}^{T}e^{-j2\pi uat/T}dt=\frac{T}{\pi ua}\sin(\pi ua)e^{-j\pi ua}</script></li><li><p>若$y_0(t)=bt/T$，那么</p><script type="math/tex; mode=display">H(u,v)=\frac{T}{\pi(ua+vb)}\sin(\pi(ua+vb))e^{-j\pi (ua+vb)}</script></li></ul></li></ul><h4 id="逆滤波"><a href="#逆滤波" class="headerlink" title="逆滤波"></a>逆滤波</h4><ul><li><p><a href="https://blog.csdn.net/bluecol/article/details/47357717">https://blog.csdn.net/bluecol/article/details/47357717</a></p></li><li><p>对于一副被退化函数$H$降质的图像，最简单的复原方法就是直接采用逆滤波，即</p><ul><li>$\hat{F}(u,v)=\frac{G(u,v)}{H(u,v)}$ (假设$N(u,v)=0$)</li><li>该除法是阵列操作，即按位除。</li></ul></li><li><p>进一步，由$G(u,v)=H(u,v)F(u,v)+N(u,v)$可以得到</p><ul><li><script type="math/tex; mode=display">\hat{F}(u,v)=F(u,v) + \frac{N(u,v)}{H(u,v)}</script></li></ul></li><li><p>如果退化函数$H(u,v)$在某一个频率点的值为$0$或很小的值，那么比值$N(u,v)/H(u,v)$很容易压制信号，造成$F(u,v)$的估计存在较大误差。一种解决方法是只利用原点附近退化函数的值来进行逆滤波(受限逆滤波)的计算</p></li></ul><h4 id="维纳滤波"><a href="#维纳滤波" class="headerlink" title="维纳滤波"></a>维纳滤波</h4><ul><li><p><a href="https://blog.csdn.net/bluecol/article/details/46242355">https://blog.csdn.net/bluecol/article/details/46242355</a></p></li><li><p>综合了退化函数和信噪统计特性两个方面进行复原处理</p></li><li><p>引入最小二乘约束条件，使得$f(x,y)$与$\hat{f}(x,y)$之间的均方误差最小</p></li><li><p>维纳滤波器寻求能最小化下面的统计误差函数的估计值$\hat{f}$</p><ul><li>$e^{2}=E{(f-\hat{f})^2}$</li><li>其中，$E$为求取数学期望的算子，$f$为没有退化的图像。这个表达式在频域中的解为</li><li><script type="math/tex; mode=display">\hat{F}(u,v)=\left( \frac{1}{H(u,v)}\frac{|H(u,v)|^2}{|H(u,v)|^2+S_{\eta}(u,v)/S_{f}(u,v)} \right)G(u,v)</script></li><li>$|H(u,v)|^2=H^{*}(u,v)H(u,v)$</li><li>$H^{*}(u,v)$为$H(u,v)$的复共轭</li><li>$S_{\eta}(u,v)=|N(u,v)|^2$表示噪声的功率谱</li><li>$S_{f}(u,v)=|F(u,v)|^2$表示未退化图像的功率谱</li></ul></li><li><p>$\frac{|S_{\eta}(u,v)|^{2}}{|S_{f}(u,v)|^{2}}$为噪信功率比</p><ul><li>如果噪声为0，则维纳滤波器退化为逆滤波</li><li>如果噪心功率比未知或不可估计，则<ul><li><script type="math/tex; mode=display">\hat{F}(u,v)=\left( \frac{1}{H(u,v)}\frac{|H(u,v)|^2}{|H(u,v)|^2+K} \right)G(u,v)</script></li></ul></li><li>其中$K$表示一个交互的标量常数</li></ul></li></ul><p><strong>维纳滤波与逆滤波的比较</strong></p><ul><li>逆滤波算法简单，但去模糊能力不强，且忽略噪声影响</li><li>维纳滤波去模糊效果优于逆滤波，且具备去噪功能，但需要知道未退化图像和噪声的功率比</li><li>维纳滤波建立在最小化统计准则的基础上，滤波结果只是平均意义上的最优</li></ul><h4 id="约束最小二乘方滤波"><a href="#约束最小二乘方滤波" class="headerlink" title="约束最小二乘方滤波"></a>约束最小二乘方滤波</h4><ul><li><a href="https://blog.csdn.net/bluecol/article/details/47359421?spm=1001.2014.3001.5502">https://blog.csdn.net/bluecol/article/details/47359421?spm=1001.2014.3001.5502</a></li><li>使用维纳滤波方法存在的困难：必须知道未退化图像和噪声的功率谱</li><li>对功率谱比的恒定估计有时可以取得很好的结果，但并不意味着它总是一种很好的解决方法</li><li>下面将要讨论的约束最小二乘滤波方法只需要知道噪声的均值和方差</li><li>如果用矩阵建模退化过程，有<ul><li>$g(x,y)=h(x,y)*f(x,y)+\eta(x,y)$</li><li>$\mathbf{g} =\mathbf{H} \mathbf{f} +\mathbf{\eta} $</li><li>$\mathbf{H}$是$MN$维方阵，$\mathbf{g},\mathbf{f},\mathbf{\eta}$为$MN$维列向量</li></ul></li><li>该方法的核心是$H$对噪声敏感性问题。缓解这个问题的一种方法是将复原计算建立在一个图像平滑度的度量上</li><li>拉普拉斯算子是个很不错的选择<ul><li><script type="math/tex; mode=display">min\ C=\sum_{X=0}^{M-1}\sum_{y=0}^{N-1}(\bigtriangledown ^2f(x,y))^2</script></li><li>其约束为<script type="math/tex">\left \| \mathbf{g} -\mathbf{H} \mathbf{\hat{f}}  \right \|^2 =\left \| \mathbf{\eta} \right \|^2</script></li><li>拉普拉斯算子$\bigtriangledown ^2$在这里表示平滑程度</li></ul></li><li>该问题在频域中的解为<ul><li><script type="math/tex; mode=display">\hat{F}(u,v)=\left( \frac{H^*(u,v)}{|H(u,v)|^2+\gamma|P(u,v)|^2} \right)G(u,v)</script></li><li>其中$\gamma$是一个参数，$P(u,v)$是拉普拉斯算子$p(x,y)$的傅里叶变换<ul><li><script type="math/tex; mode=display">p(x,y)= \begin{pmatrix}  0& -1 & 0\\  -1& 4 & -1\\  0& -1 &0\end{pmatrix}</script></li></ul></li><li>$\gamma=0$时，简化为逆滤波</li></ul></li><li>迭代计算$\gamma$</li><li>定义残差向量$\mathbf{r}$为$\mathbf{r}=\mathbf{g} -\mathbf{H} \mathbf{\hat{f}}$，并且$\phi (\gamma ) = \mathbf{r} ^{T}\mathbf{r} =\left | \mathbf{r}  \right | ^2$</li><li>可以证明$\phi (\gamma )$是关于$\gamma$单调递增的函数，所以可以通过调整$\gamma$使得<ul><li>$\left | \mathbf{r}  \right | ^2=\left | \eta \right | ^2\pm a$ </li><li>其中，$a$是一个精确度因子(非常小)</li></ul></li><li>如何计算$\left | \eta \right | ^2$<ul><li>$\left | \eta \right | ^2=MN(\sigma_{\eta}^2+m_{\eta}^2)$ （$\left | \eta \right | ^2/MN$噪声随机变量平方的期望）</li><li>$\sigma_{\eta}^2=\frac{1}{MN}\sum_{X=0}^{M-1}\sum_{y=0}^{N-1}( \eta(x,y)-m_{ \eta})^2$ (方差)</li><li>$m_{ \eta}=\sum_{X=0}^{M-1}\sum_{y=0}^{N-1}\eta(x,y)$ （期望）</li></ul></li></ul><h2 id="彩色图像处理"><a href="#彩色图像处理" class="headerlink" title="彩色图像处理"></a>彩色图像处理</h2><h3 id="颜色空间及转换"><a href="#颜色空间及转换" class="headerlink" title="颜色空间及转换"></a>颜色空间及转换</h3><ul><li><p>RGB —&gt; NTSC (彩色图像 —&gt; 灰度图像)</p><script type="math/tex; mode=display">\left[    \begin{array}{c}   Y\\   I\\   Q  \end{array} \right]  \left[    \begin{array}{ccc}    0.299& 0.587 & 0.114\\    0.596&  -0.274& -0.322\\    0.211&  -0.523& 0.312  \end{array} \right]  \left[    \begin{array}{c}  R\\  G\\  B  \end{array} \right]</script><ul><li>Y表示亮度信息，I和Q表示颜色信息</li></ul></li><li><p>NTSC —&gt; RGB</p><script type="math/tex; mode=display">\left[    \begin{array}{c} R\\ G\\ B\end{array} \right]=\left[    \begin{array}{ccc}  1.000& 0.956& 0.621\\  1.000&  -0.272& -0.647\\  1.000&  -1.106& 1.703\end{array} \right]\left[    \begin{array}{c} Y\\ I\\ Q\end{array} \right]</script></li><li><p>RGB —&gt; YCbCr (用于编码数字图像)</p><script type="math/tex; mode=display">\left[    \begin{array}{c} Y\\ Cb\\ Cr\end{array} \right]=\left[    \begin{array}{c} 16\\ 128\\ 128\end{array} \right]\left[    \begin{array}{ccc}  65.481& 128.553 & 24.966\\  -37.797&  -74.203& 112.000\\  112.000&  -93.786& -18.214\end{array} \right]\left[    \begin{array}{c}R\\G\\B\end{array} \right]/256(about)</script><ul><li>Y通道: 表示图像的强度、亮度（luminance）</li><li>Cb通道： 表示图像蓝色 色度（chroma、chrominance）</li><li>Cr通道： 表示图像红色 色度（chroma、chrominance）</li><li>人眼对亮度更加敏感，因此如果保证亮度不变，轻微减少色彩通道的信息，人眼感官上图像质量并不会下降。因此可以通过减少色彩信息的方式来减少存储空间。</li></ul></li><li><p>HSV</p><ul><li>Hue（色调、色相）</li><li>Saturation（饱和度、色彩纯净度）</li><li>Value（强度）</li><li>越靠近中心饱和度越低，白光越多</li><li>角度决定色调</li><li>六边形的大小决定了亮度和强度的大小</li></ul></li><li><p>CMY</p><script type="math/tex; mode=display">\left[    \begin{array}{c} C\\ M\\ Y\end{array} \right]=\left[    \begin{array}{c}  1\\  1\\  1\end{array} \right]-\left[    \begin{array}{c}R\\G\\B\end{array} \right]</script><ul><li>RGB的补空间</li><li>用于彩色打印机</li></ul></li><li><p>HSI</p><ul><li>Hue（色调、色相）</li><li>Saturation（饱和度、色彩纯净度）</li><li>Intensity（颜色的明亮程度）</li><li>HSI是指一个数字图像的模型，它反映了人的视觉系统感知彩色的方式，以色调、饱和度和亮度三种基本特征量来感知颜色。HSI模型的建立基于两个重要的事实：</li><li>第一个，分量与图像的彩色信息无关；</li><li>第二个，H和S分量与人感受颜色的方式是紧密相联的。这些特点使得HSI模型非常适合彩色特性检测与分析。</li></ul></li></ul><h3 id="彩色图像处理-1"><a href="#彩色图像处理-1" class="headerlink" title="彩色图像处理"></a>彩色图像处理</h3><ul><li>令$c$表示RGB彩色空间的一个任意向量<ul><li><script type="math/tex; mode=display">c=\left[    \begin{array}{c} cr\\ cg\\ cb\end{array} \right]=\left[    \begin{array}{c} R\\ G\\ B\end{array} \right]</script></li></ul></li><li>$c$的分量仅是一副彩色图像在一点处的RGB分量<ul><li><script type="math/tex; mode=display">c(x,y)=\begin{bmatrix} cr(x,y)\\ cg(x,y)\\ cb(x,y)\end{bmatrix}=\begin{bmatrix} R(x,y)\\ G(x,y)\\ B(x,y)\end{bmatrix}</script></li></ul></li><li>多通道独立处理<ul><li>$s_i=T_i(r_i),\ i=1,2,…,n$</li><li>对$n$个通道单独处理然后合在一起</li></ul></li><li>伪彩色处理<ul><li>$s_i=T_i(r),\ i=1,2,…,n$</li><li>将灰度图像变为彩色图像</li></ul></li><li>插值映射函数</li></ul><p><strong>彩色图像的空域滤波</strong></p><ol><li>提取各颜色通道</li><li>对图像的各个组成部分分别滤波</li><li>重建</li></ol><p><strong>彩色图像的锐化</strong></p><ul><li><p>采用拉普拉斯滤波器</p><script type="math/tex; mode=display">\bigtriangledown ^2c(x,y)=\begin{bmatrix}  \bigtriangledown ^2R(x,y)\\  \bigtriangledown ^2G(x,y)\\  \bigtriangledown ^2B(x,y) \end{bmatrix}</script></li></ul><p><strong>彩色图像的边缘检测</strong></p><ul><li><p>使用梯度进行彩色边缘检测：</p><ul><li>梯度：<script type="math/tex">\bigtriangledown ^2f=\begin{bmatrix}  G_x\\  G_y\end{bmatrix}=\begin{bmatrix}  \frac{\partial f}{\partial x} \\  \frac{\partial f}{\partial y} \end{bmatrix}</script></li><li>幅值：<script type="math/tex">\left | \bigtriangledown f \right | = mag(\bigtriangledown f)=\sqrt{G_x^{2}+G_y^{2}}=\sqrt{\left ( \frac{\partial f}{\partial x}  \right )^2+ \left ( \frac{\partial f}{\partial y}  \right )^2}</script></li><li><p>幅角：<script type="math/tex">\alpha (x,y)=\arctan\left ( \frac{G_x}{G_y}  \right )</script></p></li><li><p>偏导数的计算(Sobel算子)</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/sobel.png" alt=""></p></li></ul></li><li><p>$r,g,b$是沿着$R,G,B$轴的单位向量，令</p><ul><li><script type="math/tex; mode=display">u=\frac{\partial R}{\partial x} r+\frac{\partial G}{\partial x} g+\frac{\partial B}{\partial x}b</script></li><li><script type="math/tex; mode=display">v=\frac{\partial R}{\partial y} r+\frac{\partial G}{\partial y} g+\frac{\partial B}{\partial y}b</script></li></ul></li><li><p>定义数量</p><ul><li><script type="math/tex; mode=display">g_{xx}=u\cdot u=u^{T}u=\left ( \frac{\partial R}{\partial x}  \right ) ^2+\left ( \frac{\partial G}{\partial x}  \right ) ^2+\left ( \frac{\partial B}{\partial x}  \right ) ^2</script></li><li><script type="math/tex; mode=display">g_{yy} = v\cdot v=v^{T}v=\left ( \frac{\partial R}{\partial y}  \right ) ^2+\left ( \frac{\partial G}{\partial y}  \right ) ^2+\left ( \frac{\partial B}{\partial y}  \right ) ^2</script></li><li><script type="math/tex; mode=display">g_{xy}=u\cdot v=u^{T}v= \frac{\partial R}{\partial x}  \frac{\partial R}{\partial y}  +\frac{\partial G}{\partial x}\frac{\partial G}{\partial y} +\frac{\partial B}{\partial x} \frac{\partial B}{\partial y}</script></li></ul></li><li><p>角度即为$c(x,y)$最大改变率的方向</p><ul><li><script type="math/tex; mode=display">\theta (x,y) = \frac{1}{2}\arctan \left ( \frac{2g_{xy}}{g_{xx}-g_{yy}}  \right )</script></li></ul></li><li><p>对应的变化率的值为</p><ul><li><script type="math/tex; mode=display">F_{\theta}(x,y)=\sqrt{\frac{1}{2}\left ( (g_{xx}+g_{yy})+ (g_{xx}-g_{yy})\cos 2\theta +2g_{x,y}\sin 2\theta \right )  }</script></li></ul></li></ul><p><strong>彩色图像的分割</strong></p><ul><li><p>RGB向量空间中的图像分割</p></li><li><script type="math/tex; mode=display">D(z,m)=\left \| z-m \right \|=\sqrt{(z-m)^{T}(z-m)}=\sqrt{(z_R-m_R)^2+(z_G-m_G)^2+(z_B-m_B)^2}</script><ul><li>欧式距离</li><li>三个坐标轴的量纲一致</li></ul></li><li><p>上面等式的一个有用推广是如下形式的距离度量</p><ul><li><script type="math/tex; mode=display">D(z,m)=\sqrt{(z-m)^{T}C^{-1}(z-m)}</script></li><li>马氏距离</li><li>$C$为样本的协方差矩阵(半正定)</li></ul></li></ul><h2 id="小波和多分辨率处理"><a href="#小波和多分辨率处理" class="headerlink" title="小波和多分辨率处理"></a>小波和多分辨率处理</h2><h3 id="小波变换-wavelet-transform"><a href="#小波变换-wavelet-transform" class="headerlink" title="小波变换 (wavelet transform)"></a>小波变换 (wavelet transform)</h3><p><a href="https://users.rowan.edu/~polikar/WTtutorial.html">https://users.rowan.edu/~polikar/WTtutorial.html</a></p><p><a href="https://www.bilibili.com/video/BV1dv411371B/?spm_id_from=333.788">https://www.bilibili.com/video/BV1dv411371B/?spm_id_from=333.788</a></p><p><strong>傅里叶变换的局限性和短时傅里叶变换 (STFT)</strong></p><ul><li>Decomposes the signal $f(t)$ in infinite number of sine/ cosine waves (harmonics).</li><li>No means of identifying exactly where an event occurs</li><li>Does not cope well with discontinous(不连续), bursts of signals(突变) e.g. video, music etc.</li></ul><p>平稳信号</p><ul><li>Signal with frequency content unchanged in time</li><li>All frequency compontents exits at all the time</li></ul><p>非平稳信号</p><ul><li>Frequency component changes in time</li><li>One example: the “Chirp Singnal”</li></ul><p>短时傅里叶变换 (Short-Time Fourier Transform)</p><ul><li>To analyze only a small section of the signal at a time</li><li><p>A technique called <em>Windowing the signal</em></p></li><li><p>The Segment of signal is assumed stationary</p></li><li><script type="math/tex; mode=display">STFT_{x}^{\omega}({t}' ,\omega)=\int _{t}\left ( x(t)W(t-{t}' ) \right )e^{-j\omega t}dt</script></li></ul><p>短时傅里叶变换的缺点</p><ul><li>unchanged window</li><li>Dilemma of resolution<ul><li>narrow window (good time resolution) —&gt; poor frequency resolution.</li><li>wide window (poor time resolution) —&gt; good frequency resolution.</li></ul></li></ul><p><strong>小波理论</strong></p><ul><li>A Wavelet is a waveform of effectively limited  duration that has an average value of zero. It is defined as<ul><li><script type="math/tex; mode=display">\psi_{a,b}(t)=\frac{1}{\sqrt{a} } \psi\left ( \frac{t-b}{a}  \right )\ a,b \in R</script></li><li>Here $a$ and $b$ are called Dilation (Scale) ane Translation (Position) parameters respectively.</li><li>$a$ 控制小波左右拉伸 (a和频率负相关 )，$b$控制左右移动</li></ul></li></ul><p><strong>连续小波变换 Continuous Wavelet Transform (CWT)</strong></p><ul><li>The continuous Wavelet Transform (CWT) of a signal $f(t)$ is then given by the equation,<ul><li><script type="math/tex; mode=display">CWT(a,b) = \left \langle f,\psi_{a,b} \right \rangle = \frac{1}{\sqrt{a} } \int_{-\infty }^{+\infty } f(t)\psi^{*}\left ( \frac{t-b}{a}  \right )dt</script></li></ul></li><li>The results of the CWT are many wavelet coefficients, which are a function of a (scale) ane $b$ (position).</li></ul><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/连续小波.png" alt=""></p><p><strong>Discrete Wavlet Transform (DWT)</strong></p><ul><li><p>In CWT, claculating wavelet coefficients at every possible scale is a fair amount of work, and it generates an awful lot of data.</p></li><li><p>If scales ($a$) and position ($b$) are chosen to be discrete then analysis will be much easier and will not generate the huge data. </p></li><li><p>This idea of choosing discrete values of dilation ($a$) and translation ($b$) parameters is implemented in,</p><ul><li>Redundant Wavelet Transform (Frames) 冗余小波变换</li><li>Orthonormal bases for wavelets or Multi Resolution Analysis (MRA) 小波正交基/多解析度分析</li></ul></li><li><p><strong>Multi Resolution Analysis (MRA)</strong> — 常用、高效</p><ul><li>If scales and positions are chosen based on powers of two, so-called Dyadic scales and positions, then analysis becomes much more efficient and just as accurate.</li><li>Scaling: $2^{j}\ (j=1,2,3,4,…)$</li><li>Translation: $2^{j}m\ (m=1,2,3,4,…)$</li><li>$j$：离散的分解水平（层数）</li><li><p>DWT：分成两个部分</p><ul><li>approximation coefficients: CA (high scale, low frequency)</li><li>detail coefficients: CD (low scale, high frequency)</li></ul></li><li><p>It was developed in 1988 by S. Mallat. For some very special choice of $\psi (k)$ and $a_0,\ b_0$, the $\psi_{m,n} (k)$ constitute an orthonormal basis for $\mathbb{L}^{2}(\mathbb{R})$</p></li><li>In particular, if $a_0=2,\ b_0=1$, then there exist $\psi(k)$ with good time-frequency localization properties, such that the,<ul><li>$\psi_{m,n}(k)=2^{m/2}\psi (2^{-m}k-n) \ m,n \in \mathbb{z}$, constitutes an orthonormal basis for $\mathbb{L}^{2}(\mathbb{R})$</li></ul></li><li>For a given function $f(k)$, the inner product $\left \langle f,\psi_{m,n} \right \rangle$ then gives the wavelet transform as<ul><li><script type="math/tex; mode=display">DWT(m,n) = \left \langle f,\psi_{m,n} \right \rangle = 2^{\frac{m}{2} }\sum_{k=-\infty }^{\infty} f(k)\psi^{*} (2^{-m}k-n)</script></li></ul></li></ul></li></ul><h3 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h3><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/图像金字塔1.png" alt=""></p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/图像金字塔2.png" alt=""></p><h3 id="子带编码"><a href="#子带编码" class="headerlink" title="子带编码"></a>子带编码</h3><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/子带编码.png" alt=""></p><p><strong>Z变换</strong></p><ul><li>$X(z)=\sum_{-\infty}^{+\infty}x(n)z^{-n}$，其中$z$是一个复变量<ul><li>$Z$变换是离散傅里叶变换的推广形式</li></ul></li><li><p>信号下采样的Z变换</p><ul><li>$x_{down}(n)=x(2n) \Leftrightarrow  X_{down}(z)=\frac{1}{2}(X(z^\frac{1}{2})+X(-z^\frac{1}{2}))$</li></ul></li><li><p>信号上采样的Z变换 (填0处理)</p><ul><li><script type="math/tex; mode=display">x^{up}(n)=\left\{\begin{matrix} x(\frac{n}{2}),\ n=0,2,4,...\\0,otherwise\end{matrix}\right.\Leftrightarrow X^{up}(z)=X(z^{2})</script></li></ul></li><li><p>因此，一个信号经下采样与上采样(填0处理)后对应信号的Z变换为</p><ul><li>$\hat{X}(z)=\frac{1}{2}\left ( X(z) + X(-z) \right )  $</li></ul></li><li>其中 <script type="math/tex">\left\{\begin{matrix}  &\hat{x}(n)=Z^{-1}\hat{X}(z)   \\  &Z^{-1}\hat{X}(-z)=(-1)^{n}\hat{x}(n)  \end{matrix}\right.</script><ul><li>$Z^{-1}$表示$Z$变换的逆变换</li></ul></li></ul><p>一个双子带编码和解码系统表示为</p><script type="math/tex; mode=display">\begin{align}\hat{X}(z) & = \frac{1}{2}G_0(z)\left ( H_0(z)X(z) + H_0(-z)X(-z) \right ) +\frac{1}{2}G_1(z)\left ( H_1(z)X(z) + H_1(-z)X(-z) \right )\\&=\frac{1}{2}X(z)\left ( H_0(z)G_0(z) + H_1(z)G_1(z) \right ) +\frac{1}{2}X(-z)\left ( H_0(-z)G_0(-z) + H_1(-z)G_1(-z) \right )\end{align}</script><ul><li><p>为了对输入进行无失真重建，可施加如下条件：</p><ul><li>$ H_0(-z)G_0(-z) + H_1(-z)G_1(-z)=0$</li><li>$ H_0(z)G_0(z) + H_1(z)G_1(z)=2$</li></ul></li><li><p>将上式合并为一个矩阵表达式</p><ul><li><script type="math/tex; mode=display">\begin{bmatrix} G_0(z)\\ G_1(z)\end{bmatrix}\mathbf{H} _m(z)=\begin{bmatrix}2&0\end{bmatrix}</script></li><li><p>$\mathbf{H} _m(z)$称为分析调制矩阵</p><script type="math/tex; mode=display">\mathbf{H} _m(z)=\begin{bmatrix}H_0(z)&H_0(-z)\\H_1(z)&H_1(-z)\end{bmatrix}</script></li></ul></li><li><p>假定$\mathbf{H} _m(z)$为非奇异矩阵，可得：</p><p><script type="math/tex">\begin{bmatrix} G_0(z)\\ G_1(z)\end{bmatrix}=\frac{2}{\det (\mathbf{H} _m(z))} \begin{bmatrix}H_1(-z)\\-H_0(-z)\end{bmatrix}</script> (克莱姆法则)</p></li></ul><p>完美重建滤波器组(<em>PCFB</em>)的特性 — 交叉调制</p><ul><li><p>由上式可知$G_0(z)$是$H_1(-z)$的函数，$G_1(z)$是$H_0(-z)$的函数。因此分析与综合滤波器是交叉调制的</p></li><li><p>对于有限脉冲响应滤波器(Finite Pulse Response Filter, FIR)，分析调制矩阵$\mathbf{H} _m(z)$的行列式值是一个纯延时</p><ul><li>$\det (\mathbf{H} _m(z))=\alpha z^{-(2k+1)}$</li></ul></li><li><p>若忽略掉对应$z^{-(2k+1)}$的时间延迟，且令$\alpha=2$，对等式两边取$Z$变换的逆变换，可得</p><ul><li>$g_0(n)=(-1)^nh_1(n)$</li><li>$g_1(n)=(-1)^{n+1}h_0(n)$  ($Z^{-1}\hat{X}(-z)=(-1)^{n}\hat{x}(n)$)</li></ul></li><li><p>因此，有限脉冲响应综合滤波器是分析滤波器的交叉调制版本并且有且只有一个与分析滤波器方向相反</p></li></ul><p>完美重建滤波器组(<em>PCFB</em>)的特性 — 双正交性</p><ul><li><p>令$P(z)$表示低通分析滤波器和综合滤波器传递函数的乘积，有</p><script type="math/tex; mode=display">P(z)=G_0(z)H_0(z)=\frac{2}{\det (\mathbf{H} _m(z))}H_0(z)H_1(-z)</script></li><li><p>由于$\color{red} \det (\mathbf{H} _m(z)) = -\det (\mathbf{H} _m(-z))$，乘积$G_1(z)H_1(z)$同样可以被定义为：</p><script type="math/tex; mode=display">G_1(z)H_1(z)=P(-z)=G_0(-z)H_0(-z)</script><ul><li><script type="math/tex; mode=display">\mathbf{H} _m(-z)=\begin{bmatrix}H_0(-z)&H_0(z)\\H_1(-z)&H_1(z)\end{bmatrix}</script></li><li>两列互换行列式的值互为相反数</li></ul></li><li><p>因此$G_1(z)H_1(z)=\frac{2}{\det (\mathbf{H} _m(z))}H_0(z)H_1(-z)=P(-z)$。将其代入$ H_0(z)G_0(z) + H_1(z)G_1(z)=2$可得</p><ul><li><script type="math/tex; mode=display">G_0(z)H_0(z)+G_0(-z)H_0(-z)=2</script></li></ul></li><li><p>对等式$G_0(z)H_0(z)+G_0(-z)H_0(-z)=2$的两边进行反$Z$变换可得</p><ul><li>$\sum_{k}g_0(k)h_0(n-k)+(-1)^{n}\sum_{k}g_0(k)h_0(n-k)=2\delta(n)$</li></ul></li><li><p>由于奇次方项相互抵消 ($n$只能取偶数)，上式可简化为</p><ul><li>$\sum_{k}g_0(k)h_0(2n-k)=\left \langle g_0(k),h_0(2n-k) \right \rangle =\delta(n)$</li></ul></li><li><p>同理可得</p><ul><li>$\left \langle g_1(k),h_1(2n-k) \right \rangle =\delta(n)$</li><li>$\left \langle g_0(k),h_1(2n-k) \right \rangle =0$</li><li>$\left \langle g_1(k),h_0(2n-k) \right \rangle =0$</li></ul></li><li><p>可以得到更具有普遍意义的表达式</p><ul><li>$\left \langle h_i(2n-k), g_j(k) \right \rangle =\delta(i-j)\delta(n)\ i,j = {0,1}$</li></ul></li><li><p>满足下列条件的滤波器组称为具有双正交性：</p><ul><li>$\left \langle h_i(2n-k), g_j(k) \right \rangle =\delta(i-j)\delta(n)\ i,j = {0,1}$</li></ul></li><li><p>所有两频段实系数的完美重建滤波器组的分析和综合滤波器的冲激响应服从双正交约束</p></li><li><p>双正交FIR滤波器的例子包括双正交spline族和双正交coiflet族</p></li><li><p>除了双正交性外，完么重建滤波器组的正交性定义为</p><ul><li>$\left \langle  g_i(n) , g_i(n+2m)\right \rangle =\delta(i-j)\delta(m)\ i,j = {0,1}$</li></ul></li><li><p>可见，$G_1$与低通综合滤波器$G_0$的联系在于调制、时域反转或奇数平移。此外，$H_1$和$H_0$分别是响应综合滤波器$G_0$和$G_1$的时域反转。</p></li><li><p>$Z$变换的另外两个重要性质</p><ul><li>$x(-n)\Leftrightarrow X(z^{-1})$ </li><li>$x(n-k)\Leftrightarrow z^{-k}X(z)$</li></ul></li></ul><p>用于图像的二维子带滤波器</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/二维子带滤波器1.png" alt=""></p><ul><li>图中滤波后的输出结果$a(m,n),d^{V}(m,n),d^{H}(m,n)$和$d^{D}(m,n)$分别称为图像的近似值子带、垂直细节子带、水平细节子带和对角线细节子带。</li><li>一个或多个这样的子带可被进一步分为4个更小的子带，以此类推</li></ul><p>例：Daubechies正交滤波器</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/正交滤波器.png" alt=""></p><h3 id="哈尔变换"><a href="#哈尔变换" class="headerlink" title="哈尔变换"></a>哈尔变换</h3><ul><li><p>哈尔变换的基函数是周所周知的最古老也最简单的正交小波</p></li><li><p>哈尔变换本身具有对称性和可分离性，可以用下述矩阵形式表达</p><ul><li><script type="math/tex; mode=display">\mathbf{T} =\mathbf{HFH}^ {T}</script></li><li>其中，$\mathbf{F}$是一个$N\times N$图像矩阵，$\mathbf{H}$是一个$N\times N$的变换矩阵，$\mathbf{T}$是变换的结果矩阵</li></ul></li><li><p>变换矩阵$\mathbf{H}$包含基函数$h_k(z)$ (对应$\mathbf{H}$中的一行)，它们定义在连续闭区间$z\in [0,1]$上，其中$k=0,…,N-1$且$N=2^{n}$。</p></li><li><p>为了生成矩阵$\mathbf{H}$，定义整数$k=2^{p}+q-1$，$0 \le p \le N-1$且当$p=0$时，$q=0$或$q=1$；当$p \neq 0$时，$1 \le q \le 2^{p}$。则基函数为</p><ul><li><script type="math/tex; mode=display">h_0(z)=h_{00}(z)=\frac{1}{\sqrt{z}},\ z\in [0,1]</script><script type="math/tex; mode=display">h_k(z)=h_{pq}(z)=\frac{1}{\sqrt{N}}\left\{\begin{matrix}2^{p/2},\ (q-1)/2^{p} \le z < (q-0.5)/2^{p} \\-2^{p/2},\ (q-0.5)/2^{p} \le z < (q)/2^{p}\\0,\  其他,\ z \in [0,1]\end{matrix}\right.</script></li><li><p>例：$k=21$，对应二进制 10101，则$p=4, q=6$</p></li><li><p>$k=0$对应$p=0,\ q=0$</p></li><li><p>$k=1$ 对应$p=0,\ q=1$</p></li><li><p>$p$决定了脉冲的宽窄 ($p$越大越窄)，$q$决定了正脉冲的起始位置</p></li></ul></li></ul><h3 id="多分辨率分析"><a href="#多分辨率分析" class="headerlink" title="多分辨率分析"></a>多分辨率分析</h3><ul><li>在多分辨率展开(Multi-resolution analysis, MRA)中，尺度函数被用于建立某一函数或图像的一系列近似值，而被称为小波的函数用于对相邻近似值之间的差异进行编码</li><li>信号或函数$f(x)$常可分解为一系列展开函数的线性组合，即<ul><li>$f(x)=\sum_{k}\alpha_k\varphi_k(x)$</li></ul></li><li>如果这种展开是唯一的，也就是说对任何指定的$f(x)$，只有一个系数序列与之相对应，则$\varphi_k(x)$称为==基函数==，展开序列$\{\varphi_k(x)\}$称为可表示的函数类的基</li><li>可被表示的函数组成了一个函数空间，称为展开集合的闭合跨度，表示为：<ul><li>$V=\overline{Span_k\{\varphi_k(x)\}} $</li></ul></li></ul><p><strong>序列展开</strong></p><ul><li><p>对于任意的函数空间$V$及其相应的展开函数集合$\{\varphi_k(x)\}$，都存在一个对偶函数集$\{\tilde{\varphi}(x) \}$，通过计算其和$f(x)$的积分可得到系数$\{\alpha_k\}$，即</p><ul><li>$\alpha_k=\left \langle \tilde{\varphi}(x),f(x) \right \rangle = \int \tilde{\varphi}^{*}(x)f(x)dx$</li></ul></li><li><p>系数$\{\alpha_k\}$的计算包含了以下情况</p><ul><li><p><strong>情况1</strong>: 如果展开函数构成了$V$的一个正交基，即</p><p>​    <script type="math/tex">\left \langle \varphi_j(x), \varphi_k(x)\right \rangle  = \delta_{jk}=\begin{cases}0,\  j \neq k \\1 ,\ j=k\end{cases}</script></p><p>则基与它的对偶相等，因此</p><p>​    $\alpha_k=\left \langle \varphi(x),f(x) \right \rangle$</p></li><li><p>情况2：如果展开函数本身不正交，但却是$V$的一个正交基，即</p><p>​    <script type="math/tex">\left \langle \varphi_j(x), \varphi_k(x)\right \rangle  =0, j \neq k</script></p><p>​         且基函数与其对偶函数是双正交函数，即</p><p>​    <script type="math/tex">\left \langle \varphi_j(x), \tilde{\varphi}(x)_k(x)\right \rangle  = \delta_{jk}=\begin{cases}0,\  j \neq k \\1 ,\ j=k\end{cases}</script></p><p>那么</p><p>​    $\alpha_k=\left \langle \tilde{\varphi}(x),f(x) \right \rangle$</p></li></ul></li></ul><h2 id="形态学图像处理"><a href="#形态学图像处理" class="headerlink" title="形态学图像处理"></a>形态学图像处理</h2><ul><li><p>基本思想：用具有一定形态的结构元素去度量和提取图像中的对应形状以达到对图像分析和识别的目的</p></li><li><p>形态学图像处理的作用：可以简化图像数据，去除图像中不重要的结构，仅保持图像的基本形状特性</p></li><li>形态学图像处理的基本运算：膨胀、腐蚀、开启、闭合</li><li>二值图像形态学处理的运算对象是集合<ul><li>设A为像素集合，B为结构元素 (本身也是一个像素集合，其成员是感兴趣目标的像素)，其B和A进行操作</li></ul></li><li>B对A的具体操作<ul><li>通过让B在A上平移，以便使B的原点访问A的每一个元素，以此得到一个新的像素集合</li></ul></li><li>结构元素必须指定一个原点<ul><li>结构元素的原点是形态学运算的参考点 (当结构元素对称且未显示原点时，通常假定原点位于对称中心处)</li><li>注意：原点可以包含在结构元素中，也可以不包含在结构元素中 (结构元素原点的位置不同，运算结果也不同)</li></ul></li><li>在实际处理中，只考虑图像和结构元素中有效像素点，即只考虑感兴趣的前景部分，背景部分不予考虑</li></ul><h3 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h3><ul><li>集合B的反射$\hat{B}$定义为$\hat{B}=\{w|w=-b,b \in B\}$，即关于原集合原点对称，即相对于原点旋转180$^{\text o}$</li><li>一个集合B的平移表示为$(B)_{z}$，定义如下<ul><li><script type="math/tex; mode=display">(B)_{z}=\{c|c=b+z, b \in B\}</script></li><li>其中$z=(z_1,z_2)$</li><li>如果$B$是描述图像中物体的像素的集合，则$(B)_{z}$是$B$中坐标值$(x,y)$被$(x+z_1,y+z_2)$替代的像素点的集合</li></ul></li></ul><h3 id="膨胀和腐蚀"><a href="#膨胀和腐蚀" class="headerlink" title="膨胀和腐蚀"></a>膨胀和腐蚀</h3><p><strong>膨胀：使图像扩大</strong></p><ul><li>$A$和$B$是两个集合，$A$被$B$膨胀定义为<ul><li>$A \oplus B=\{z|(\hat{B})_{z}\cap A\neq 0\}$ </li><li>上式表示：$B$的反射进行平移与$A$的交集不为空</li></ul></li><li>膨胀的另一种定义为<ul><li>$A \oplus B=\{z|(\hat{B})_{z}\cap A\subseteq A\}$ </li><li>上式表示：B的反射进行平移与A的交集是A的子集</li></ul></li></ul><p><strong>腐蚀：使图像缩小</strong></p><ul><li>$A$和$B$是两个集合，$A$被$B$腐蚀定义为<ul><li>$A \ominus  B=\{z|(B)_{z} \subseteq A\}$ </li></ul></li><li>使用腐蚀消除图像的细节部分，产生滤波器的作用</li><li>如果两个物体之间有细小的连通，那么当结构元素足够大时，通过腐蚀运算可以将两个物体分开</li></ul><h3 id="开操作和闭操作"><a href="#开操作和闭操作" class="headerlink" title="开操作和闭操作"></a>开操作和闭操作</h3><p><strong>开操作</strong>：使图像的轮廓变得光滑，断开狭窄的间断和消除细的突出物</p><ul><li>定义：设$A$为原始二值图像，$B$是结构元素，则使用结构元素$B$对集合$A$进行开启操作，定义为<ul><li>$A \circ  B=(A \ominus  B) \oplus B$</li><li>先用$B$对$A$腐蚀，然后用$B$对结果膨胀</li></ul></li><li>开操作的几何解释<ul><li>$B$在$A$的边界内转动时，$B$中的点所能到达的$A$的边界的的最远点</li><li>开操作的最终结果：原图像$A$方向向外的角边圆了，而方向向内的角则未受影响</li></ul></li><li>开操作的3条性质<ul><li>$A \circ  B$是$A$的子集合</li><li>如果$C$是$D$的子集，则$C \circ  B$是$D \circ  B$的子集</li><li>$(A \circ  B)\circ  B = A\circ  B$</li></ul></li></ul><p><strong>闭操作</strong>：同样使图像的轮廓变得光滑，但与开操作相反，它能消除狭窄的间断和长细的鸿沟，消除小的孔洞，并填补轮廓线中的裂痕</p><ul><li>使用结构元素$B$对集合$A$进行闭操作，定义为：<ul><li>$A \bullet   B=(A \oplus  B) \ominus B$</li><li>先用B对A膨胀，然后用B对结果腐蚀</li></ul></li><li>闭操作的几何解释<ul><li>B在A的边界外部转动</li><li>闭操作的最终结果：原图像$A$方向向内的角边圆了，而方向向外的角则未受影响</li></ul></li><li>闭操作的3条性质<ul><li>$A$是$A \bullet   B$是的子集合</li><li>如果$C$是$D$的子集，则$C \bullet  B$是$D \bullet  B$的子集</li><li>$(A \bullet  B) \bullet  B = A \bullet  B$</li></ul></li></ul><p><strong>先开操作再闭操作，构成噪声滤波器</strong></p><h3 id="形态学的主要应用"><a href="#形态学的主要应用" class="headerlink" title="形态学的主要应用"></a>形态学的主要应用</h3><p><strong>边界提取</strong>：图像$A$的边界$b(A)$定义为：$b(A)=A-(A \ominus  B)$</p><p><strong>击中与击不中变换</strong>：</p><ul><li><p><a href="https://www.cnblogs.com/a-runner/p/14136520.html">https://www.cnblogs.com/a-runner/p/14136520.html</a></p></li><li><p>作用：在二值图像中找到匹配</p></li><li><p>两个结构元素，记为$E$和$F$，构成结构元素对$B=(E,F)$，$E \cap F = \phi$</p></li><li>分别探测图像的内部和外部，$E$用于探测图像内部,作为击中部分；$F$用于探测图像外部,作为击不中部分，从而确定物体形状<ul><li>$A*B=(A\ominus E)\cap (A^{c}\ominus F)$</li></ul></li></ul><p><strong>孔洞填充</strong>：</p><ul><li>令$A$表示一个集合：其元素是一个8连通的边界，且每个边界包围一个孔洞</li><li>令$X_0$表示一个与$A$相同大小的二维阵列，其初始状态为：<ul><li>包含每个孔洞中的一个指定位置处的前景像素点</li><li>除了上述的前景像素点之外，其余元素均为背景像素点</li></ul></li><li>在给定$A$和$X_0$的前提下，采用前景像素填充$A$的所有孔洞的过程如下：<ul><li>$X_k=(X_{k-1}\oplus B)\cap A^{c}$</li></ul></li><li>在算法执行过程中，如果$X_k=X_{k-1}$，则迭代结束</li><li>集合$X_k$包含所有被填充的孔洞，$X_k$与$A$的并集则包含被填充的孔洞及其边界</li><li>在每一步运算中，膨胀结果与$A^{c}$的交集操作实现了将膨胀结果限制在ROI，即条件膨胀</li></ul><p><strong>连通分量的提取</strong>：</p><ul><li>令$Y$表示一个包含于集合$A$中的连通分量，并假设$Y$中的一个点$p$是已知的。用下列迭代式生成$Y$的所有元素<ul><li>$X_k=(X_{k-1}\oplus B)\cap A$</li></ul></li></ul><p><strong>骨架抽取：</strong></p><ul><li>骨架的概念<ul><li>图像的一种细化结构（图像中物体的骨骼部分），由物体的若干条细化的中轴线组成，描述了图像中物体的<strong>形状</strong>和<strong>方向</strong>信息</li></ul></li><li><p>骨架的作用</p><ul><li>通过骨架抽取可以简化图像中物体的信息而保留其同伦结构</li><li>有助于突出形状特点和减少冗余信息量</li></ul></li><li><p>骨架的定义 (最大内切圆概念)</p><ul><li>物体$A$的骨架由$A$内部所有的最大内切圆盘的圆心组成，骨架的每个点都对应一个相应的最大内切圆盘</li><li>其中，最大内切圆盘不是其他任何完全属于$A$的圆盘的子集，并且至少有两点与集合$A$的边界轮廓相切</li></ul></li><li><p>骨架抽取的实现</p><ul><li><p>对于集合$A$，一般用$S(A)$表示其骨架，可以使用腐蚀和开启操作来实现骨架的抽取，如下：</p><ul><li>$S(A)=\bigcup_{k=0}^{K} S_k(A)$</li><li>$S_k(A)=(A\ominus kB)-((A\ominus kB)\circ B)$</li></ul></li></ul></li><li><p>式中，$B$是一个结构元素，而$(A\ominus kB)$表示对$A$的连续$k$次腐蚀</p><ul><li>$(A\ominus kB)=((…((A\ominus B)\ominus B)\ominus B…)\ominus B)$</li><li>$K$是A被腐蚀为空集前的最后一次迭代步骤，即</li><li>$K=\max\{k|(A\ominus kB) \neq\phi  \}$</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
            <tag> 机器视觉 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
