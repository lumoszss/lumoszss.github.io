<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态规划学习</title>
      <link href="/2022/08/11/dong-tai-gui-hua-xue-xi/"/>
      <url>/2022/08/11/dong-tai-gui-hua-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><strong>动态规划题目特点</strong></p><ol><li>计数<ul><li>有多少种方式走到右下角</li><li>有多少种方法选出k个数使得和是sum</li></ul></li><li>求最大值最小值<ul><li>从左上角走到右下角路径的最大数字和</li><li>最长上升子序列长度</li></ul></li><li>求存在性<ul><li>取石子游戏，先手是否必胜</li><li>能不能选出k个数使得和是sum</li></ul></li></ol><p><strong>动态规划组成部分：</strong></p><ol><li><p>确定状态 f[x]</p><p>解动态规划的时候需要开一个数组，数组的每个f[i]或f[i][j]代表什么</p><ul><li>最后一步</li><li>子问题</li></ul></li><li><p>转移方程</p><ul><li>根据子问题写出转移方程</li></ul></li><li><p>初始条件和边界情况</p><ul><li>初始条件：用转移方程算不出来的，需要手工定义</li><li>边界情况：数组不能越界</li></ul></li><li><p>计算顺序的确定</p><ul><li>从小到大</li><li>从大到小</li></ul></li></ol><h2 id="求最值型动态规划"><a href="#求最值型动态规划" class="headerlink" title="求最值型动态规划"></a>求最值型动态规划</h2><p>leetcode322：给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。</p><p>问题分析：</p><p>​    假设 coins = [2, 3, 5], amount = 27</p><ol><li><p>确定状态 f[x] = 最少用多少枚硬币拼出x</p><ul><li><p>考虑子问题和最后一步</p></li><li><p>假设最优策略为k枚硬币a_1,a_2,…,a_k，所以一定有一枚最后的硬币a_k，前面硬币的总面值为27-a_k</p></li><li><p>因为是最优策略所以拼出27-a_k的硬币数一定最少</p></li><li><p>原问题：最少用多少枚硬币拼出a_k </p></li><li><p>子问题：最少用多少枚硬币拼出27-a_k</p></li><li><p>对于任意的x f[x] = min{f[x-2]+1, f[x-5]+1, f[x-7]+1}</p></li></ul></li><li><p>转移方程 </p><ul><li>f[x] = min{f[x-2]+1, f[x-5]+1, f[x-7]+1}</li></ul></li><li><p>初始条件和边界情况</p><ul><li><p>初始条件：f[0] = 0</p></li><li><p>边界情况：如果不能拼出Y， 定义f[Y] = 正无穷</p></li></ul></li><li><p>计算顺序的确定</p><ul><li><p>初始条件：f[0] = 0</p></li><li><p>计算：f[1], f[2],…, f[27]</p></li><li><p>当计算f[x]时,f[x-2],f[x-5],f[x-7]都已经有结果了</p></li></ul></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> coins<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type coins: List[int]        :type amount: int        :rtype: int        """</span>        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>coins<span class="token punctuation">)</span>  <span class="token comment"># number of kinds of coins</span>        <span class="token comment"># 初始化</span>        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment"># 计算f[1],f[2],...,f[amount]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>             <span class="token comment"># 最后一枚硬币</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> coins<span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token operator">-</span> c <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>                    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span>c<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">if</span> math<span class="token punctuation">.</span>isinf<span class="token punctuation">(</span>f<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">else</span> f<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="求计数型动态规划"><a href="#求计数型动态规划" class="headerlink" title="求计数型动态规划"></a>求计数型动态规划</h2><p>LC62不同路径：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？</p><p>问题分析:</p><ol><li><p>确定状态 f[i][j]为机器人有多少种方式走到[i][j]</p><ul><li>考虑子问题和最后一步<ul><li>最后一步：无论机器人用何种方式到达右下角，总有最后挪动的一步（向右或者向下）</li><li>设右下角坐标为(m-1,n-1)，那么前一步机器人一定在(m-2,n-1)或者(m-1,n-2)</li><li>假设机器人有X种方式从左上角走到(m-2,n-1)，有Y种方式走到(m-1,n-2)，则机器人有X+Y种方式走到(m-1,n-1)</li><li>问题转化为，机器人有 多少种方式从左上角走到(m-2,n-1)和(m-1,n-2)</li></ul></li></ul></li><li><p>转移方程 </p><ul><li>f[i][j] = f[i-1][j] + f[i][j-1]</li></ul></li><li><p>初始条件和边界情况</p><ul><li><p>初始条件：f[0][0]=1</p></li><li><p>边界情况：i=0或j=0，f[i][j] = 1</p></li></ul></li><li><p>计算顺序的确定</p><ul><li>初始条件：f[0][0]=1</li><li>计算第0行：f[0][0]，f[0][1]，…，f[0][n-1]</li><li>计算第1行：f[1][0]，f[1][1]，…，f[1][n-1]</li><li>​        …</li><li>答案是 f[m-1][n-1]</li></ul></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type m: int        :type n: int        :rtype: int        """</span>        <span class="token comment"># 初始化</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment"># 计算每一个dp[i][j]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="求存在型动态规划"><a href="#求存在型动态规划" class="headerlink" title="求存在型动态规划"></a>求存在型动态规划</h2><p><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a>：给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。</p><p>问题分析:</p><ol><li><p>确定状态 f[i]能否到达下标i</p><ul><li>考虑子问题和最后一步<ul><li>最后一步：如果能到达最后一个下标n-1，考虑最后一步</li><li>如果最后一步是从下标i的位置跳过来，需要满足两个条件：<ol><li>可以跳跃到下标i的位置</li><li>最后一步不超过跳跃的最大距离：$n-1-i&lt;=nums[i]$</li></ol></li><li>原问题：能否到达最后一个下标$n-1$</li><li>子问题：能否到达下标$i\ (i&lt;n-1)$</li></ul></li></ul></li><li><p>转移方程 </p><ul><li>$f[j] = OR_{0&lt;=i<j}(f[i]\ and="" \="" i="" +="" nums[i]="">= j)$</j}(f[i]\></li></ul></li><li><p>初始条件和边界情况</p><ul><li>初始条件：f[0] = True</li></ul></li><li><p>计算顺序的确定</p><ul><li>初始条件：f[0] = True</li><li>计算：f[1],f[2],…,f[n-1]</li></ul></li><li>时间复杂度o($N^2$),空间复杂度o($N$)</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canJump</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: bool        """</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">True</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>            <span class="token comment"># previous step</span>            <span class="token comment"># last jump from i to j</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">and</span> i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> j<span class="token punctuation">:</span>                    f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>                    <span class="token keyword">break</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动态规划重点内容"><a href="#动态规划重点内容" class="headerlink" title="动态规划重点内容"></a>动态规划重点内容</h2><h3 id="坐标型动态规划"><a href="#坐标型动态规划" class="headerlink" title="坐标型动态规划"></a>坐标型动态规划</h3><ul><li>给定一个<strong>序列</strong>或<strong>网格</strong>，需要找到某个/些子序列或网格中的某条路径<ul><li>某种性质最大/最小</li><li>计数</li><li>存在性</li></ul></li><li>动态规划方程f[i]中的下标i表示以$a_i$结尾的满足某条件的子序列的性质，f[i][j]中的下标i,j表示以格子(i,j)为结尾的满足条件的路径的性质</li></ul><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II</a>：一个机器人位于一个 m x n 网格的左上角 。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p>问题分析:</p><ol><li>f[i][j] = 机器人有多少种方式走到[i][j]</li><li><p>转移方程 f[i][j] = f[i-1][j] + f[i][j-1]</p></li><li><p>如果左上角(0,0)格或者右下角(m-1,n-1)格有障碍，直接输出0</p></li><li>如果(i,j)格有障碍，f[i][j] = 0，表示机器人不能到达此格（0种方式）</li><li>初始条件：f[0][0] = 1</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">uniquePathsWithObstacles</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> obstacleGrid<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type obstacleGrid: List[List[int]]        :rtype: int        """</span>        m <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>obstacleGrid<span class="token punctuation">)</span>  <span class="token comment"># row</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># column</span>        <span class="token comment"># 如果左上角(0,0)格或者右下角(m-1,n-1)格有障碍，直接输出0</span>        <span class="token keyword">if</span> obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">or</span> obstacleGrid<span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment"># 初始化</span>        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment"># 计算f[i][j]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> j <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 第一行</span>                        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>                    <span class="token keyword">elif</span> i <span class="token operator">!=</span><span class="token number">0</span> <span class="token keyword">and</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 第一列</span>                        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                    <span class="token keyword">elif</span> i<span class="token operator">!=</span><span class="token number">0</span> <span class="token keyword">and</span> j <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a>:给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p>问题分析:</p><ol><li>f[i][j] = 到达[i][j]的最小数字总和是f[i][j]</li><li>转移方程 f[i][j] =min{ f[i-1][j] + grid[i][j], f[i][j-1] + grid[i][j]}</li><li>f[0][0] = grid[0][0]</li><li>f[i][0] = f[i-1][0] + grid[i][0]; f[0][j] = f[0][j-1] + grid[0][j]</li></ol><p>优化：用滚动数组实现（空间优化）— 只需要开两行数组</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>grid <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> grid<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> old <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> now <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>t1<span class="token punctuation">,</span>t2<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            old <span class="token operator">=</span> now<span class="token punctuation">;</span>            now <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> now<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    f<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                f<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    t1 <span class="token operator">=</span> f<span class="token punctuation">[</span>old<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span><span class="token punctuation">{</span>                    t1 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    t2 <span class="token operator">=</span> f<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span><span class="token punctuation">{</span>                    t2 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>t1 <span class="token operator">&lt;</span> t2<span class="token punctuation">)</span><span class="token punctuation">{</span>                    f<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> t1<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                 <span class="token keyword">else</span><span class="token punctuation">{</span>                    f<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> t2<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a>：给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。连续递增的子序列可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p><p> 示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,3,5,4,7]输出：3解释：最长连续递增序列是 [1,3,5], 长度为3。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 问题分析：</p><ol><li><p>确定状态 : f[j] = 以a[j]结尾的最长连续上升子序列长度</p><ul><li>考虑子问题和最后一步</li><li>最后一步：对于最优策略，一定有最后一个元素a[j]<ul><li>第一种情况：最优策略中最长上升子序列就是{a[j]}，答案是1</li><li>第二种情况：子序列长度大于1，那么最优策略中a[j]前一个元素a[j-1]&lt;a[j]</li><li>因为是最优策略，那么a[j-1]结尾的连续上升子序列一定是最长的</li></ul></li><li>要求以a[j-1]结尾的最长连续上升子序列</li></ul></li><li><p>转移方程 </p><ul><li>f[j] = max{1, f[j-1]+1|j&gt;0 and a[j-1]&lt;a[j]}</li></ul></li><li><p>初始条件和边界情况</p><ul><li><p>初始条件：f[0] = 1</p></li><li><p>边界情况：边界情况</p></li></ul></li><li><p>计算顺序的确定</p><ul><li>计算f[0],…,f[n-1]</li><li>答案是max{f[0],…,f[n-1]}</li></ul></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findLengthOfLCIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> result<span class="token punctuation">)</span><span class="token punctuation">{</span>                result <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findLengthOfLCIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp <span class="token operator">=</span>  <span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findLengthOfLCIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        <span class="token comment"># 滑动窗口版本</span>        length <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> length <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> length <span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> length        left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>        max_len <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> right <span class="token operator">&lt;</span> length<span class="token punctuation">:</span>            sub_len <span class="token operator">=</span> <span class="token number">1</span>            <span class="token keyword">while</span> right <span class="token operator">&lt;</span> length <span class="token keyword">and</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>right<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                sub_len <span class="token operator">+=</span> <span class="token number">1</span>                right <span class="token operator">+=</span> <span class="token number">1</span>            max_len <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>max_len<span class="token punctuation">,</span> sub_len<span class="token punctuation">)</span>            left <span class="token operator">=</span> right            right <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> max_len<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="序列型动态规划"><a href="#序列型动态规划" class="headerlink" title="序列型动态规划"></a>序列型动态规划</h3><ul><li>给定一个序列，f[i]中的下标i表示前i个元素a[0],a[1],…,a[i-1]的某种性质。</li><li>初始化中，f[0]，表示空序列的性质</li></ul><p><strong>…前i个…最小/方式数/可行性</strong></p><p><strong>序列 + 状态</strong></p><p>[LeetCode] 256. 粉刷房子：假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。<br> 例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请计算出粉刷完所有房子最少的花费成本。<br> 输入: costs = [[17,2,17],[16,16,5],[14,3,19]] 输出: 10 解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。<br>     最少花费: 2 + 5 + 3 = 10。</p><p> 问题分析：</p><ol><li><p>确定状态 : 设油漆<strong>前i栋</strong>房子并且房子i-1是红色、蓝色、绿色的最小花费分别为f[i][0], f[i][1], f[i][2]</p><ul><li>考虑子问题和最后一步</li><li>最后一步：房子n-1一定染成了红、蓝、绿中的一种，且前一步中刷的房子颜色不能与最后一步相同</li><li>因此需要记录房子颜色</li></ul></li><li><p>转移方程 </p><ul><li>f[i][0] = min{f[i-1][1] + cost[i-1][0], f[i-1][2] + cost[i-1][0] }<ul><li>f[i-1][1] + cost[i-1][0]: 油漆前i-1栋房子并且房子i-2是蓝色的最小花费 + 油漆房子i-1的花费</li></ul></li><li>f[i][1] = min{f[i-1][0] + cost[i-1][1], f[i-1][2] + cost[i-1][1]}</li><li>f[i][2] = min{f[i-1][0] + cost[i-1][2], f[i-1][1] + cost[i-1][2]}</li></ul></li><li><p>初始条件和边界情况</p><ul><li><p>初始条件：f[0][0] = f[0][1] = f[0][2] = 0 即不油漆任何房子的花费</p></li><li><p>边界情况：无边界情况</p></li></ul></li><li><p>计算顺序的确定</p><ul><li>初始化：f[0][0] = f[0][1] = f[0][2] = 0</li><li>计算：f[1][0]，f[1][1]，f[1][2]</li><li>计算：f[2][0]，f[2][1]，f[2][2]</li><li>​        …</li><li>计算：f[n][0]，f[n][1]，f[n][2]</li><li>答案: min{f[n][0]，f[n][1]，f[n][2]}</li></ul></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minCost</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> costs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type costs: List[List[int]]        :rtype: int        """</span>        <span class="token comment"># 初始化</span>        house_num <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>costs<span class="token punctuation">)</span>        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>house_num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>house_num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token builtin">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>house_num<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>house_num<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>house_num<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设有K种颜色</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//如果最小值是第i个元素，次小值是第j个元素</span><span class="token comment">//1. 只要除掉的元素不是第i个，剩下的最小值就是第i个元素</span><span class="token comment">//2. 如果除掉的元素是第i个，剩下的最小值就是第j个元素</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minCost</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> costs<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>costs <span class="token operator">==</span> <span class="token keyword">null</span><span class="token operator">||</span>costs<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">int</span> n <span class="token operator">=</span> costs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// house number</span>     <span class="token keyword">int</span> <span class="token class-name">K</span> <span class="token operator">=</span> costs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// paint number</span>     <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">K</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>     <span class="token keyword">int</span> min1<span class="token punctuation">,</span>min2<span class="token punctuation">,</span>j1<span class="token punctuation">,</span>j2<span class="token punctuation">;</span> <span class="token comment">// min1最小值，min2次小值,j1最小值下标，j2次小值下标</span>     j1 <span class="token operator">=</span> j2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token class-name">K</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment">// 计算每一个f[i][j]</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         min1 <span class="token operator">=</span> min2 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token comment">//求最小值和次小值</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>min1<span class="token punctuation">)</span><span class="token punctuation">{</span>                 min2 <span class="token operator">=</span> min1<span class="token punctuation">;</span>                 j2 <span class="token operator">=</span> j1<span class="token punctuation">;</span>                 min1 <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                 j1 <span class="token operator">=</span> j<span class="token punctuation">;</span>             <span class="token punctuation">}</span>             <span class="token keyword">else</span><span class="token punctuation">{</span>                 <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min2<span class="token punctuation">)</span><span class="token punctuation">{</span>                     min2 <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                     j2 <span class="token operator">=</span> j<span class="token punctuation">;</span>                 <span class="token punctuation">}</span>             <span class="token punctuation">}</span>         <span class="token punctuation">}</span>         <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">!=</span> j1<span class="token punctuation">)</span><span class="token punctuation">{</span>         f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j1<span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">else</span><span class="token punctuation">{</span>         f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j2<span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> res<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a>：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</strong>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。<br>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。&nbsp;    偷窃到的最高金额 = 1 + 3 = 4 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token operator">==</span><span class="token keyword">null</span> <span class="token operator">||</span> nums<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// the number of house</span>        <span class="token comment">// 初始化</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">// 计算每一个f[i][j]</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">// 第i-1间偷了，第i-2间一定没偷</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 第i-1间没偷，第i-2间可能没偷也可能偷了</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>序列 + 位操作型动态规划</p><ul><li>&amp;与，|或，^异或，！非</li></ul><p><a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a>:给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。<br>示例 1：<br></p><pre class="line-numbers language-none"><code class="language-none">输入：n = 2输出：[0,1,1]解释：0 --&gt; 01 --&gt; 12 --&gt; 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><ul><li>二进制表示算法：<ul><li>第一步：i mod 2 是最低位的bit</li><li>第二步：i /2，如果i=0结束，否则回到第一步</li></ul></li><li><p>和位操作有关的，一般用值做状态</p><p>问题分析：</p></li></ul><ol><li><p>确定状态 :  f[i] = i的二进制表示中有多少个1</p><ul><li>考虑子问题和最后一步</li><li>要求N的二进制中有多少1</li><li>在N的二进制去掉最后一位N mod 2，设新的数是Y = (X&gt;&gt;1)（右移一位）</li><li>子问题：要知道Y的二进制表示中有多少1</li></ul></li><li><p>转移方程 </p><ul><li>f[i] = f[i&gt;&gt;1] + i mod 2</li></ul></li><li><p>初始条件和边界情况</p><ul><li><p>初始条件：f[0]=1</p></li><li><p>边界情况：如果i=1只看最后一个数字</p></li></ul></li><li><p>计算顺序的确定</p><ul><li>初始化：f[0]=0</li><li>计算：f[1], f[2], …, f[N]</li></ul></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">countBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 初始化</span>        f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">&gt;&gt;</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> f<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="划分型动态规划"><a href="#划分型动态规划" class="headerlink" title="划分型动态规划"></a>划分型动态规划</h3><p><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a>：<br>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><pre class="line-numbers language-none"><code class="language-none">'A' -&gt; 1'B' -&gt; 2...'Z' -&gt; 26<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>"11106"</code> 可以映射为：</p><ul><li><code>"AAJF"</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>"KJF"</code> ，将消息分组为 <code>(11 10 6)</code></li></ul><p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>"06"</code> 不能映射为 <code>"F"</code> ，这是由于 <code>"6"</code> 和 <code>"06"</code> 在映射中并不等价。</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p><p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p><p><strong>示例 ：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：s = "226"输出：3解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 问题分析：</p><ol><li><p>确定状态 :  设数字串S<strong>前i个</strong>数字解密成字母串有f[i]种方式</p><ul><li>考虑子问题和最后一步</li><li>最后一步：一定有最后一个字母 A, B,…, Z，这个字母加密时变成1,2,…,26</li><li>设数字串长度为N，要求数字串前N 个数字的解密方式数，需要知道数字串前N-1和N-2个字符的解密方式数</li></ul></li><li><p>转移方程 </p><ul><li>f[i] = f[i-1]|S[i-1]对应一个字母(非0) + f[i-2]|S[i-2]S[i-1]对应一个字母</li></ul></li><li><p>初始条件和边界情况</p><ul><li><p>初始条件：f[0]=1</p></li><li><p>边界情况：如果i=1只看最后一个数字</p></li></ul></li><li><p>计算顺序的确定</p><ul><li>初始化：f[0]=1</li><li>计算：f[1], f[2], …, f[N]</li></ul></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numDecodings</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s <span class="token operator">=</span> ss<span class="token punctuation">.</span><span class="token function">toCharArrary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 初始化</span>        f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> t <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">&gt;=</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> t<span class="token operator">&lt;=</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&gt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                t <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">&gt;=</span><span class="token number">10</span> <span class="token operator">&amp;&amp;</span> t<span class="token operator">&lt;=</span><span class="token number">26</span><span class="token punctuation">)</span>                    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numDecodings</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        length <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">if</span> length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> length <span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">if</span> <span class="token builtin">int</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            num <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span> <span class="token operator">+</span> <span class="token builtin">int</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> num <span class="token operator">&gt;=</span><span class="token number">10</span> <span class="token keyword">and</span> num <span class="token operator">&lt;=</span><span class="token number">26</span><span class="token punctuation">:</span>                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理学习笔记</title>
      <link href="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/"/>
      <url>/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="数字图像处理"><a href="#数字图像处理" class="headerlink" title="数字图像处理"></a>数字图像处理</h1><p><strong>图像</strong></p><p>二维图像<code>f(x,y)</code></p><ul><li><code>x,y</code>: 空间坐标</li><li><code>(x,y)</code>上的负值<code>f</code>：该点图像的强度或者灰值</li></ul><p><strong>数字图像</strong></p><ul><li><code>x,y</code>和幅值<code>f(x,y)</code>为有限的离散数值</li><li>像素pixel是数字图像的基本元素</li></ul><p><strong>图像的采样&amp;量化</strong></p><ul><li>取样 (Sampling)</li><li>量化 (Quantization，模数转换)</li></ul><p>图像的数字化过程</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/图像数字化.jpg" style="zoom:50%;"></p><ul><li>采样间隔越大，所得图像像素数越少，图像空间分辨率低，质量差</li><li>采样间隔越小，所得图像像素数越多，图像空间分辨率高，质量好，但数据量大</li><li>量化等级越多，所得图像层次越丰富，灰度分辨率越高，质量越好，但数据量大；</li><li>量化等级越少，图像层次欠丰富，灰度分辨率低，质量变差，会出现假轮廓现象，但数据量小。</li></ul><p><strong>邻域关系</strong></p><ul><li><p>4邻域、D邻域、8邻域</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/邻域关系.png" style="zoom:23%;"></p></li></ul><p><strong>邻接性</strong></p><ul><li><p>4 邻接、8邻接、m邻接</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/邻接关系.png" alt=""></p></li></ul><p><strong>m邻接实质</strong>：当像素间同时存在4 邻接和 8 邻接时，优先采用 4 邻接屏蔽两个和同一像素间存在4 邻接的像素之间的 8 邻接</p><p><strong>连通性</strong></p><ul><li><p>从具有坐标(x,y)的像素p到具有坐标(s,t)的像素q的通路（或曲线）是特定的像素序列，其坐标为</p></li><li><p>$(x_0,y_0),(x_1,y_1),…,(x_n,y_n)$</p></li><li>其中$(x_0,y_0)=(x,y)$并且像素$(x_i,y_i)$和$(x_{i-1},y_{i-1})$(对于$1 \leq i \leq n$)是邻接的。在这种情况下，n是通路的长度。如果$(x_0,y_0)=(x_n,y_n)$，则通路是闭合通路。</li></ul><p>如果要从像素s 到像素 t</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/连通性.png" style="zoom:25%;"></p><ul><li>在 4 连通 的条件下：s 不能到 t</li><li>在8 连通 的条件下：s 可以到 t</li><li>在 m 连通 的条件下：s 可以到 t</li></ul><p><strong>区域和边界</strong></p><ul><li>区域的定义是建立在连通集的基础上的，令R 是图像中的像素子集</li><li>如果 R 是连通集，则称 R 为一个区域</li><li>如果一个点的 8 邻域都是 1 ，则可以认为这个点是内部的点 而不是边界上的点，可以删除这类点，剩下的就是边界上的点</li><li>根据腐蚀的特性，使用 3*3 的结构元素对图像进行腐蚀，可以得到内部的点，那么再用原图减去腐蚀图 ，就得到了图像的边界</li></ul><p><strong>像素之间的距离</strong></p><ul><li><p>欧式距离：$D_e(p,q) = \sqrt{(x-s)^{2}+(y-t)^{2}}$</p></li><li><p>城市街区距离</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/城市街区距离.jpg" alt=""></p></li><li><p>棋盘距离</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/棋盘距离.jpg" alt=""></p><ul><li>围着 P 点的所有元素都是相邻的，它下一步可以走到包围它的八个点的任何一个，也就是横竖和斜向。</li><li>对于可以横竖和斜向走的最短距离，就是横向或竖向的距离的最大值。</li><li>实质上是凑成一个正方形的对角线</li></ul></li></ul><h2 id="图像变换与矫正"><a href="#图像变换与矫正" class="headerlink" title="图像变换与矫正"></a>图像变换与矫正</h2><ul><li><p>由于多种因素的影响，应用中实际获得的画面可能会与想象中有所差异，因此需要进行调整、把画面复原。</p></li><li><p>图像的变换与校正是指用数学建模方法来描述图像位置、大小、形状等已知条件，利用这些条件进行确定模型参数，根据模型对图像进行几何校正。</p></li></ul><h3 id="图像的平移、旋转和缩放"><a href="#图像的平移、旋转和缩放" class="headerlink" title="图像的平移、旋转和缩放"></a>图像的平移、旋转和缩放</h3><p><strong>平移</strong></p><p>齐次坐标 (<strong>Homogenous Coordinate</strong>)</p><p>点$p_{0}(x_{0},y_{0})$平移至$p_{t}(x_{0}+T_{x},y_{0}+T_{y})$</p><script type="math/tex; mode=display">\begin{cases}x_{1} = x_{0}+T_{x}\\y_{1} = y_{0}+T_{y}\end{cases}</script><script type="math/tex; mode=display">\begin{bmatrix} x_{1}\\ y_{1}\\ 1\end{bmatrix}=\begin{bmatrix}  1 & 0 & T_{x}\\  0 & 1 & T_{y}\\  0 & 0 & 1\end{bmatrix}\begin{bmatrix}x_{0}\\y_{0}\\1\end{bmatrix}</script><p>记为如下的形式：</p><script type="math/tex; mode=display">p_{t} = T \cdot p_0 = \begin{bmatrix}1 & 0 & x_{t}\\0 & 1 & y_{t}\\ 0 & 0 & 1\end{bmatrix} \cdot p_0</script><p><strong>旋转</strong></p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/旋转.png" style="zoom: 50%;"></p><ul><li><p>$x_0 = r \cos \alpha$</p></li><li><p>$y_0 = r \sin \alpha$</p></li><li>$x = r\cos(\alpha - \gamma) = r\cos{\alpha}\cos{\gamma}+r\sin{\alpha}\sin{\gamma} = x_0\cos{\gamma} + y_0\sin{\gamma}$</li><li>$y = r\sin(\alpha - \gamma) = r\sin{\alpha}\cos{\gamma}-r\cos{\alpha}\sin{\gamma} = y_0\cos{\gamma} - x_0\sin{\gamma}$</li></ul><script type="math/tex; mode=display">p_{r} = R \cdot p_0 = \begin{bmatrix} \cos{\gamma}  & -\sin{\gamma} & 0\\ \sin{\gamma} & \cos{\gamma} & 0\\ 0 & 0 & 1\end{bmatrix} \cdot p_0</script><p><strong>缩放</strong></p><p>缩放前后两点$A_0(x_0, y_0)$和$A_1(x_1, y_1)$之间的关系</p><script type="math/tex; mode=display">\begin{cases}x_1 = \alpha x_{0}\\y_1 = \alpha y_{0}\end{cases}</script><p>用矩阵形式可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix} x_{1}\\ y_{1}\\ 1\end{bmatrix}=\begin{bmatrix}  \alpha & 0 & 0\\  0 & \alpha & 0\\  0 & 0 & 1\end{bmatrix}\begin{bmatrix}x_{0}\\y_{0}\\1\end{bmatrix}</script><script type="math/tex; mode=display">p_{s} = S \cdot p_0 = \begin{bmatrix} S_{x} & 0 & 0\\0 & S_{y} & 0\\ 0 & 0 & 1\end{bmatrix} \cdot p_0</script><h3 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h3><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/几何变换.jpg" alt=""></p><p><strong>相似变换 (Similarity Transformation)</strong></p><p>相似变换：由一个平面立体图形变换到另一个平面立体图形，在改变的过程中<strong>保持形状不变(大小方向和位置可变)</strong>，任何相似变换都可以分解为<strong>等比例缩放</strong>、 <strong>平移</strong> 、 <strong>旋转</strong>的组合</p><script type="math/tex; mode=display">\begin{bmatrix}  1 & 0 & T_{x}\\  0 & 1 & T_{y}\\  0 & 0 & 1\end{bmatrix}\begin{bmatrix} \cos{\gamma}  & -\sin{\gamma} & 0\\ \sin{\gamma} & \cos{\gamma} & 0\\ 0 & 0 & 1\end{bmatrix}\begin{bmatrix} S & 0 & 0\\0 & S & 0\\ 0 & 0 & 1\end{bmatrix}</script><p>可记为</p><script type="math/tex; mode=display">\begin{bmatrix}      sR& T\\   0 & 1\\\end{bmatrix}</script><p><strong>仿射变换 (Affine Transformation)</strong></p><p>仿射变换：由一个平面立体图形变换到另一个平面立体图形，在改变的过程中<strong>保持直线和平行线不变</strong> (平行线映射为平行线），任何仿射变换都可以分解为<strong>缩放</strong> 、 <strong>平移</strong> 、 <strong>旋转</strong>和<strong>切变 (Shearing)</strong>的组合</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/仿射变换.jpg" style="zoom:80%;"></p><p>仿射变换允许图形任意倾斜，而且允许图形在两个方向上任意伸缩变换</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/Affine Transformation1.jpg" alt=""></p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/Affine Transformation2.jpg" alt=""></p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/Affine Transformation3.jpg" alt=""></p><p><strong>投影变换 (Projective Transformation)</strong></p><p>又称为单应性变换</p><p>投影变换 ：把空间三维立体投射到投影面上得到二维平面图形的过程。</p><ul><li>中心投影（透视投影）图</li></ul><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/投影变换.jpg" style="zoom: 67%;"></p><p>单应性不严谨定义：用无镜头畸变的相机从不同位置拍摄同一平面物体的图像之间存在单应性，可以用投影变换表示。</p><ul><li><p>单应性变换 (投影变换)：不同视角的同一物体，在像素坐标系中的变换。</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/单应性.jpg" style="zoom:33%;"></p></li></ul><script type="math/tex; mode=display">H_{3 \times 3} = \begin{bmatrix}   A_{2 \times 2}& T_{2 \times 1}\\   V^{T} & s\\\end{bmatrix} = \begin{bmatrix}   a_{11} & a_{12} & t_x\\ a_{21} & a_{22} & t_y \\   v_{1} & v_{2} & s\\\end{bmatrix}</script><ul><li><p>其中$A_{2 \times 2}$代表仿射变换的参数，$T_{2 \times 1}$代表了平移变换的参数</p></li><li><p>$V^{T} = [v_1,v_2]$表示一种“变换后边缘交点”关系</p></li><li><p>$s$是一个与$V^{T} = [v_1,v_2]$相关的缩放因子</p><script type="math/tex; mode=display">\begin{bmatrix}  1 & 0 & 0\\  0 & 1 & 0\\  v_{1} & v_{2} & s\end{bmatrix}\begin{bmatrix}x\\y\\1\end{bmatrix} =\begin{bmatrix} x\\ y\\ v_{1}x+v_{2}y+s\end{bmatrix} \Rightarrow \begin{bmatrix} \frac{x}{v_{1}x+v_{2}y+s}\\ \frac{y}{v_{1}x+v_{2}y+s}\\\end{bmatrix}</script></li><li><p>单应性矩阵$H$虽然有9个未知数，但是只有8个自由度</p><ul><li>单应性矩阵$H$与$aH$完全相同</li><li>令 $a = 1/s$</li></ul></li><li><p>仿射变换是投影变换的特例</p></li><li><p>单应性在计算机视觉领域是一个非常重要的概念，它在 图像校正、图像拼接、相机位姿估计、视觉 SLAM 等领域有非常重要的作用。</p></li></ul><h2 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h2><p>增强的主要目的是对图像进行处理，使结果图像比原始图像更适用于某一<strong>特定</strong>应用。<strong>特定</strong>意味着技术是非常面向问题的</p><p>图像增强方法可以分为两大类：<strong>空域方法</strong>和<strong>频域方法</strong></p><ul><li>空域方法是基于图像中的像素直接进行局部处理</li><li>频域方法是基于图像的傅立叶变换进行处理</li></ul><h3 id="空域方法"><a href="#空域方法" class="headerlink" title="空域方法"></a>空域方法</h3><p>空间域处理的数学表示：</p><ul><li>$g(x,y) = T[f(x,y)]$<ul><li>$f(x,y)$：输入图像</li><li>$g(x,y)$: 输出图像</li><li>$T$: 在$f(x,y)$上的操作，定义在$(x,y)$的某个邻域上</li></ul></li><li>$T$可以在一组图像上进行操作，例如噪声消除</li><li>方形和矩形邻域是使用最多的，因为它们易于实现，也可使用圆形区域</li></ul><h4 id="灰度变换-亮度变换"><a href="#灰度变换-亮度变换" class="headerlink" title="灰度变换 (亮度变换)"></a>灰度变换 (亮度变换)</h4><ul><li>$T$最简单的情况是邻域大小为$1 \times 1$，此时$g$只依赖于$f$在$(x,y)$处的值，即</li><li>$s=T(r)$</li><li>称之为灰度变换或者亮度变换，其中s和r分别为输出与输入的亮度值</li></ul><ol><li>幂律变换$s=cr^{\gamma}$，其中$c$和$\gamma$为正常数（伽马矫正，对比度增强）</li><li>分段线性函数（对比度增强，灰度级分层）</li><li><p>比特位面图像</p><ul><li>突出特定位对图像总外观的贡献</li><li>图像中的每个像素由8位二进制数(灰度分为256阶：0-255)表示</li><li>图像由8个1位平面(二值图像)组成，最小有效位平面为0位平面，最大有效位平面为7位平面</li></ul></li><li><p>对数变换$s=clog(1+r)$</p><ul><li>其中$c$是常数</li><li>该变换的形状类似于$\gamma$曲线</li><li>$\gamma$曲线的形状是可变的，而对数函数的形状是固定的</li><li>$(1+r)$ —&gt; $r=0,s=0$</li><li>对数变换的主要用途之一是压缩动态范围</li></ul></li><li><p>对比拉伸变换</p><ul><li>$s=T(r)=\frac{1}{1+(m/r)^E}$</li><li>将小于$m$的输入值压缩到输出图像中较窄的暗区范围内</li><li>类似的，将$m$以上的值压缩成输出中的窄带亮区</li><li>其中$r$为输入图像的强度，$s$为输出图像中对应的强度值，$E$控制函数的斜率，$m$为参数</li><li>$E$越大，函数图像的倾斜度越高</li></ul></li></ol><p><strong>直方图处理</strong></p><ul><li><p>亮度变换通常是基于从图像亮度直方图中提取的信息进行的，直方图在很多图像处理方面（图像增强、压缩、分割和描述）都起到基础作用</p></li><li><p>一副亮度取值在$[0,G]$范围内的数字图像，将它量化为$L$个亮度级别的直方图，可以定义为一个离散函数</p><ul><li>$h(r_k)=n_k$</li><li>其中$r_k$为区间$[0,G]$中第$k$个强度级别，$n_k$为图像中强度级别为$r_k$的像素数目。</li><li>uint8类图像的$G$值为255，unit16类图像的$G$值是65535，double类图像的$G$值为1.0</li></ul></li><li><p>一副图像的直方图$h(r_k)$可以表示为一个向量，将其所有分量处以该图像的像素总数，可以得到归一化直方图</p><ul><li>$p(r_k)=\frac{h(r_k)}{N}=\frac{n_k}{N}, N=\sum_{k=1}^{L}n_k$</li><li>$p(r_k)$可看作为在一副图像中强度级$r_k$发生概率的估计值</li></ul></li><li><p>matlab中的图像直方图函数</p><ul><li><code>h=imhist(f,b)</code></li><li>f为输入图像，h为输入图像的直方图，b为生成直方图所用量化级别的数目</li></ul></li></ul><p><strong>直方图均衡</strong></p><ul><li>目的：改善图像对比度</li><li>结果：均衡后的图像具有几乎均匀的像素值分布（服从均匀分布）</li><li>优点：无参数的算法</li></ul><p>寻找变换函数</p><ul><li>假设$r$被归一化为区间$[0,1]$，$r=0$表示黑色，$r=1$表示白色<ul><li>$s=T(r), 0 \le r \le 1$</li></ul></li><li>转换函数$T$要求满足下列条件：<ul><li>$T(r)$在区间$[0,1]$上是单值($r_1 \ne r_2, s_1\ne s_2$)的且单调递增</li><li>对于$0 \le r \le 1$，$0 \le T(r) \le 1$</li></ul></li><li>直方图均衡化是基于一个随机变量的概率密度函数的变换</li><li>令$p_s(s)$和$p_r(r)$分别为随机变量$s$和$r$的概率密度函数 (归一化直方图函数)</li><li><p>如果$p_r(r)$和$T(r)$是已知的，则可得到变换后的变量$s$的概率密度函数$p_s(s)$通过下面的计算得到</p><ul><li>$p_s(s)=p_r(r)|dr/ds|$</li><li>分析<ul><li>对于连续型随机变量$X$的概率密度函数$f(x)$</li><li>$p\{X=x\}=f(x)dx$</li><li>$p_s(s)$和$p_r(r)$是一一映射的关系，每一点出现的概率均相等</li><li>所以$p_s(s)ds=p_r(r)dr$</li></ul></li></ul></li><li><p>定义一个转换函数</p><ul><li>$s=T(r)=\int_{0}^{r}p_r(\omega) d\omega$</li><li>其中$\omega$是积分的虚变量，方程的右边可看作随机变量的累积分布函数</li><li>分析<ul><li>$s=T(r)=\int_{0}^{r}p_r(\omega) d\omega$</li><li>$\frac{ds}{dr}= \frac{dT(r)}{dr}= \frac{d[\int_{0}^{r}p_r(\omega) d\omega]}{dr}= p_r(r)$</li><li>$p_s(s)=p_r(r)|\frac{dr}{ds}|= p_r(r)|\frac{1}{p_r(r)}|=1,0\le s\le1$</li></ul></li><li>由分析可知，在给定的映射变换下，输出随机变量$s$服从均匀分布</li><li>$T(r)$虽然依赖于$p_r(r)$，但是得到的$p_s(s)$总是均匀的</li></ul></li><li>对于离散的情况，图像中亮度级$r_k$出现的概率为<ul><li>$p_k(r_k)=n_k/n, k = 0,1,2,…,L-1$</li><li>其中$n_k$为输入图像中$r_k$级的像素数目，$n$为图像中总的像素数目</li></ul></li><li>此时，变换函数为<ul><li>$s_k=T(r_k)=\sum_{j=0}^{k}p_r(r_j)=\sum_{j=0}^{k}n_j/n$</li><li>利用该映射，可将输入图像$r_k$级的每个像素映射到$s_k$级对应的像素，从而得到均衡后输出图像</li></ul></li><li>直方图均衡化是通过Matlab中的函数<code>g=histeq(f,nlev)</code>实现<ul><li>其中f为输入图像，g为均衡后的输出图像，nelv为输出图像指定的亮度级别数</li></ul></li></ul><p><strong>直方图均衡算法</strong></p><ul><li>对输入图像计算其直方图，并计算归一化直方图</li><li>利用累积映射计算输入图像中每个灰度级$r_k$对应的输出图像的灰度级$s_k$<ul><li>$s_k=T(r_k)=\sum_{j=0}^{k}n_j/n, k = 0,1,2,…,L-1$</li></ul></li><li>这时$s_k$为区间$[0,1]$的浮点数，可以通过$m_k=[s_k\times (L-1)]$将$s_k$转化为一个整数的灰度级别，其中符号<code>[]</code>代表某种取整操作</li><li>取整运算可能会导致多个输入灰度级对应同一个灰度级的输出，即$m_p=m_{p+1}=…=m_k=…=m_q$这时输出图线的灰度级$m_k$对应的归一化直方图中的概率值为对应的多个输入灰度级的概率值之和</li></ul><p><strong>直方图匹配</strong></p><ul><li>直方图匹配类似于直方图均衡化，只不过希望输出图像的直方图具有指定的形状</li><li>考虑标准化到区间$[0,1]$的连续亮度级，令$r$和$z$分别表示输入和输出图像的亮度级。输入图像的亮度分布服从概率密度函数$p_r(r)$，输出图像的亮度分布服从指定的概率密度函数$p_z(z)$</li><li>首先由$s=T(r)=\int_{0}^{r}p_r(\omega) d\omega$可以得到理想的均衡化直方图$p_s(s)$</li><li>假设变量$z$具有如下属性$H(z)=\int_{0}^{z}p_z(\omega) d\omega=s$</li><li>由上面两个等式可以推出$z=H^{-1}(s)=H^{-1}(T(r))$</li><li>从输入图像可以找到$T(r)$，只要找到$H^{-1}$，就可以得到变换后的亮度值z,它具有指定的概率密度函数$p_z(z)$</li></ul><h4 id="空域滤波技术"><a href="#空域滤波技术" class="headerlink" title="空域滤波技术"></a>空域滤波技术</h4><ul><li>$g(x,y)$在$(x,y)$处的输出值与$f(x,y)$在$(x,y)$处邻域内的像素有关，相关技术称为空域滤波器技术</li><li>在空域滤波中，输出图像中的每个输出像素值直接通过对输入图像同位置以及周围邻域内像素的简单计算得到的</li><li>空间滤波可以是线性的，也可以是非线性的</li><li>线性滤波应用更为广泛，主要通过卷积运算来实现</li></ul><p><strong>线性空域滤波</strong></p><ul><li><p>一般来说，一副大小为$M \times N$的图像被一个尺寸为$m \times n$的滤波器滤波可以通过下面的计算来获得</p><ul><li>$g(x,y)=\sum_{s=-a}^{a}\sum_{t=-b}^{b}\omega(s,t)f(x+s,y+t)$</li><li>其中，$a=(m-1)/2, b=(n-1)/2$</li><li>这个概念叫卷积（其实是相关）。滤波器掩码有时被称为卷积掩码或卷积核(<strong>destination pixel</strong>)</li><li>卷积操作需要先旋转180度$f(x,y) \rightarrow f(-x,-y)$</li></ul></li><li><p>相关与卷积</p><ul><li>相关：$(f\ast g)(t)=\int_{-\infty}^{+\infty}f^{\ast}(\tau)g(t+\tau)d\tau$,  $f^{\ast}(t)$表示 $f(t)$的共轭</li><li>卷积：$(f*g)(t)=\int_{-\infty}^{+\infty}f(\tau)g(t-\tau)d\tau$</li><li>相关：$(f\ast g)[n]=\sum_{m=-\infty}^{+\infty}f^{\ast} [m]g[n+m]$</li><li>卷积：$(f*g)[n]=\sum_{m=-\infty}^{+\infty}f[m]g[n-m]$</li></ul></li><li><p>卷积</p><ul><li><p>卷积相关运算是“动态”的点积运算，度量信号与参考信号或者模板的相似度</p></li><li><p>卷积的运算过程：置换变量 —&gt; 反转 —&gt; 平移 —&gt; 相乘 —&gt; 积分</p></li><li>卷积的性质<ul><li>交换性：$f(x)\ast g(x)=g(x)\ast f(x)$</li><li>结合性：$f(x)\ast g(x)\ast h(x)=f(x)\ast (g(x)\ast h(x))$</li><li>分配性：$(f(x)+g(x))\ast h(x)=f(x)\ast h(x)+g(x)\ast h(x)$</li><li>$a*\delta = a$</li></ul></li><li>相关与卷积相差一个旋转180度</li></ul></li><li><p>平滑线性滤波器</p><ul><li><p>盒式滤波器</p></li><li><p>加权均值滤波器</p></li><li><p>高斯滤波器（最常用）</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/平滑滤波器.png" alt=""></p></li></ul></li></ul><p><strong>线性移不变系统与卷积</strong></p><ul><li><p>线性系统$H$</p><ul><li>可叠加性：$H(f_1(x,y)+f_2(x,y))=H(f_1(x,y))+H(f_2(x,y))$</li><li>伸缩性：$H(af(x,y))=aH(f(x,y))$</li></ul></li><li><p>移不变系统$H$</p><ul><li>移不变性：若$H(f(x,y))=g(x,y)$，则$H(f(x-a,y-a))=g(x-a,y-a)$</li></ul></li><li>对于一个线性移不变系统来说，它的单位脉冲响应刻画了该系统的响应特性。换句话说，一旦知道了该系统的单位脉冲响应，可以推断出该系统对任何输入的响应</li><li>卷积用于计算线性移不变系统输入与输出的数学模型。具体地，若知道该系统的单位脉冲响应$h(x,y)$，则该系统的输入$f(x,y)$与输出$g(x,y)$之间可以用下式来表示。<ul><li>$g(x,y)=f(x,y)**h(x,y)$</li></ul></li><li>示例<ul><li>首先若已知$z[t]=x[t]<em>y[t]=[1]</em> [2,0,-2]=[2,0,-2]$</li><li>现有输入$x[t]=[1,2,3]=1\times[1,0,0]+2\times[0,1,0]+3\times[0,0,1]$</li><li>当用信号$x_0=1\times[1,0,0]$刺激系统时，有响应$z_0=[1\times 2,1\times 0,1\times (-2),{\color{Red} 0}  ,{\color{Red} 0} ]$</li><li>当用信号$x_1=2\times[0,1,0]$刺激系统时，有响应$z_1=[{\color{Red} 0} ,2\times 2,2\times 0,2\times (-2) ,{\color{Red} 0} ]$</li><li>当用信号$x_2=3\times[0,0,1]$刺激系统时，有响应$z_0=[{\color{Red} 0} ,{\color{Red} 0},3\times 2,3\times 0,3\times (-2)  ]$</li><li>把信号$x_0,x_1,x_2$叠加起来刺激系统时，响应为对应响应的叠加$z[t]+z_0+z_1+z_2=[2,4,4,-4,-6]$</li></ul></li></ul><p>锐化空间滤波器</p><ul><li>锐化的主要目标是突出图像中的细节(边缘)，或者增强模糊的细节</li><li>锐化通常是通过空间差分来完成的</li><li>数字图像函数的导数是通过差分来定义的</li><li>要求一阶导数必须满足<ul><li>平坦段必须为0 (灰度值恒定的区域)</li><li>在灰度阶跃或斜坡开始时必须非0</li><li>斜坡上一定是非0</li></ul></li><li>对于二阶导数必须满足<ul><li>在平坦段(灰度值恒定的区域)中必须为0</li><li>在灰度级阶跃或者斜坡的开始和结束时，必须是非0的</li><li>在坡度恒定的斜坡上必须为0</li></ul></li><li>一维函数$f(x)$一阶导数的一个基本定义就是差分<ul><li>$\frac{\partial f(x) }{\partial x} =f(x+1)-f(x)$ — 离散情况下相邻两个像素之间的距离为1</li><li>一阶差分一般用于边缘检测；因为在边缘处，差的绝对值是比较大的，检测值大的位置就是边缘，这样就可以把边缘提取出来。一阶导数通常对灰度阶跃(边缘)有更强的响应。</li></ul></li><li>同样地，定义二阶导数为<ul><li>$\frac{\partial^{2}f(x) }{\partial x^2}=f(x+1)-f(x)-(f(x)-f(x-1)) =f(x+1)+f(x-1)-2f(x)$</li><li>二阶差分一般用于图像锐化；因为经过两次差分之后，仍然留下的比较大的数值是特征点部分。二阶导数对细节有更强的响应</li><li>二阶差分的时候非零的只有一类，就是在变化开始和结束的时候，也就是特征点处</li></ul></li></ul><p>拉普拉斯滤波器</p><ul><li>拉普拉斯算子定义为<ul><li>$\bigtriangledown ^2f=\frac{\partial^{2}f }{\partial x^2}+\frac{\partial^{2}f }{\partial y^2}=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)$</li></ul></li><li>这里算出的结果只是<strong>差分结果</strong>(Mask)，并不是中间像素要被赋值的结果，赋值的结果应该是原本中间像素的值再<strong>减去</strong>Mask。</li><li>假如中间是一个灰度较大的值，周围灰度都很小，那么这个点就是一个特征点，需要被保存，现在经过拉普拉斯计算的值就是一个负的很大的值。因为我们是要<strong>增强</strong>特征点，所以原来的灰度大我们要让他<strong>更大</strong>，所以应该是原本灰度<strong>减</strong>差分结果。</li><li>拉普拉斯滤波器进行图像增强<ul><li>$g(x,y)=f(x,y)-\bigtriangledown ^2f(x,y)$</li><li>$=f(x,y)-(f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y))$</li><li>$=5f(x,y)-f(x+1,y)-f(x-1,y)-f(x,y+1)-f(x,y-1)$</li></ul></li></ul><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/Laplace滤波器.png" alt=""></p><p>反锐化掩模和高提升滤波</p><ul><li><p>以前印刷业经常用到的锐化方法，先将一张图平滑，也就是模糊掉，然后用原图减去模糊的图得到特征图Mask，然后原图加特征图得到锐化图</p></li><li><p>反锐化掩模是通过图像本身减去图像的模糊版本来实现的，即</p><ul><li>$f_s(x,y)=f(x,y)-\bar{f}(x,y)$</li><li>$\bar{f}(x,y)$表示原图$f(x,y)$的一个模糊版本</li></ul></li><li><p>对反锐化掩模的一种轻微推广称为高提升滤波，高提升滤波图像$h_{hb}(x,y)$定义为</p><ul><li>$h_{hb}(x,y)=f(x,y)+Af_s(x,y)$</li><li>$A \ge 1$</li></ul></li><li><p>$f(x,y)$的梯度表示为$(\frac{\partial f }{\partial x},\frac{\partial f }{\partial y})$</p></li></ul><p><strong>非线性空域滤波</strong></p><ul><li>非线性滤波通常也使用邻域，但是使用其他一些数学运算。例如，让每个中心点的响应等于其邻域内的最大像素值便是一种非线性滤波操作。</li><li>数字图像处理中最著名的阶序统计滤波器是中值滤波器</li></ul><h3 id="频域方法"><a href="#频域方法" class="headerlink" title="频域方法"></a>频域方法</h3><h4 id="傅立叶变换"><a href="#傅立叶变换" class="headerlink" title="傅立叶变换"></a>傅立叶变换</h4><p><strong>傅立叶级数</strong></p><ul><li><p>三角函数系:$\{0,1,sinx,cosx,sin2x,cos2x,…,sinnx,cosnx\}$</p></li><li><p>正交：</p><ul><li><p>$\int_{-\pi}^{+\pi}\sin nx\cos mxdx=0$</p></li><li><p>$\int_{-\pi}^{+\pi}\cos nx\cos mxdx=0, n \neq m$</p></li></ul></li><li><p>周期为$\color{red}2\pi$的函数展开为傅立叶级数</p><ul><li><p>$T=2\pi,f(x)=f(x+2\pi)$</p></li><li><p>$f(x)=\sum_{n=0}^{\infty}a_ncosnx+\sum_{n=0}^{\infty}b_nsinnx$ </p><p>​          $=a_0+\sum_{n=1}^{\infty}(a_n\cos nx+b_n\sin nx)$ </p></li><li><p>求解$a_0$，等式两边同时在$[-\pi,+\pi]$上积分</p></li><li><p>$\int_{-\pi}^{+\pi}f(x)dx=\int_{-\pi}^{+\pi}a_0dx+\int_{-\pi}^{+\pi}\sum_{n=1}^{\infty}(a_n\cos nx+b_n\sin nx)dx=2\pi a_0$</p><p>$\Rightarrow a_0=\frac{1}{2\pi}\int_{-\pi}^{+\pi}f(x)dx$</p></li><li><p>求解$a_n$，同乘$\color{red}{\cos mx}$后在$[-\pi,+\pi]$上积分</p></li><li><p>$\int_{-\pi}^{+\pi}f(x){\color{red}\cos mx}dx=\int_{-\pi}^{+\pi}a_0{\color{red}\cos mx}dx+\int_{-\pi}^{+\pi}\sum_{n=1}^{\infty}(a_n\cos nx{\color{red}\cos mx}+b_n\sin nx{\color{red}\cos mx})dx$</p></li><li><p>$\int_{-\pi}^{+\pi}f(x){\color{red}\cos mx}dx=\int_{-\pi}^{+\pi}a_n\cos nx{\color{red}\cos nx}dx=a_n\pi$ (积化和差)</p></li><li><p>$\Rightarrow a_n=\frac{1}{\pi}\int_{-\pi}^{+\pi}f(x)\sin nxdx$</p></li><li><p>同理求解$b_n$，同乘$\color{red}{\sin mx}$后在$[-\pi,+\pi]$上积分</p></li><li><p>$b_n=\frac{1}{\pi}\int_{-\pi}^{+\pi}f(x)\cos nxdx$</p></li></ul></li><li><p>周期为$\color{red}2L$的函数展开为傅立叶级数</p><ul><li>对于$f(t+2L)=f(t)$函数</li><li>换元$x=\frac{\pi}{L}t,\ t=\frac{L}{\pi}x \Rightarrow f(t)=f(\frac{L}{\pi}x)=g(x)$</li><li>$g(x)=a_0+\sum_{n=1}^{\infty}(a_n\cos nx+b_n\sin nx)$ </li><li>$f(t)=a_0+\sum_{n=1}^{\infty}(a_n\cos\frac{n\pi}{L}t+b_n\sin \frac{n\pi}{L}t)$<ul><li>$a_0=\frac{1}{2L}\int_{-L}^{+L}f(t)dt$</li><li>$ a_n=\frac{1}{L}\int_{-L}^{+L}f(x)\sin \frac{n\pi}{L}tdt$</li><li>$b_n=\frac{1}{L}\int_{-L}^{+L}f(x)\cos \frac{n\pi}{L}tdt$</li></ul></li><li>工程中$t$从$0$开始，周期为$T=2L$，$\omega =\pi/L=2\pi/T$ (<strong>基频率</strong>)<ul><li>$f(t)=a_0+\sum_{n=1}^{\infty}(a_n\cos n\omega t+b_n\sin  n\omega t)$</li><li>$a_0=\frac{1}{T}\int_{0}^{T}f(t)dt$</li><li>$ a_n=\frac{2}{T}\int_{0}^{T}f(t)\sin n\omega tdt$</li><li>$b_n=\frac{2}{T}\int_{0}^{T}f(t)\cos n\omega tdt$</li></ul></li></ul></li><li><p>傅立叶级数的复数形式</p><ul><li><p>欧拉公式：$e^{j\theta}=cos\theta+jsin\theta$</p><ul><li>$\cos\theta=\frac{1}{2}(e^{j\theta}+e^{-j\theta})$</li><li>$\sin\theta=-\frac{1}{2}j(e^{j\theta}-e^{-j\theta})$</li></ul></li><li><p>$f(t)=a_0+\sum_{n=1}^{\infty}(a_n\cos n\omega t+b_n\sin  n\omega t)$</p><p>​         $=a_0+\sum_{n=1}^{\infty}(\frac{1}{2}a_n(e^{jn\omega t}+e^{-jn\omega t})-\frac{1}{2}jb_n(e^{jn\omega t}-e^{-jn\omega t}))$</p><p>​         $=a_0+\sum_{n=1}^{\infty}\frac{a_n-jb_n}{2}e^{jn\omega t}+\color{red}{\sum_{n=1}^{\infty}\frac{a_n+jb_n}{2}e^{-jn\omega t}}$</p><p>​         $=a_0+\sum_{n=1}^{\infty}\frac{a_n-jb_n}{2}e^{jn\omega t}+\color{red}{\sum_{n=-\infty}^{-1}\frac{a_{-n}+jb_{-n}}{2}e^{jn\omega t}(n\to -n)}$</p><p>​         $=\sum_{n=0}^{\color{red}0}a_0e^{jn\omega t}+\sum_{\color{red}n=1}^{\color{red}\infty}\frac{a_n-jb_n}{2}e^{jn\omega t}+\sum_{\color{red}n=-\infty}^{\color{red}-1}\frac{a_{-n}+jb_{-n}}{2}e^{jn\omega t}$</p><p>​         $=\sum_{n=-\infty}^{+\infty}C_ne^{jn\omega t}$</p><ul><li><p>$C_0=a_0=\frac{1}{T}\int_{0}^{T}f(t)dt$</p></li><li><p>$C_n(n=1,2,…)=\frac{a_n-jb_n}{2}=\frac{1}{T}\int_{0}^{T}f(t)(\cos n\omega t-j\sin n\omega t)dt$</p><p>​                                 $=\frac{1}{T}\int_{0}^{T}f(t)e^{-jn\omega t}dt$</p></li><li><p>$C_n(n=1,2,…)=\frac{a_{-n}+jb_{-n}}{2}=\frac{1}{T}\int_{0}^{T}f(t)(\cos n\omega t-j\sin n\omega t)dt$</p><p>​                                 $=\frac{1}{T}\int_{0}^{T}f(t)e^{-jn\omega t}dt$</p></li></ul></li><li><p>$f(t)=\sum_{n=-\infty}^{+\infty}C_ne^{jn\omega t},C_n=\frac{1}{T}\int_{0}^{T}f(t)e^{-jn\omega t}dt$</p></li></ul></li></ul><p><strong>傅立叶变换</strong></p><ul><li>满足条件(狄利克雷条件)的任何周期函数可以由一系列不同频率的正弦(余弦)函数叠加而成。这种相加形式又称为级数，所以也称为傅立叶级数。</li><li>即使不是周期性的函数也可以表示为正弦(余弦)函数叠加而成(傅立叶变换)</li><li>频域是指将一个信号经过傅立叶变换后所得到的信号表示形式</li><li>傅立叶变换的目的是将信号表示为各种频率正余弦信号的线性组合</li><li>距离原点越近的频率成分越低频，越偏离远点的频率成分越高频</li><li>图像的平滑区域与细节区域分别对应于频谱图的低频成分与高频成分</li></ul><p>连续傅立叶变换</p><ul><li><p>一维傅立叶变换及其逆变换</p><ul><li>傅立叶变换：$F(u)=\int_{-\infty}^{+\infty}f(x)e^{-j2\pi ux}dx$, $j=\sqrt{-1}$</li><li>傅立叶逆变换：$f(x)=\int_{-\infty}^{+\infty}F(u)e^{j2\pi ux}du$</li><li>$e^{-j2\pi ux}$和$e^{j2\pi ux}$互为共轭函数</li><li>A为一个正交阵$AA^{H}=E$，定义正交变换$Y=AX$，则$X=A^{H}Y$</li></ul></li><li>傅立叶变换就是在用一种特殊的正交基(正交函数$e^{j2\pi ux}$)在对原函数做线性变换<br> <img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/欧拉.png" alt=""></li><li><p>二维傅立叶变换及其逆变换</p><ul><li>傅立叶变换：$F(u,v)=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}f(x,y)e^{-j2\pi(ux+vy)} dxdy$</li><li>傅立叶逆变换：$f(x,y)=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}F(u,v)e^{j2\pi(ux+vy)} dudv$</li></ul></li></ul><p>离散傅立叶变换(DFT)</p><ul><li><p>傅立叶变换：$F(u)=\sum_{x=0}^{M-1}f(x)e^{-\frac{j2\pi ux}{M}},u=0,1,2,…,M-1$</p><ul><li>由于$e^{j\theta}=cos\theta+jsin\theta$</li><li>$F(u)=\sum_{x=0}^{M-1}f(x)(cos(2\pi ux/M)-jsin(2\pi ux/M))$</li></ul></li><li><p>逆变换：$f(x)=\frac{1}{M}\sum_{u=0}^{M-1}F(u)e^{\frac{j2\pi ux}{M}},x=0,1,2,…,M-1$</p></li><li>频域：函数$F(u)$的自变量$u$的定义域范围，$u$描述变换中对应的频率分量的频率</li><li>频率分量：$F(u)$的$M$项中的每一项</li><li><p>$F(u)$可以用极坐标来表示</p><ul><li>$F(u)=|F(u)|e^{j\phi (u)}$</li><li>其中，$|F(u)|=(R^{2}(u)+I^{2}(u))^{\frac{1}{2}}$(幅度谱或频谱)<ul><li>由于$F(u)$为复函数形式，总是使用频谱表示傅里叶变换的结果</li><li>频谱描述了图像中某种频率的成分数量</li></ul></li><li>频率中出现的明亮线反映了原始图像的灰度级变化方向 (即图像的轮廓线或由灰度急剧变化来表征的内容，其方向与频谱中的明亮线相互垂直)</li><li>$\phi (u)=tan^{-1}\frac{I(u)}{R(u)}$(相位角或相位谱)</li><li>$I(u)$：$F(u)$的虚部；$R(u)$：$F(u)$的实部</li></ul></li><li><p>功率谱$P(u)=|F(u)|^{2}=R^{2}(u)+I^{2}(u)$</p></li></ul><p>二维离散傅立叶变换(2D DFT)</p><ul><li><p>傅立叶变换：$F(u,v)=\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)e^{-j2\pi( \frac{ux}{M}+\frac{vy}{N})}$</p><ul><li>$u=0,1,2,…,M-1,v=0,1,2,…,N-1$</li></ul></li><li><p>逆变换：$f(x,y)=\frac{1}{MN}\sum_{u=0}^{M-1}\sum_{v=0}^{N-1}F(u,v)e^{j2\pi( \frac{ux}{M}+\frac{vy}{N})}$</p><ul><li>$x=0,1,2,…,M-1,y=0,1,2,…,N-1$</li></ul></li><li>$u,v$：频率变量</li><li><p>$x,y$：空间变量</p></li><li><p>$|F(u,v)|=(R^{2}(u,v)+I^{2}(u,v))^{\frac{1}{2}}$(幅度谱或频谱)</p></li><li>$\phi (u,v)=tan^{-1}\frac{I(u,v)}{R(u,v)}$(相位角或相位谱)</li><li>$P(u,v)=|F(u,v)|^{2}=R^{2}(u,v)+I^{2}(u,v)$(功率谱)</li></ul><p><strong>二维离散傅立叶变换的性质</strong></p><ul><li>对于$\mathscr{F}(f(x,y))=F(u,v)$</li></ul><ol><li><p>空域平移性质</p><ul><li>$\mathscr{F}(f(x-x_0,y-y_0))=F(u,v)e^{-j2\pi( \frac{ux_0}{M}+\frac{vy_0}{N})}$</li><li>空域上的平移操作相当于在频域上围绕原点发生旋转，幅度频谱不改变</li></ul></li><li><p>频域平移性质</p><ul><li>$\mathscr{F}(f(x,y)e^{j2\pi( \frac{u_0x}{M}+\frac{v_0y}{N})})=F(u-u_0,v-v_0)$</li><li>$\mathscr{F}(f(x,y)(-1)^{x+y})=F(u-M/2,v-N/2),(u_0=M/2,v_0=N/2)$<ul><li>原式$=e^{j\pi(x+y)}=\cos(x+y)\pi+j\sin(x+y)\pi=(-1)^{x+y}$</li><li>应用于将最亮的位置转移到图像中心</li></ul></li></ul></li><li><p>平均和对称性质</p><ul><li><p>$\bar f(x,y)=\frac{1}{MN}F(0,0)=\frac{1} {MN}\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)$ </p></li><li><p>$F(u,v)=F^{*}(-u,-v)$ (共轭对称)</p><ul><li><p>数字图像$f(x,y)$是实函数</p></li><li><p>数字图像的傅里叶变换是中心对称的</p></li></ul></li><li><p>$|F(u,v)|=|F(-u,-v)|$ (幅度谱中心对称)</p></li></ul></li><li><p>可分离性质</p><ul><li><p>$F(u,v)=\mathscr{F}(f(x,y))$</p><p>​               $=\sum_{y=0}^{N-1}(\sum_{x=0}^{M-1}f(x,y)e^{-j2\pi{ux}/{M}})e^{-j2\pi {vy}/{N}}$</p><p>​               $=\sum_{y=0}^{N-1}F(u,y)e^{-j2\pi {vy}/{N}}$</p></li><li><p>$F(u,v)$的二维离散傅立叶变换可以通过一下计算方式得到</p><ul><li>对图像$f(x,y)$的每一行计算其一维傅立叶变换得到$F(u,y)$</li><li>对图像$F(u,y)$再进行一维离散傅立叶变换</li></ul></li></ul></li><li><p>旋转性质</p><ul><li>令，$x=rcos\theta,y=rsin\theta,u=\omega\cos\phi,v=\omega\sin\phi$</li><li>则，$f(r,\theta+\theta_0)\Leftrightarrow F(\omega,\phi+\theta_0)$</li></ul></li><li>周期性<ul><li>$f(x,y)=f(x+M,y)=f(x,y+N)=f(x+M,y+N)$</li><li>$F(u,v)=F(u+M,v)=F(u,v+N)=F(u+M,v+N)$</li></ul></li><li><p>线性</p><ul><li>$\mathscr{F}(af(x,y)+bg(x,y))=a\mathscr{F}(f(x,y))+b\mathscr{F}(g(x,y))$</li></ul></li><li>微分性质<ul><li>$\mathscr{F}(\frac{\partial^{n}f(x,y) }{\partial x^n})=(j2\pi u)^n\mathscr{F}(f(x,y))=(j2\pi u)^nF(u,v)$</li><li>$\mathscr{F}((-j2\pi u)^{n}f(x,y))=\frac{\partial^{n}F(u,v) }{\partial u^n}$</li><li>$\mathscr{F}(\bigtriangledown ^2f(x,y))=-4\pi^{2}(u^{2}+v^{2})F(u,v)$</li></ul></li><li><p>卷积定理</p><ul><li>$\mathscr{F}(f(x,y)*g(x,y))=F(u,v)G(u,v)$</li><li>$\mathscr{F}(f(x,y)g(x,y))=F(u,v)*G(u,v)$</li></ul></li><li><p>相关定理</p><ul><li>$\mathscr{F}(f(x,y)\circ g(x,y))=F^{*}(u,v)G(u,v)$</li><li>$\mathscr{F}(f(x,y)\circ f(x,y))=|F(u,v)|^{2}$</li><li>$\mathscr{F}(f^{*}(x,y) g(x,y))=F(u,v)\circ G(u,v)$</li><li>$\mathscr{F}(|f(x,y)|^{2})=F(u,v)\circ F(u,v)$</li></ul></li><li><p>伸缩性质</p><ul><li>$\mathscr{F}(f(ax,by))=\frac{1}{|ab|}F(\frac{u}{a},\frac{v}{b})$</li></ul></li></ol><p><strong>傅立叶变换对</strong></p><ul><li>$\delta(x,y)\Leftrightarrow 1$</li><li>$A2\pi\sigma^{2}e^{-2\pi^{2}\sigma^{2}(x^2+y^2)}\Leftrightarrow Ae^{-(u^2+v^2)/2\sigma^2}$<ul><li><em>高斯函数的傅立叶变换仍是高斯函数</em></li><li>$e^{-\pi(x^2+y^2)}\Leftrightarrow e^{-\pi(u^2+v^2)}$</li></ul></li><li>$\cos(2\pi u_0x+2\pi v_0y) \Leftrightarrow \frac{1}{2}(\delta(u+u_0,v+v_0)+(\delta(u-u_0,v-v_0))$<ul><li>$\cos\theta=\frac{1}{2}(e^{j\theta}+e^{-j\theta})$</li><li>频域上对称的两个脉冲信号</li></ul></li><li>$\sin(2\pi u_0x+2\pi v_0y) \Leftrightarrow \frac{1}{2}j(\delta(u+u_0,v+v_0)-(\delta(u-u_0,v-v_0))$</li></ul><h4 id="频域滤波"><a href="#频域滤波" class="headerlink" title="频域滤波"></a>频域滤波</h4><ul><li>空间域和频域中线性滤波的基础是卷积定理，它可以写成<ul><li><script type="math/tex; mode=display">f(x,y)*h(x,y)\Leftrightarrow F(u,v)H(u,v)</script></li></ul></li><li>频域滤波器的基本想法是选择一个特定的滤波器传递函数来修改输入图像的傅里叶变换$F(u,v)$</li><li>基于卷积定理，可以知道为了在空域中获得相应的滤波图像，只需要简单的计算输入图像的傅里叶变换与滤波器乘积$H(u,v)F(u,v)$的逆傅里叶变换</li><li>如果周期相对于函数的非零部分的长度非常接近，则周期函数的卷积可能带来相邻周期内的非零部分信号的干扰，这种干扰称为混叠误差(卷积后的大小为$L+l-1$)，可以用零填充的技术手段消除 </li></ul><p>频率域滤波的基本步骤</p><ol><li>用$(-1)^{x+y}$乘以输入图像$f(x,y)$，使其原点中心化</li><li>对步骤1的结果执行DFT，得到关于中心对称的频谱$F(u,v)$</li><li>生成实的、中心对称的频域滤波器$H(u,v)$</li><li>对滤波器$H(u,v)$、频谱$F(u,v)$阵列相乘(对应元素逐个进行相乘)，形成乘积$G(u,v)=H(u,v)F(u,v)$，其中$G(m,n)=H(m,n)F(m,n)$</li><li>对步骤4的结果$G(u,v)$执行反DFT，并取其结果的实部</li><li><p>用$(-1)^{x+y}$乘以步骤5的反DFT结果的实部，得到滤波结果$g(x,y)$</p><p>如何获取频域滤波器</p></li><li><p>从空域滤波器获取频域滤波器</p></li><li>频域中直接构造滤波器</li></ol><p><strong>频域中直接构造滤波器</strong></p><p><strong>低通滤波器（平滑）</strong></p><ul><li><p>使频谱的低频成分通过，同时使其高频成分衰减</p></li><li><p>理想的低通滤波器(<strong>ILPF</strong>)</p><ul><li><script type="math/tex; mode=display">H(u,v) = \begin{cases}1,if\  D(u,v)\le  D_0\\0,if\  D(u,v) >  D_0\end{cases}</script></li><li><p>其中，$D(u,v)$表示从点$(u,v)$到频率矩形中心的距离</p><script type="math/tex; mode=display">D(u,v)=\sqrt{(u-M/2)^2+(v-N/2)^2}</script></li><li><p>$D_0$称为截止频率，$D_0$越小保留的信息越少越模糊</p></li><li><p>截止频率可以通过频谱中通过的功率占比选择</p><ul><li><p>总功率: <script type="math/tex">P_{T}=\sum_{0}^{M-1}\sum_{0}^{N-1}P(u,v)</script></p></li><li><p>通过截止频率为$D_0$低通滤波器：<script type="math/tex">P_{pass}=\sum_{0}^{\hat{M} -1}\sum_{0}^{\hat{N}-1}P(u,v),\ \hat{M}<M,\ \hat{N}<N</script></p></li><li><script type="math/tex">\frac{P_{pass}}{P_T}\times 100 = \alpha</script>表示频域中心半径为$D_0$包含$\alpha%$的功率</li></ul></li><li><p>ILPF通常带有振铃效应(出现带有波纹的模糊图像)</p></li></ul></li><li><p>巴特沃斯低通滤波器(<strong>BLPF</strong>)</p><ul><li><script type="math/tex; mode=display">H(u,v) =\begin{pmatrix}1+(D(u,v)/D_0)^{2n}\end{pmatrix}^{-1}</script></li><li>阶数n越大越趋于理想的低通滤波器</li><li>高阶BLPF会出现振铃效应</li></ul></li><li>高斯低通滤波器(<strong>GLPF</strong>)<ul><li><script type="math/tex; mode=display">H(u,v)=e^{-D^{2}(u,v)/2D_0^2}</script></li><li>高斯低通滤波器不能达到相同截止频率的BLPF低通滤波器的平滑效果</li><li>高斯低通滤波器没有振铃效果(高斯函数的傅里叶逆变换仍是高斯函数)</li></ul></li></ul><p><strong>高通滤波器（锐化）</strong></p><ul><li>使频谱的高频成分通过，同时使其低频成分衰减</li><li><p>通用高通频域滤波器 </p><ul><li><script type="math/tex; mode=display">H_{hp}(u,v) = 1-H_{lp}(u,v)</script></li></ul></li><li><p>理想的高通滤波器 (<strong>IHPF</strong>)</p><ul><li><script type="math/tex; mode=display">H(u,v) = \begin{cases}0,if\  D(u,v)\le  D_0\\1,if\  D(u,v) >  D_0\end{cases}</script></li></ul></li><li><p>巴特沃斯高通滤波器 (<strong>BHPF</strong>)</p><ul><li><script type="math/tex; mode=display">H(u,v) =\begin{pmatrix}1+(D_0/D(u,v))^{2n}\end{pmatrix}^{-1}</script></li></ul></li><li>高斯高通滤波器 (<strong>GHPF</strong>)<ul><li><script type="math/tex; mode=display">H(u,v)=1-e^{-D^{2}(u,v)/2D_0^2}</script></li></ul></li><li>图像经过高通滤波后，其背景的平均强度减少到接近黑色 (高通滤波器除去了傅里叶变换的零频率成分)</li><li>解决方法：把原始图像加到滤波后的结果图像中，即高频提升滤波或高频加强滤波</li><li>高频加强滤波(*)<ul><li><script type="math/tex; mode=display">H_{hfe}(u,v)=a+bH_{hp}(u,v)</script></li><li>在高通滤波器函数前乘以一个常数，再增加一个偏移量以便使零频率不被滤波器滤除掉</li></ul></li></ul><p><strong>同态滤波</strong></p><ul><li><p>同态滤波基于图像的成像模型，在频域压缩灰度动态范围，增强对比度</p><ul><li><script type="math/tex; mode=display">f(x,y)=I(x,y)\times R(x,y)</script></li><li><script type="math/tex">I(x,y)</script>表示照射分量，<script type="math/tex">R(x,y)</script>表示反射分量</li></ul></li><li><p>人眼对于图像亮度的响应具有类似于对数运算</p><ul><li><script type="math/tex; mode=display">lnf(x,y)=lnI(x,y)+lnR(x,y)</script></li><li>照射分量在整个空间区域缓慢变化</li><li>反射分量在物体间的交界处急剧变化</li></ul></li><li><p>对成像模型的对数形式做傅里叶变换</p><ul><li><script type="math/tex; mode=display">\hat{F}(u,v)= \hat{I}(u,v)+\hat{R}(u,v)</script></li><li><script type="math/tex">\hat{I}(u,v)</script>低频分量</li><li><script type="math/tex">\hat{R}(u,v)</script>高频分量</li></ul></li><li><p>令<script type="math/tex">\hat{G}(u,v)= H(u,v)\times\hat{F}(u,v)</script></p><ul><li><script type="math/tex; mode=display">\hat{G}(u,v)= H(u,v)\times\hat{I}(u,v)+ H(u,v)\times\hat{R}(u,v)</script></li></ul></li><li><p>傅里叶逆变换</p><ul><li><script type="math/tex; mode=display">g(x,y)= \hat{I}(x,y)+ \hat{R}(x,y)</script></li></ul></li><li><p>指数变换</p><ul><li><script type="math/tex; mode=display">g(x,y)= \exp {(\hat{I}(x,y)+ \hat{R}(x,y))}</script></li></ul></li><li><p><script type="math/tex">H(u,v)</script>的设计</p><ul><li>抑制低频，压缩图像的动态范围</li><li>增强高频，加大各部分间的对比度</li></ul></li></ul><p>基于Retinex滤波</p><ul><li>Retina：视网膜</li><li>Cortex：大脑皮层</li></ul><p>Retinex理论</p><ul><li>物体颜色：物体表面对长波、中波、短波的反射特性</li><li>人眼视觉：观察物体时首先寻找标准的“白光”；计算色差，从而得到物体的信息</li><li>入射光决定了图像灰度级的动态范围</li><li><strong>反射光</strong>决定了图片具有的内在本质</li><li><script type="math/tex; mode=display">f(x,y)=I(x,y)\times \color{red}R(x,y)</script><ul><li><script type="math/tex; mode=display">\ln f(x,y)=\ln I(x,y)+ \color{red}\ln R(x,y)</script></li><li><script type="math/tex; mode=display">{\color{red}\ln R(x,y)}=\ln f(x,y)-\ln I(x,y)</script><ul><li>$\ln f(x,y)$已知；$\ln I(x,y)$估算</li></ul></li><li>入射分量具有缓和平滑性</li><li>入射分量与反射光具有一定的弱相关性</li></ul></li><li>环绕函数法<ul><li>$I(x,y)=f(x,y)*h(x,y)$</li><li><script type="math/tex; mode=display">h(x,y)=\frac{1}{2\pi\sigma_x\sigma_y}e^{-\frac{1}{2}(\frac{x^{2}}{\sigma_x^{2}}+\frac{y^{2}}{\sigma_y^{2}})}</script></li><li><script type="math/tex; mode=display">R(x,y)=\exp(\ln f(x,y)-\ln (f(x,y*h(x,y))))</script></li></ul></li></ul><h2 id="图像复原"><a href="#图像复原" class="headerlink" title="图像复原"></a>图像复原</h2><ul><li><p>图像复原：以某种预定义的方式改善给定图像</p></li><li><p>图像退化与复原的数学模型</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/复原模型.png" alt=""></p><ul><li><script type="math/tex; mode=display">g(x,y)=H(f(x,y))+\eta(x,y)</script></li><li><script type="math/tex; mode=display">g(x,y)=h(x,y)*f(x,y)+\eta(x,y)</script><ul><li>($H$线性移不变系统)</li></ul></li><li><script type="math/tex; mode=display">G(u,v)=H(u,v)F(u,v)+N(u,v)</script></li></ul></li></ul><h3 id="噪声模型"><a href="#噪声模型" class="headerlink" title="噪声模型"></a>噪声模型</h3><p><strong>独立同分布的空域随机噪声</strong></p><ul><li>如果$\omega$是区间$(0,1)$上服从均匀分布的随机变量，那么我们可以通过求解方程得到一个具有指定累积分布函数(CDF)$F_z$的随机变量$z$<ul><li>$z=F_z^{-1}(\omega)$</li><li>设$z$为服从任意分布的随机变量，根据直方图均衡中的结果$\omega=F_z(z)$服从$(0,1)$的均匀分布</li></ul></li><li>例：用瑞利CDF生成随机数z<ul><li><script type="math/tex; mode=display">F_z(z)=\begin{cases}1-e^{(z-a)^{2}/b},\ if\  z \ge a\\0,\ if\  z < a\end{cases}</script></li><li>$\omega=1-e^{(z-a)^{2}/b}$</li><li>$z=a+\sqrt{-b+ln(1-\omega)}$</li></ul></li></ul><p><strong>周期噪声</strong></p><ul><li>$r(x,y)=A\sin (2\pi u_0(x+B_x)/M+2\pi v_0(y+B_y)/N)$</li></ul><p><strong>估算噪声参数</strong></p><ul><li><p>通过对图像的傅里叶频谱的审视来估计周期性噪声的参数，例如通过肉眼去发现频谱中的频域尖峰</p></li><li><p>尝试直接从图像推断噪声分量的周期性通常仅在简单的情况下是可行的</p></li><li><p>在噪声尖峰非常明显，或者具有对于干扰的频率分量一般位置的先验知识的情况下，才可以进行自动分析。</p></li><li><p>噪声PDF的参数可以部分从传感器规范中得知，但通常需要针对特定的成像环境估计它们，例如，一组“平坦”环境</p></li><li><p>当仅有生成的图像可用时，通常可以从相对恒定灰度级的图像小区域中估计噪声PDF的参数</p></li><li><p>最简单的方法就是利用图像中的采样数据来估计噪声的均值和方差</p></li><li><p>通过直方图的形状来辨识最接近的PDF匹配</p></li></ul><p>统计矩和中心距</p><ul><li>$\mu_n=\sum_{i=0}^{L-1}(z_i-m)^np(z_i),\ m=\sum_{i=0}^{L-1}z_ip(z_i)$</li><li>where $n=0$, $\mu_0=\sum_{i=0}^{L-1}(z_i-m)^0p(z_i)=1$</li><li>where $n=1$, $\mu_1=\sum_{i=0}^{L-1}(z_i-m)p(z_i)=\sum_{i=0}^{L-1}z_ip(z_i)-m\sum_{i=0}^{L-1}p(z_i)=0$</li><li>where $n=2$, $\mu_2=\sum_{i=0}^{L-1}(z_i-m)^2p(z_i)=Var(z)$</li></ul><h3 id="只存在噪声的复原"><a href="#只存在噪声的复原" class="headerlink" title="只存在噪声的复原"></a>只存在噪声的复原</h3><h4 id="空域滤波"><a href="#空域滤波" class="headerlink" title="空域滤波"></a>空域滤波</h4><p>如果只有噪声，图像退化模型可以表示为</p><ul><li>$g(x,y) = f(x,y) + \eta(x,y)$</li><li>$G(u,v) = F(u,v) +N(u,v)$</li></ul><p><strong>空域噪声滤波器</strong></p><p>均值滤波器</p><ul><li><p>算数平均滤波器</p><ul><li><p>$\hat{f}(x,y)=\frac{1}{mn}\sum_{(s,t)\in S_{xy}}g(s,t)$</p></li><li><p>$S_{xy}表示以(x,y)为中心的一个邻域$</p></li></ul></li><li><p>几何均值滤波器</p><ul><li>$\hat{f}(x,y)=\sqrt[mn]{ {\textstyle \prod_{(s,t)\in S_{xy}}} g(s,t)}$</li></ul></li><li>谐波均值滤波器<ul><li>$\hat{f}(x,y)=\frac{mn}{\sum_{(s,t)\in S_{xy}}1/g(s,t)}$</li><li>谐波均值滤波器不能消除椒盐噪声，对高斯噪声效果很好</li></ul></li><li>逆谐波均值滤波器<ul><li>$\hat{f}(x,y)=\frac{\sum_{(s,t)\in S_{xy}}g(s,t)^{Q+1}}{\sum_{(s,t)\in S_{xy}}g(s,t)^{Q}}$<ul><li>设$A=\sum_{(s,t)\in S_{xy}}g(s,t)^{Q}$</li><li>$原式=\sum_{(s,t)\in S_{xy}}\frac{g(s,t)^{Q}}{A}g(s,t)$</li><li>因此，原式可以看做$g(s,t)$的加权求和</li><li>$Q&gt;0$时，$g$越大权重系数越大，可消除椒噪声</li><li>$Q&lt;0$时，$g$越大权重系数越小，可消除盐噪声</li></ul></li><li>$Q$称为滤波器的阶数</li><li>$Q=0$简化为算数均值滤波器</li><li>$Q=-1$简化为谐波均值滤波器</li><li>椒盐噪声又叫冲击噪声（或者脉冲噪声）。在图像中的表现为离散分布的纯白色或者黑色像素点。由于在正常情况下，在图像中不太可能出现最大/最小值的灰度像素，因此这样的像素点可以被当成噪点。</li><li>逆谐波均值滤波器非常适合消除椒盐噪声的影响。当$Q&gt;0$时，该滤波器可消除椒噪声；当$Q&lt;0$时，适合消除盐噪声。它不能同时消除两种噪声</li></ul></li></ul><p>统计排序滤波器</p><ul><li><p>中值滤波器</p><ul><li><script type="math/tex; mode=display">\hat{f}(x,y)={\mbox{ median}}_{(s,t)\in S_{xy}}g(s,t)</script></li></ul></li><li><p>最大、最小滤波器</p><ul><li><script type="math/tex; mode=display">\hat{f}(x,y)= \max_{(s,t)\in S_{xy}} g(s,t)</script></li><li><script type="math/tex; mode=display">\hat{f}(x,y)=\min_{(s,t)\in S_{xy}} g(s,t)</script></li></ul></li><li><p>中点滤波器</p><ul><li><script type="math/tex; mode=display">\hat{f}(x,y)=(\max_{(s,t)\in S_{xy}} g(s,t)+\min_{(s,t)\in S_{xy}} g(s,t))/2</script></li></ul></li><li><p>$\alpha$均值滤波器</p><ul><li><p>$\hat{f}(x,y)=\frac{1}{mn-d}\sum_{(s,t)\in S_{xy}}g_r(s,t)$</p></li><li><p>在邻域$S_{xy}$内去掉$g(s,t)$最低灰度值的$d/2$和最高灰度值的$d/2$</p></li></ul></li></ul><p>自适应空域中值滤波器</p><ul><li><p>符号</p><ul><li>$z_{\min} = S_{xy}中的最小灰度值$</li><li>$z_{\max} = S_{xy}中的最大灰度值$</li><li>$z_{med} = S_{xy}中的灰度值的中值$</li><li>$z_{xy} = 坐标(x,y)处的灰度值$</li><li>$S_{\max}=S_{xy}允许的最大尺度$</li></ul></li><li><p>自适应中值滤波算法以两个进程工作，表示为Level A和Level B，如下所示</p><p>Level A：</p><ul><li>$A_1=z_{med} - z_{\min}$</li><li>$A_2=z_{med} - z_{\max}$</li><li>if $A_1&gt;0$ and $A_2&lt;0$ (中值介于最大值和最小值之间，不是椒噪声也不是盐噪声), go to Level B</li><li>else increase the window size</li><li>if window size $\le S_{\max}$, repeat Level A</li><li>else output $z_{med}$</li></ul><p>Level B:</p><ul><li>$B_1=z_{xy} - z_{\min}$</li><li>$B_2=z_{xy} - z_{\max}$</li><li>if $B_1&gt;0$ and $B_2&lt;0$ (当前值不是椒噪声也不是盐噪声), output $z_{xy}$</li><li>else output $z_{med}$</li></ul></li></ul><h4 id="频域滤波-1"><a href="#频域滤波-1" class="headerlink" title="频域滤波"></a>频域滤波</h4><ul><li>用频率域技术可以有效地分析并滤除周期噪声。在傅里叶变换中，周期噪声在对应于周期干扰的频率处，以集中的能量脉冲形式出现</li></ul><p><strong>带阻滤波器</strong></p><ol><li>理想带阻滤波器<ul><li><script type="math/tex; mode=display">H(u,v) = \begin{cases} 1,if\  D(u,v) <  D_0 -\frac{W}{2}\\ 0,if\  D_0 -\frac{W}{2}< D(u,v)<  D_0 +\frac{W}{2} \\ 1,if\ D(u,v)>  D_0 +\frac{W}{2} \end{cases}</script></li></ul></li><li>巴特沃斯带阻滤波器<ul><li><script type="math/tex; mode=display">H(u,v) =\begin{pmatrix} 1+(\frac{D(u,v)W}{D^2(u,v)-D^2_0})^{2n} \end{pmatrix}^{-1}</script></li></ul></li><li>高斯带阻滤波器<ul><li><script type="math/tex; mode=display">H(u,v) = 1-\exp{ (-\frac{1}{2}(\frac{D^2(u,v)-D^2_0}{D(u,v)W})^{2}})</script></li></ul></li></ol><p><strong>带通滤波器</strong></p><ul><li><script type="math/tex; mode=display">H_{bp}(u,v) = 1 - H_{br}(u,v)</script></li><li>使用带通滤波器可以提取噪声信号</li></ul><p><strong>陷波滤波器</strong></p><ol><li>理想陷波滤波器<ul><li><script type="math/tex; mode=display">H(u,v)=\begin{cases} 0,\ if\  D_1(u,v) \le D_0 \ or \ D_2(u,v) \le D_0\\ 1, \ else \end{cases}</script></li><li><script type="math/tex; mode=display">D_1(u,v)=\sqrt{(u-\frac{M}{2}-u_0)^2-(v-\frac{N}{2}-v_0)^2}</script></li><li><script type="math/tex; mode=display">D_2(u,v)=\sqrt{(u-\frac{M}{2}+u_0)^2-(v-\frac{N}{2}+v_0)^2}</script></li><li>假设0频率在图像中心$(\frac{M}{2},\frac{N}{2})$</li></ul></li><li>巴特沃斯陷波滤波器<ul><li><script type="math/tex; mode=display">H(u,v) =\begin{pmatrix} 1+(\frac{D^2_0}{D_1(u,v)D_2(u,v)}) \end{pmatrix}^{-1}</script></li></ul></li><li>高斯陷波滤波器<ul><li><script type="math/tex; mode=display">H(u,v) = 1-\exp{ (-\frac{1}{2}(\frac{D_1(u,v)D_2(u,v)}{D^2_0}))}</script></li></ul></li></ol><p><strong>最佳陷波滤波算法</strong></p><ul><li><p>当存在多个干扰分量时，由于滤波过程去除的图像信息过多，上述方法的滤波效果并不总是可以接受的</p></li><li><p>这里讨论的方法的最优是在<em>最小化被复原图像局部方差</em>意义下的</p><ul><li>邻域内方差很小，意味着邻域内所有的信号值比较相近，没有发生突变</li></ul></li><li><p>首先通过如下计算获得对噪声的初始估计</p><ul><li>$N(u,v)=F_N(u,v)G(u,v)$</li><li>$\eta(x,y)={\mathscr{F}}^{-1}(F_N(u,v)G(u,v))$</li><li>$F_N(u,v)$是获取噪声干扰模式的陷波滤波器</li></ul></li><li><p>令$\hat{f}(x,y)=g(x,y)-\omega(x,y)\eta(x,y)$</p><ul><li>寻找调制函数$\omega(x,y)$，来最小化$\hat{f}(x,y)$的局部方差</li></ul></li><li><p>目标函数</p><ul><li><script type="math/tex; mode=display">\min\sigma^{2}(x,y)=\frac{1}{(2a+1)(2b+1)}\sum_{s=-a}^{a}\sum_{t=-b}^{b}(\hat{f}(x+s,y+t)-\bar{f})^2</script></li><li><script type="math/tex; mode=display">\bar{f}=\frac{1}{(2a+1)(2b+1)}\sum_{s=-a}^{a}\sum_{t=-b}^{b}\hat{f}(x+s,y+t)</script></li></ul></li></ul><ul><li><p>由(1)式可得</p><ul><li><p>$\sigma^{2}(x,y)=\frac{1}{(2a+1)(2b+1)}\sum_{s=-a}^{a}\sum_{t=-b}^{b}(g(x+s,y+t)-$</p><p>$\omega(x+s,y+t)\eta(x+s,y+t)-(\bar{g}(x,y)-\overline{\omega(x,y)\eta(x,y)}))^2$</p></li></ul></li><li><p>假设$\omega(x,y)$在整个邻域内基本保持不变，即$\omega(x+s,y+t)=\omega(x,y)$，有</p><ul><li><p>$\sigma^{2}(x,y)=\frac{1}{(2a+1)(2b+1)}\sum_{s=-a}^{a}\sum_{t=-b}^{b}(g(x+s,y+t)-$</p><p>$\omega(x,y)\eta(x+s,y+t)-(\bar{g}(x,y)-\omega(x,y)\bar{\eta}(x,y)))^2$</p></li></ul></li><li><p>为了最小化$\sigma^{2}(x,y)$，求解方程</p><ul><li><script type="math/tex; mode=display">\frac{\partial\sigma^2(x,y)}{\partial\omega (x,y)}=0</script></li></ul></li><li><p>求得的结果为</p><ul><li><script type="math/tex; mode=display">\omega(x,y)=\frac{\overline{g(x,y)\eta(x,y)}-\bar{g}(x,y)\bar{\eta}(x,y)}{\bar{\eta^2}(x,y)-\bar{\eta}^2(x,y)}</script></li></ul></li></ul><h3 id="含有退化函数的复原"><a href="#含有退化函数的复原" class="headerlink" title="含有退化函数的复原"></a>含有退化函数的复原</h3><h4 id="估计退化函数"><a href="#估计退化函数" class="headerlink" title="估计退化函数"></a>估计退化函数</h4><ul><li><p>图像观察估计法</p><ul><li>设$g_s(u,v)$为观测到图像的子图像，$\hat{f}_s(x,y)$为原始子图像的估计值，假设选择的是强信号区域，因此噪声可以忽略，有<ul><li><script type="math/tex; mode=display">H_s(u,v)=\frac{G_s(u,v)}{\hat{F}_s(u,v)}</script></li></ul></li><li>然后可以从$H_s(u,v)$推导出完整的函数$H(u,v)$</li><li>实验估计方法 </li></ul></li><li><p>实验估计方法</p><ul><li><script type="math/tex; mode=display">H(u,v)=\frac{G(u,v)}{A}</script></li><li>$G(u,v)$是观察图像的傅里叶变换</li><li>$A$是一个描述冲激强度的常量</li></ul></li><li><p>建模估计法</p><ul><li>基于大气湍流的物理特征提出</li></ul><ul><li><script type="math/tex; mode=display">H(u,v)=e^{-k(u^2+v^2)^{5/6}}</script></li><li><p>$k$是与湍流的性质有关的常数</p></li><li>$k \rightarrow 0, \ H(u,v)\rightarrow 1$，无退化</li></ul></li><li><p>建模运动带来的图像模糊退化</p><ul><li><p>$g(x,y)= \int_{0}^{T}f(x-x_0(t),y-y_0(t))dt$</p><ul><li>$g(x,y)$为模糊后的图像</li></ul></li><li><p>对其进行傅里叶变换有</p><script type="math/tex; mode=display">G(u,v)=\int_{-\infty}^{-\infty}\int_{-\infty}^{-\infty} g(x,y)e^{-j2\pi( ux+vy)}dxdy</script><script type="math/tex; mode=display">=\int_{-\infty}^{-\infty}\int_{-\infty}^{-\infty}\left ( \int_{0}^{T}f(x-x_0(t),y-y_0(t))dt \right ) e^{-j2\pi( ux+vy)}dxdy</script><script type="math/tex; mode=display">=\int_{0}^{T}\left ( \int_{-\infty}^{-\infty}\int_{-\infty}^{-\infty}f(x-x_0(t),y-y_0(t))e^{-j2\pi( ux+vy)}dxdy \right )dt</script></li><li><p>根据傅里叶变换的平移性质</p><script type="math/tex; mode=display">原式= \int_{0}^{T}F(u,v)e^{-j2\pi( ux_0(t)+vy_0(t))}dt</script><p>$= F(u,v)\int_{0}^{T}e^{-j2\pi( ux_0(t)+vy_0(t))}dt$</p></li><li><p>因此</p><script type="math/tex; mode=display">H(u,v)=\int_{0}^{T}e^{-j2\pi( ux_0(t)+vy_0(t))}dt</script></li><li><p>若$x_0(t)=at/T,y_0(t)=0$，(水平方向匀速运动，垂直方向不变)那么</p><script type="math/tex; mode=display">H(u,v)=\int_{0}^{T}e^{-j2\pi uat/T}dt=\frac{T}{\pi ua}\sin(\pi ua)e^{-j\pi ua}</script></li><li><p>若$y_0(t)=bt/T$，那么</p><script type="math/tex; mode=display">H(u,v)=\frac{T}{\pi(ua+vb)}\sin(\pi(ua+vb))e^{-j\pi (ua+vb)}</script></li></ul></li></ul><h4 id="逆滤波"><a href="#逆滤波" class="headerlink" title="逆滤波"></a>逆滤波</h4><ul><li><p><a href="https://blog.csdn.net/bluecol/article/details/47357717">https://blog.csdn.net/bluecol/article/details/47357717</a></p></li><li><p>对于一副被退化函数$H$降质的图像，最简单的复原方法就是直接采用逆滤波，即</p><ul><li>$\hat{F}(u,v)=\frac{G(u,v)}{H(u,v)}$ (假设$N(u,v)=0$)</li><li>该除法是阵列操作，即按位除。</li></ul></li><li><p>进一步，由$G(u,v)=H(u,v)F(u,v)+N(u,v)$可以得到</p><ul><li><script type="math/tex; mode=display">\hat{F}(u,v)=F(u,v) + \frac{N(u,v)}{H(u,v)}</script></li></ul></li><li><p>如果退化函数$H(u,v)$在某一个频率点的值为$0$或很小的值，那么比值$N(u,v)/H(u,v)$很容易压制信号，造成$F(u,v)$的估计存在较大误差。一种解决方法是只利用原点附近退化函数的值来进行逆滤波(受限逆滤波)的计算</p></li></ul><h4 id="维纳滤波"><a href="#维纳滤波" class="headerlink" title="维纳滤波"></a>维纳滤波</h4><ul><li><p><a href="https://blog.csdn.net/bluecol/article/details/46242355">https://blog.csdn.net/bluecol/article/details/46242355</a></p></li><li><p>综合了退化函数和信噪统计特性两个方面进行复原处理</p></li><li><p>引入最小二乘约束条件，使得$f(x,y)$与$\hat{f}(x,y)$之间的均方误差最小</p></li><li><p>维纳滤波器寻求能最小化下面的统计误差函数的估计值$\hat{f}$</p><ul><li>$e^{2}=E{(f-\hat{f})^2}$</li><li>其中，$E$为求取数学期望的算子，$f$为没有退化的图像。这个表达式在频域中的解为</li><li><script type="math/tex; mode=display">\hat{F}(u,v)=\left( \frac{1}{H(u,v)}\frac{|H(u,v)|^2}{|H(u,v)|^2+S_{\eta}(u,v)/S_{f}(u,v)} \right)G(u,v)</script></li><li>$|H(u,v)|^2=H^{*}(u,v)H(u,v)$</li><li>$H^{*}(u,v)$为$H(u,v)$的复共轭</li><li>$S_{\eta}(u,v)=|N(u,v)|^2$表示噪声的功率谱</li><li>$S_{f}(u,v)=|F(u,v)|^2$表示未退化图像的功率谱</li></ul></li><li><p>$\frac{|S_{\eta}(u,v)|^{2}}{|S_{f}(u,v)|^{2}}$为噪信功率比</p><ul><li>如果噪声为0，则维纳滤波器退化为逆滤波</li><li>如果噪心功率比未知或不可估计，则<ul><li><script type="math/tex; mode=display">\hat{F}(u,v)=\left( \frac{1}{H(u,v)}\frac{|H(u,v)|^2}{|H(u,v)|^2+K} \right)G(u,v)</script></li></ul></li><li>其中$K$表示一个交互的标量常数</li></ul></li></ul><p><strong>维纳滤波与逆滤波的比较</strong></p><ul><li>逆滤波算法简单，但去模糊能力不强，且忽略噪声影响</li><li>维纳滤波去模糊效果优于逆滤波，且具备去噪功能，但需要知道未退化图像和噪声的功率比</li><li>维纳滤波建立在最小化统计准则的基础上，滤波结果只是平均意义上的最优</li></ul><h4 id="约束最小二乘方滤波"><a href="#约束最小二乘方滤波" class="headerlink" title="约束最小二乘方滤波"></a>约束最小二乘方滤波</h4><ul><li><a href="https://blog.csdn.net/bluecol/article/details/47359421?spm=1001.2014.3001.5502">https://blog.csdn.net/bluecol/article/details/47359421?spm=1001.2014.3001.5502</a></li><li>使用维纳滤波方法存在的困难：必须知道未退化图像和噪声的功率谱</li><li>对功率谱比的恒定估计有时可以取得很好的结果，但并不意味着它总是一种很好的解决方法</li><li>下面将要讨论的约束最小二乘滤波方法只需要知道噪声的均值和方差</li><li>如果用矩阵建模退化过程，有<ul><li>$g(x,y)=h(x,y)*f(x,y)+\eta(x,y)$</li><li>$\mathbf{g} =\mathbf{H} \mathbf{f} +\mathbf{\eta} $</li><li>$\mathbf{H}$是$MN$维方阵，$\mathbf{g},\mathbf{f},\mathbf{\eta}$为$MN$维列向量</li></ul></li><li>该方法的核心是$H$对噪声敏感性问题。缓解这个问题的一种方法是将复原计算建立在一个图像平滑度的度量上</li><li>拉普拉斯算子是个很不错的选择<ul><li><script type="math/tex; mode=display">min\ C=\sum_{X=0}^{M-1}\sum_{y=0}^{N-1}(\bigtriangledown ^2f(x,y))^2</script></li><li>其约束为<script type="math/tex">\left \| \mathbf{g} -\mathbf{H} \mathbf{\hat{f}}  \right \|^2 =\left \| \mathbf{\eta} \right \|^2</script></li><li>拉普拉斯算子$\bigtriangledown ^2$在这里表示平滑程度</li></ul></li><li>该问题在频域中的解为<ul><li><script type="math/tex; mode=display">\hat{F}(u,v)=\left( \frac{H^*(u,v)}{|H(u,v)|^2+\gamma|P(u,v)|^2} \right)G(u,v)</script></li><li>其中$\gamma$是一个参数，$P(u,v)$是拉普拉斯算子$p(x,y)$的傅里叶变换<ul><li><script type="math/tex; mode=display">p(x,y)= \begin{pmatrix}  0& -1 & 0\\  -1& 4 & -1\\  0& -1 &0\end{pmatrix}</script></li></ul></li><li>$\gamma=0$时，简化为逆滤波</li></ul></li><li>迭代计算$\gamma$</li><li>定义残差向量$\mathbf{r}$为$\mathbf{r}=\mathbf{g} -\mathbf{H} \mathbf{\hat{f}}$，并且$\phi (\gamma ) = \mathbf{r} ^{T}\mathbf{r} =\left | \mathbf{r}  \right | ^2$</li><li>可以证明$\phi (\gamma )$是关于$\gamma$单调递增的函数，所以可以通过调整$\gamma$使得<ul><li>$\left | \mathbf{r}  \right | ^2=\left | \eta \right | ^2\pm a$ </li><li>其中，$a$是一个精确度因子(非常小)</li></ul></li><li>如何计算$\left | \eta \right | ^2$<ul><li>$\left | \eta \right | ^2=MN(\sigma_{\eta}^2+m_{\eta}^2)$ （$\left | \eta \right | ^2/MN$噪声随机变量平方的期望）</li><li>$\sigma_{\eta}^2=\frac{1}{MN}\sum_{X=0}^{M-1}\sum_{y=0}^{N-1}( \eta(x,y)-m_{ \eta})^2$ (方差)</li><li>$m_{ \eta}=\sum_{X=0}^{M-1}\sum_{y=0}^{N-1}\eta(x,y)$ （期望）</li></ul></li></ul><h2 id="彩色图像处理"><a href="#彩色图像处理" class="headerlink" title="彩色图像处理"></a>彩色图像处理</h2><h3 id="颜色空间及转换"><a href="#颜色空间及转换" class="headerlink" title="颜色空间及转换"></a>颜色空间及转换</h3><ul><li><p>RGB —&gt; NTSC (彩色图像 —&gt; 灰度图像)</p><script type="math/tex; mode=display">\left[    \begin{array}{c}   Y\\   I\\   Q  \end{array} \right]  \left[    \begin{array}{ccc}    0.299& 0.587 & 0.114\\    0.596&  -0.274& -0.322\\    0.211&  -0.523& 0.312  \end{array} \right]  \left[    \begin{array}{c}  R\\  G\\  B  \end{array} \right]</script><ul><li>Y表示亮度信息，I和Q表示颜色信息</li></ul></li><li><p>NTSC —&gt; RGB</p><script type="math/tex; mode=display">\left[    \begin{array}{c} R\\ G\\ B\end{array} \right]=\left[    \begin{array}{ccc}  1.000& 0.956& 0.621\\  1.000&  -0.272& -0.647\\  1.000&  -1.106& 1.703\end{array} \right]\left[    \begin{array}{c} Y\\ I\\ Q\end{array} \right]</script></li><li><p>RGB —&gt; YCbCr (用于编码数字图像)</p><script type="math/tex; mode=display">\left[    \begin{array}{c} Y\\ Cb\\ Cr\end{array} \right]=\left[    \begin{array}{c} 16\\ 128\\ 128\end{array} \right]\left[    \begin{array}{ccc}  65.481& 128.553 & 24.966\\  -37.797&  -74.203& 112.000\\  112.000&  -93.786& -18.214\end{array} \right]\left[    \begin{array}{c}R\\G\\B\end{array} \right]/256(about)</script><ul><li>Y通道: 表示图像的强度、亮度（luminance）</li><li>Cb通道： 表示图像蓝色 色度（chroma、chrominance）</li><li>Cr通道： 表示图像红色 色度（chroma、chrominance）</li><li>人眼对亮度更加敏感，因此如果保证亮度不变，轻微减少色彩通道的信息，人眼感官上图像质量并不会下降。因此可以通过减少色彩信息的方式来减少存储空间。</li></ul></li><li><p>HSV</p><ul><li>Hue（色调、色相）</li><li>Saturation（饱和度、色彩纯净度）</li><li>Value（强度）</li><li>越靠近中心饱和度越低，白光越多</li><li>角度决定色调</li><li>六边形的大小决定了亮度和强度的大小</li></ul></li><li><p>CMY</p><script type="math/tex; mode=display">\left[    \begin{array}{c} C\\ M\\ Y\end{array} \right]=\left[    \begin{array}{c}  1\\  1\\  1\end{array} \right]-\left[    \begin{array}{c}R\\G\\B\end{array} \right]</script><ul><li>RGB的补空间</li><li>用于彩色打印机</li></ul></li><li><p>HSI</p><ul><li>Hue（色调、色相）</li><li>Saturation（饱和度、色彩纯净度）</li><li>Intensity（颜色的明亮程度）</li><li>HSI是指一个数字图像的模型，它反映了人的视觉系统感知彩色的方式，以色调、饱和度和亮度三种基本特征量来感知颜色。HSI模型的建立基于两个重要的事实：</li><li>第一个，分量与图像的彩色信息无关；</li><li>第二个，H和S分量与人感受颜色的方式是紧密相联的。这些特点使得HSI模型非常适合彩色特性检测与分析。</li></ul></li></ul><h3 id="彩色图像处理-1"><a href="#彩色图像处理-1" class="headerlink" title="彩色图像处理"></a>彩色图像处理</h3><ul><li>令$c$表示RGB彩色空间的一个任意向量<ul><li><script type="math/tex; mode=display">c=\left[    \begin{array}{c} cr\\ cg\\ cb\end{array} \right]=\left[    \begin{array}{c} R\\ G\\ B\end{array} \right]</script></li></ul></li><li>$c$的分量仅是一副彩色图像在一点处的RGB分量<ul><li><script type="math/tex; mode=display">c(x,y)=\begin{bmatrix} cr(x,y)\\ cg(x,y)\\ cb(x,y)\end{bmatrix}=\begin{bmatrix} R(x,y)\\ G(x,y)\\ B(x,y)\end{bmatrix}</script></li></ul></li><li>多通道独立处理<ul><li>$s_i=T_i(r_i),\ i=1,2,…,n$</li><li>对$n$个通道单独处理然后合在一起</li></ul></li><li>伪彩色处理<ul><li>$s_i=T_i(r),\ i=1,2,…,n$</li><li>将灰度图像变为彩色图像</li></ul></li><li>插值映射函数</li></ul><p><strong>彩色图像的空域滤波</strong></p><ol><li>提取各颜色通道</li><li>对图像的各个组成部分分别滤波</li><li>重建</li></ol><p><strong>彩色图像的锐化</strong></p><ul><li><p>采用拉普拉斯滤波器</p><script type="math/tex; mode=display">\bigtriangledown ^2c(x,y)=\begin{bmatrix}  \bigtriangledown ^2R(x,y)\\  \bigtriangledown ^2G(x,y)\\  \bigtriangledown ^2B(x,y) \end{bmatrix}</script></li></ul><p><strong>彩色图像的边缘检测</strong></p><ul><li><p>使用梯度进行彩色边缘检测：</p><ul><li>梯度：<script type="math/tex">\bigtriangledown ^2f=\begin{bmatrix}  G_x\\  G_y\end{bmatrix}=\begin{bmatrix}  \frac{\partial f}{\partial x} \\  \frac{\partial f}{\partial y} \end{bmatrix}</script></li><li>幅值：<script type="math/tex">\left | \bigtriangledown f \right | = mag(\bigtriangledown f)=\sqrt{G_x^{2}+G_y^{2}}=\sqrt{\left ( \frac{\partial f}{\partial x}  \right )^2+ \left ( \frac{\partial f}{\partial y}  \right )^2}</script></li><li><p>幅角：<script type="math/tex">\alpha (x,y)=\arctan\left ( \frac{G_x}{G_y}  \right )</script></p></li><li><p>偏导数的计算(Sobel算子)</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/sobel.png" alt=""></p></li></ul></li><li><p>$r,g,b$是沿着$R,G,B$轴的单位向量，令</p><ul><li><script type="math/tex; mode=display">u=\frac{\partial R}{\partial x} r+\frac{\partial G}{\partial x} g+\frac{\partial B}{\partial x}b</script></li><li><script type="math/tex; mode=display">v=\frac{\partial R}{\partial y} r+\frac{\partial G}{\partial y} g+\frac{\partial B}{\partial y}b</script></li></ul></li><li><p>定义数量</p><ul><li><script type="math/tex; mode=display">g_{xx}=u\cdot u=u^{T}u=\left ( \frac{\partial R}{\partial x}  \right ) ^2+\left ( \frac{\partial G}{\partial x}  \right ) ^2+\left ( \frac{\partial B}{\partial x}  \right ) ^2</script></li><li><script type="math/tex; mode=display">g_{yy} = v\cdot v=v^{T}v=\left ( \frac{\partial R}{\partial y}  \right ) ^2+\left ( \frac{\partial G}{\partial y}  \right ) ^2+\left ( \frac{\partial B}{\partial y}  \right ) ^2</script></li><li><script type="math/tex; mode=display">g_{xy}=u\cdot v=u^{T}v= \frac{\partial R}{\partial x}  \frac{\partial R}{\partial y}  +\frac{\partial G}{\partial x}\frac{\partial G}{\partial y} +\frac{\partial B}{\partial x} \frac{\partial B}{\partial y}</script></li></ul></li><li><p>角度即为$c(x,y)$最大改变率的方向</p><ul><li><script type="math/tex; mode=display">\theta (x,y) = \frac{1}{2}\arctan \left ( \frac{2g_{xy}}{g_{xx}-g_{yy}}  \right )</script></li></ul></li><li><p>对应的变化率的值为</p><ul><li><script type="math/tex; mode=display">F_{\theta}(x,y)=\sqrt{\frac{1}{2}\left ( (g_{xx}+g_{yy})+ (g_{xx}-g_{yy})\cos 2\theta +2g_{x,y}\sin 2\theta \right )  }</script></li></ul></li></ul><p><strong>彩色图像的分割</strong></p><ul><li><p>RGB向量空间中的图像分割</p></li><li><script type="math/tex; mode=display">D(z,m)=\left \| z-m \right \|=\sqrt{(z-m)^{T}(z-m)}=\sqrt{(z_R-m_R)^2+(z_G-m_G)^2+(z_B-m_B)^2}</script><ul><li>欧式距离</li><li>三个坐标轴的量纲一致</li></ul></li><li><p>上面等式的一个有用推广是如下形式的距离度量</p><ul><li><script type="math/tex; mode=display">D(z,m)=\sqrt{(z-m)^{T}C^{-1}(z-m)}</script></li><li>马氏距离</li><li>$C$为样本的协方差矩阵(半正定)</li></ul></li></ul><h2 id="小波和多分辨率处理"><a href="#小波和多分辨率处理" class="headerlink" title="小波和多分辨率处理"></a>小波和多分辨率处理</h2><h3 id="小波变换-wavelet-transform"><a href="#小波变换-wavelet-transform" class="headerlink" title="小波变换 (wavelet transform)"></a>小波变换 (wavelet transform)</h3><p><a href="https://users.rowan.edu/~polikar/WTtutorial.html">https://users.rowan.edu/~polikar/WTtutorial.html</a></p><p><a href="https://www.bilibili.com/video/BV1dv411371B/?spm_id_from=333.788">https://www.bilibili.com/video/BV1dv411371B/?spm_id_from=333.788</a></p><p><strong>傅里叶变换的局限性和短时傅里叶变换 (STFT)</strong></p><ul><li>Decomposes the signal $f(t)$ in infinite number of sine/ cosine waves (harmonics).</li><li>No means of identifying exactly where an event occurs</li><li>Does not cope well with discontinous(不连续), bursts of signals(突变) e.g. video, music etc.</li></ul><p>平稳信号</p><ul><li>Signal with frequency content unchanged in time</li><li>All frequency compontents exits at all the time</li></ul><p>非平稳信号</p><ul><li>Frequency component changes in time</li><li>One example: the “Chirp Singnal”</li></ul><p>短时傅里叶变换 (Short-Time Fourier Transform)</p><ul><li>To analyze only a small section of the signal at a time</li><li><p>A technique called <em>Windowing the signal</em></p></li><li><p>The Segment of signal is assumed stationary</p></li><li><script type="math/tex; mode=display">STFT_{x}^{\omega}({t}' ,\omega)=\int _{t}\left ( x(t)W(t-{t}' ) \right )e^{-j\omega t}dt</script></li></ul><p>短时傅里叶变换的缺点</p><ul><li>unchanged window</li><li>Dilemma of resolution<ul><li>narrow window (good time resolution) —&gt; poor frequency resolution.</li><li>wide window (poor time resolution) —&gt; good frequency resolution.</li></ul></li></ul><p><strong>小波理论</strong></p><ul><li>A Wavelet is a waveform of effectively limited  duration that has an average value of zero. It is defined as<ul><li><script type="math/tex; mode=display">\psi_{a,b}(t)=\frac{1}{\sqrt{a} } \psi\left ( \frac{t-b}{a}  \right )\ a,b \in R</script></li><li>Here $a$ and $b$ are called Dilation (Scale) ane Translation (Position) parameters respectively.</li><li>$a$ 控制小波左右拉伸 (a和频率负相关 )，$b$控制左右移动</li></ul></li></ul><p><strong>连续小波变换 Continuous Wavelet Transform (CWT)</strong></p><ul><li>The continuous Wavelet Transform (CWT) of a signal $f(t)$ is then given by the equation,<ul><li><script type="math/tex; mode=display">CWT(a,b) = \left \langle f,\psi_{a,b} \right \rangle = \frac{1}{\sqrt{a} } \int_{-\infty }^{+\infty } f(t)\psi^{*}\left ( \frac{t-b}{a}  \right )dt</script></li></ul></li><li>The results of the CWT are many wavelet coefficients, which are a function of a (scale) ane $b$ (position).</li></ul><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/连续小波.png" alt=""></p><p><strong>Discrete Wavlet Transform (DWT)</strong></p><ul><li><p>In CWT, claculating wavelet coefficients at every possible scale is a fair amount of work, and it generates an awful lot of data.</p></li><li><p>If scales ($a$) and position ($b$) are chosen to be discrete then analysis will be much easier and will not generate the huge data. </p></li><li><p>This idea of choosing discrete values of dilation ($a$) and translation ($b$) parameters is implemented in,</p><ul><li>Redundant Wavelet Transform (Frames) 冗余小波变换</li><li>Orthonormal bases for wavelets or Multi Resolution Analysis (MRA) 小波正交基/多解析度分析</li></ul></li><li><p><strong>Multi Resolution Analysis (MRA)</strong> — 常用、高效</p><ul><li>If scales and positions are chosen based on powers of two, so-called Dyadic scales and positions, then analysis becomes much more efficient and just as accurate.</li><li>Scaling: $2^{j}\ (j=1,2,3,4,…)$</li><li>Translation: $2^{j}m\ (m=1,2,3,4,…)$</li><li>$j$：离散的分解水平（层数）</li><li><p>DWT：分成两个部分</p><ul><li>approximation coefficients: CA (high scale, low frequency)</li><li>detail coefficients: CD (low scale, high frequency)</li></ul></li><li><p>It was developed in 1988 by S. Mallat. For some very special choice of $\psi (k)$ and $a_0,\ b_0$, the $\psi_{m,n} (k)$ constitute an orthonormal basis for $\mathbb{L}^{2}(\mathbb{R})$</p></li><li>In particular, if $a_0=2,\ b_0=1$, then there exist $\psi(k)$ with good time-frequency localization properties, such that the,<ul><li>$\psi_{m,n}(k)=2^{m/2}\psi (2^{-m}k-n) \ m,n \in \mathbb{z}$, constitutes an orthonormal basis for $\mathbb{L}^{2}(\mathbb{R})$</li></ul></li><li>For a given function $f(k)$, the inner product $\left \langle f,\psi_{m,n} \right \rangle$ then gives the wavelet transform as<ul><li><script type="math/tex; mode=display">DWT(m,n) = \left \langle f,\psi_{m,n} \right \rangle = 2^{\frac{m}{2} }\sum_{k=-\infty }^{\infty} f(k)\psi^{*} (2^{-m}k-n)</script></li></ul></li></ul></li></ul><h3 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h3><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/图像金字塔1.png" alt=""></p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/图像金字塔2.png" alt=""></p><h3 id="子带编码"><a href="#子带编码" class="headerlink" title="子带编码"></a>子带编码</h3><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/子带编码.png" alt=""></p><p><strong>Z变换</strong></p><ul><li>$X(z)=\sum_{-\infty}^{+\infty}x(n)z^{-n}$，其中$z$是一个复变量<ul><li>$Z$变换是离散傅里叶变换的推广形式</li></ul></li><li><p>信号下采样的Z变换</p><ul><li>$x_{down}(n)=x(2n) \Leftrightarrow  X_{down}(z)=\frac{1}{2}(X(z^\frac{1}{2})+X(-z^\frac{1}{2}))$</li></ul></li><li><p>信号上采样的Z变换 (填0处理)</p><ul><li><script type="math/tex; mode=display">x^{up}(n)=\left\{\begin{matrix} x(\frac{n}{2}),\ n=0,2,4,...\\0,otherwise\end{matrix}\right.\Leftrightarrow X^{up}(z)=X(z^{2})</script></li></ul></li><li><p>因此，一个信号经下采样与上采样(填0处理)后对应信号的Z变换为</p><ul><li>$\hat{X}(z)=\frac{1}{2}\left ( X(z) + X(-z) \right )  $</li></ul></li><li>其中 <script type="math/tex">\left\{\begin{matrix}  &\hat{x}(n)=Z^{-1}\hat{X}(z)   \\  &Z^{-1}\hat{X}(-z)=(-1)^{n}\hat{x}(n)  \end{matrix}\right.</script><ul><li>$Z^{-1}$表示$Z$变换的逆变换</li></ul></li></ul><p>一个双子带编码和解码系统表示为</p><script type="math/tex; mode=display">\begin{align}\hat{X}(z) & = \frac{1}{2}G_0(z)\left ( H_0(z)X(z) + H_0(-z)X(-z) \right ) +\frac{1}{2}G_1(z)\left ( H_1(z)X(z) + H_1(-z)X(-z) \right )\\&=\frac{1}{2}X(z)\left ( H_0(z)G_0(z) + H_1(z)G_1(z) \right ) +\frac{1}{2}X(-z)\left ( H_0(-z)G_0(-z) + H_1(-z)G_1(-z) \right )\end{align}</script><ul><li><p>为了对输入进行无失真重建，可施加如下条件：</p><ul><li>$ H_0(-z)G_0(-z) + H_1(-z)G_1(-z)=0$</li><li>$ H_0(z)G_0(z) + H_1(z)G_1(z)=2$</li></ul></li><li><p>将上式合并为一个矩阵表达式</p><ul><li><script type="math/tex; mode=display">\begin{bmatrix} G_0(z)\\ G_1(z)\end{bmatrix}\mathbf{H} _m(z)=\begin{bmatrix}2&0\end{bmatrix}</script></li><li><p>$\mathbf{H} _m(z)$称为分析调制矩阵</p><script type="math/tex; mode=display">\mathbf{H} _m(z)=\begin{bmatrix}H_0(z)&H_0(-z)\\H_1(z)&H_1(-z)\end{bmatrix}</script></li></ul></li><li><p>假定$\mathbf{H} _m(z)$为非奇异矩阵，可得：</p><p><script type="math/tex">\begin{bmatrix} G_0(z)\\ G_1(z)\end{bmatrix}=\frac{2}{\det (\mathbf{H} _m(z))} \begin{bmatrix}H_1(-z)\\-H_0(-z)\end{bmatrix}</script> (克莱姆法则)</p></li></ul><p>完美重建滤波器组(<em>PCFB</em>)的特性 — 交叉调制</p><ul><li><p>由上式可知$G_0(z)$是$H_1(-z)$的函数，$G_1(z)$是$H_0(-z)$的函数。因此分析与综合滤波器是交叉调制的</p></li><li><p>对于有限脉冲响应滤波器(Finite Pulse Response Filter, FIR)，分析调制矩阵$\mathbf{H} _m(z)$的行列式值是一个纯延时</p><ul><li>$\det (\mathbf{H} _m(z))=\alpha z^{-(2k+1)}$</li></ul></li><li><p>若忽略掉对应$z^{-(2k+1)}$的时间延迟，且令$\alpha=2$，对等式两边取$Z$变换的逆变换，可得</p><ul><li>$g_0(n)=(-1)^nh_1(n)$</li><li>$g_1(n)=(-1)^{n+1}h_0(n)$  ($Z^{-1}\hat{X}(-z)=(-1)^{n}\hat{x}(n)$)</li></ul></li><li><p>因此，有限脉冲响应综合滤波器是分析滤波器的交叉调制版本并且有且只有一个与分析滤波器方向相反</p></li></ul><p>完美重建滤波器组(<em>PCFB</em>)的特性 — 双正交性</p><ul><li><p>令$P(z)$表示低通分析滤波器和综合滤波器传递函数的乘积，有</p><script type="math/tex; mode=display">P(z)=G_0(z)H_0(z)=\frac{2}{\det (\mathbf{H} _m(z))}H_0(z)H_1(-z)</script></li><li><p>由于$\color{red} \det (\mathbf{H} _m(z)) = -\det (\mathbf{H} _m(-z))$，乘积$G_1(z)H_1(z)$同样可以被定义为：</p><script type="math/tex; mode=display">G_1(z)H_1(z)=P(-z)=G_0(-z)H_0(-z)</script><ul><li><script type="math/tex; mode=display">\mathbf{H} _m(-z)=\begin{bmatrix}H_0(-z)&H_0(z)\\H_1(-z)&H_1(z)\end{bmatrix}</script></li><li>两列互换行列式的值互为相反数</li></ul></li><li><p>因此$G_1(z)H_1(z)=\frac{2}{\det (\mathbf{H} _m(z))}H_0(z)H_1(-z)=P(-z)$。将其代入$ H_0(z)G_0(z) + H_1(z)G_1(z)=2$可得</p><ul><li><script type="math/tex; mode=display">G_0(z)H_0(z)+G_0(-z)H_0(-z)=2</script></li></ul></li><li><p>对等式$G_0(z)H_0(z)+G_0(-z)H_0(-z)=2$的两边进行反$Z$变换可得</p><ul><li>$\sum_{k}g_0(k)h_0(n-k)+(-1)^{n}\sum_{k}g_0(k)h_0(n-k)=2\delta(n)$</li></ul></li><li><p>由于奇次方项相互抵消 ($n$只能取偶数)，上式可简化为</p><ul><li>$\sum_{k}g_0(k)h_0(2n-k)=\left \langle g_0(k),h_0(2n-k) \right \rangle =\delta(n)$</li></ul></li><li><p>同理可得</p><ul><li>$\left \langle g_1(k),h_1(2n-k) \right \rangle =\delta(n)$</li><li>$\left \langle g_0(k),h_1(2n-k) \right \rangle =0$</li><li>$\left \langle g_1(k),h_0(2n-k) \right \rangle =0$</li></ul></li><li><p>可以得到更具有普遍意义的表达式</p><ul><li>$\left \langle h_i(2n-k), g_j(k) \right \rangle =\delta(i-j)\delta(n)\ i,j = {0,1}$</li></ul></li><li><p>满足下列条件的滤波器组称为具有双正交性：</p><ul><li>$\left \langle h_i(2n-k), g_j(k) \right \rangle =\delta(i-j)\delta(n)\ i,j = {0,1}$</li></ul></li><li><p>所有两频段实系数的完美重建滤波器组的分析和综合滤波器的冲激响应服从双正交约束</p></li><li><p>双正交FIR滤波器的例子包括双正交spline族和双正交coiflet族</p></li><li><p>除了双正交性外，完么重建滤波器组的正交性定义为</p><ul><li>$\left \langle  g_i(n) , g_i(n+2m)\right \rangle =\delta(i-j)\delta(m)\ i,j = {0,1}$</li></ul></li><li><p>可见，$G_1$与低通综合滤波器$G_0$的联系在于调制、时域反转或奇数平移。此外，$H_1$和$H_0$分别是响应综合滤波器$G_0$和$G_1$的时域反转。</p></li><li><p>$Z$变换的另外两个重要性质</p><ul><li>$x(-n)\Leftrightarrow X(z^{-1})$ </li><li>$x(n-k)\Leftrightarrow z^{-k}X(z)$</li></ul></li></ul><p>用于图像的二维子带滤波器</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/二维子带滤波器1.png" alt=""></p><ul><li>图中滤波后的输出结果$a(m,n),d^{V}(m,n),d^{H}(m,n)$和$d^{D}(m,n)$分别称为图像的近似值子带、垂直细节子带、水平细节子带和对角线细节子带。</li><li>一个或多个这样的子带可被进一步分为4个更小的子带，以此类推</li></ul><p>例：Daubechies正交滤波器</p><p><img src="/2022/08/11/shu-zi-tu-xiang-chu-li-xue-xi-bi-ji/正交滤波器.png" alt=""></p><h3 id="哈尔变换"><a href="#哈尔变换" class="headerlink" title="哈尔变换"></a>哈尔变换</h3><ul><li><p>哈尔变换的基函数是周所周知的最古老也最简单的正交小波</p></li><li><p>哈尔变换本身具有对称性和可分离性，可以用下述矩阵形式表达</p><ul><li><script type="math/tex; mode=display">\mathbf{T} =\mathbf{HFH}^ {T}</script></li><li>其中，$\mathbf{F}$是一个$N\times N$图像矩阵，$\mathbf{H}$是一个$N\times N$的变换矩阵，$\mathbf{T}$是变换的结果矩阵</li></ul></li><li><p>变换矩阵$\mathbf{H}$包含基函数$h_k(z)$ (对应$\mathbf{H}$中的一行)，它们定义在连续闭区间$z\in [0,1]$上，其中$k=0,…,N-1$且$N=2^{n}$。</p></li><li><p>为了生成矩阵$\mathbf{H}$，定义整数$k=2^{p}+q-1$，$0 \le p \le N-1$且当$p=0$时，$q=0$或$q=1$；当$p \neq 0$时，$1 \le q \le 2^{p}$。则基函数为</p><ul><li><script type="math/tex; mode=display">h_0(z)=h_{00}(z)=\frac{1}{\sqrt{z}},\ z\in [0,1]</script><script type="math/tex; mode=display">h_k(z)=h_{pq}(z)=\frac{1}{\sqrt{N}}\left\{\begin{matrix}2^{p/2},\ (q-1)/2^{p} \le z < (q-0.5)/2^{p} \\-2^{p/2},\ (q-0.5)/2^{p} \le z < (q)/2^{p}\\0,\  其他,\ z \in [0,1]\end{matrix}\right.</script></li><li><p>例：$k=21$，对应二进制 10101，则$p=4, q=6$</p></li><li><p>$k=0$对应$p=0,\ q=0$</p></li><li><p>$k=1$ 对应$p=0,\ q=1$</p></li><li><p>$p$决定了脉冲的宽窄 ($p$越大越窄)，$q$决定了正脉冲的起始位置</p></li></ul></li></ul><h3 id="多分辨率分析"><a href="#多分辨率分析" class="headerlink" title="多分辨率分析"></a>多分辨率分析</h3><ul><li>在多分辨率展开(Multi-resolution analysis, MRA)中，尺度函数被用于建立某一函数或图像的一系列近似值，而被称为小波的函数用于对相邻近似值之间的差异进行编码</li><li>信号或函数$f(x)$常可分解为一系列展开函数的线性组合，即<ul><li>$f(x)=\sum_{k}\alpha_k\varphi_k(x)$</li></ul></li><li>如果这种展开是唯一的，也就是说对任何指定的$f(x)$，只有一个系数序列与之相对应，则$\varphi_k(x)$称为==基函数==，展开序列$\{\varphi_k(x)\}$称为可表示的函数类的基</li><li>可被表示的函数组成了一个函数空间，称为展开集合的闭合跨度，表示为：<ul><li>$V=\overline{Span_k\{\varphi_k(x)\}} $</li></ul></li></ul><p><strong>序列展开</strong></p><ul><li><p>对于任意的函数空间$V$及其相应的展开函数集合$\{\varphi_k(x)\}$，都存在一个对偶函数集$\{\tilde{\varphi}(x) \}$，通过计算其和$f(x)$的积分可得到系数$\{\alpha_k\}$，即</p><ul><li>$\alpha_k=\left \langle \tilde{\varphi}(x),f(x) \right \rangle = \int \tilde{\varphi}^{*}(x)f(x)dx$</li></ul></li><li><p>系数$\{\alpha_k\}$的计算包含了以下情况</p><ul><li><p><strong>情况1</strong>: 如果展开函数构成了$V$的一个正交基，即</p><p>​    <script type="math/tex">\left \langle \varphi_j(x), \varphi_k(x)\right \rangle  = \delta_{jk}=\begin{cases}0,\  j \neq k \\1 ,\ j=k\end{cases}</script></p><p>则基与它的对偶相等，因此</p><p>​    $\alpha_k=\left \langle \varphi(x),f(x) \right \rangle$</p></li><li><p>情况2：如果展开函数本身不正交，但却是$V$的一个正交基，即</p><p>​    <script type="math/tex">\left \langle \varphi_j(x), \varphi_k(x)\right \rangle  =0, j \neq k</script></p><p>​         且基函数与其对偶函数是双正交函数，即</p><p>​    <script type="math/tex">\left \langle \varphi_j(x), \tilde{\varphi}(x)_k(x)\right \rangle  = \delta_{jk}=\begin{cases}0,\  j \neq k \\1 ,\ j=k\end{cases}</script></p><p>那么</p><p>​    $\alpha_k=\left \langle \tilde{\varphi}(x),f(x) \right \rangle$</p></li></ul></li></ul><h2 id="形态学图像处理"><a href="#形态学图像处理" class="headerlink" title="形态学图像处理"></a>形态学图像处理</h2><ul><li><p>基本思想：用具有一定形态的结构元素去度量和提取图像中的对应形状以达到对图像分析和识别的目的</p></li><li><p>形态学图像处理的作用：可以简化图像数据，去除图像中不重要的结构，仅保持图像的基本形状特性</p></li><li>形态学图像处理的基本运算：膨胀、腐蚀、开启、闭合</li><li>二值图像形态学处理的运算对象是集合<ul><li>设A为像素集合，B为结构元素 (本身也是一个像素集合，其成员是感兴趣目标的像素)，其B和A进行操作</li></ul></li><li>B对A的具体操作<ul><li>通过让B在A上平移，以便使B的原点访问A的每一个元素，以此得到一个新的像素集合</li></ul></li><li>结构元素必须指定一个原点<ul><li>结构元素的原点是形态学运算的参考点 (当结构元素对称且未显示原点时，通常假定原点位于对称中心处)</li><li>注意：原点可以包含在结构元素中，也可以不包含在结构元素中 (结构元素原点的位置不同，运算结果也不同)</li></ul></li><li>在实际处理中，只考虑图像和结构元素中有效像素点，即只考虑感兴趣的前景部分，背景部分不予考虑</li></ul><h3 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h3><ul><li>集合B的反射$\hat{B}$定义为$\hat{B}=\{w|w=-b,b \in B\}$，即关于原集合原点对称，即相对于原点旋转180$^{\text o}$</li><li>一个集合B的平移表示为$(B)_{z}$，定义如下<ul><li><script type="math/tex; mode=display">(B)_{z}=\{c|c=b+z, b \in B\}</script></li><li>其中$z=(z_1,z_2)$</li><li>如果$B$是描述图像中物体的像素的集合，则$(B)_{z}$是$B$中坐标值$(x,y)$被$(x+z_1,y+z_2)$替代的像素点的集合</li></ul></li></ul><h3 id="膨胀和腐蚀"><a href="#膨胀和腐蚀" class="headerlink" title="膨胀和腐蚀"></a>膨胀和腐蚀</h3><p><strong>膨胀：使图像扩大</strong></p><ul><li>$A$和$B$是两个集合，$A$被$B$膨胀定义为<ul><li>$A \oplus B=\{z|(\hat{B})_{z}\cap A\neq 0\}$ </li><li>上式表示：$B$的反射进行平移与$A$的交集不为空</li></ul></li><li>膨胀的另一种定义为<ul><li>$A \oplus B=\{z|(\hat{B})_{z}\cap A\subseteq A\}$ </li><li>上式表示：B的反射进行平移与A的交集是A的子集</li></ul></li></ul><p><strong>腐蚀：使图像缩小</strong></p><ul><li>$A$和$B$是两个集合，$A$被$B$腐蚀定义为<ul><li>$A \ominus  B=\{z|(B)_{z} \subseteq A\}$ </li></ul></li><li>使用腐蚀消除图像的细节部分，产生滤波器的作用</li><li>如果两个物体之间有细小的连通，那么当结构元素足够大时，通过腐蚀运算可以将两个物体分开</li></ul><h3 id="开操作和闭操作"><a href="#开操作和闭操作" class="headerlink" title="开操作和闭操作"></a>开操作和闭操作</h3><p><strong>开操作</strong>：使图像的轮廓变得光滑，断开狭窄的间断和消除细的突出物</p><ul><li>定义：设$A$为原始二值图像，$B$是结构元素，则使用结构元素$B$对集合$A$进行开启操作，定义为<ul><li>$A \circ  B=(A \ominus  B) \oplus B$</li><li>先用$B$对$A$腐蚀，然后用$B$对结果膨胀</li></ul></li><li>开操作的几何解释<ul><li>$B$在$A$的边界内转动时，$B$中的点所能到达的$A$的边界的的最远点</li><li>开操作的最终结果：原图像$A$方向向外的角边圆了，而方向向内的角则未受影响</li></ul></li><li>开操作的3条性质<ul><li>$A \circ  B$是$A$的子集合</li><li>如果$C$是$D$的子集，则$C \circ  B$是$D \circ  B$的子集</li><li>$(A \circ  B)\circ  B = A\circ  B$</li></ul></li></ul><p><strong>闭操作</strong>：同样使图像的轮廓变得光滑，但与开操作相反，它能消除狭窄的间断和长细的鸿沟，消除小的孔洞，并填补轮廓线中的裂痕</p><ul><li>使用结构元素$B$对集合$A$进行闭操作，定义为：<ul><li>$A \bullet   B=(A \oplus  B) \ominus B$</li><li>先用B对A膨胀，然后用B对结果腐蚀</li></ul></li><li>闭操作的几何解释<ul><li>B在A的边界外部转动</li><li>闭操作的最终结果：原图像$A$方向向内的角边圆了，而方向向外的角则未受影响</li></ul></li><li>闭操作的3条性质<ul><li>$A$是$A \bullet   B$是的子集合</li><li>如果$C$是$D$的子集，则$C \bullet  B$是$D \bullet  B$的子集</li><li>$(A \bullet  B) \bullet  B = A \bullet  B$</li></ul></li></ul><p><strong>先开操作再闭操作，构成噪声滤波器</strong></p><h3 id="形态学的主要应用"><a href="#形态学的主要应用" class="headerlink" title="形态学的主要应用"></a>形态学的主要应用</h3><p><strong>边界提取</strong>：图像$A$的边界$b(A)$定义为：$b(A)=A-(A \ominus  B)$</p><p><strong>击中与击不中变换</strong>：</p><ul><li><p><a href="https://www.cnblogs.com/a-runner/p/14136520.html">https://www.cnblogs.com/a-runner/p/14136520.html</a></p></li><li><p>作用：在二值图像中找到匹配</p></li><li><p>两个结构元素，记为$E$和$F$，构成结构元素对$B=(E,F)$，$E \cap F = \phi$</p></li><li>分别探测图像的内部和外部，$E$用于探测图像内部,作为击中部分；$F$用于探测图像外部,作为击不中部分，从而确定物体形状<ul><li>$A*B=(A\ominus E)\cap (A^{c}\ominus F)$</li></ul></li></ul><p><strong>孔洞填充</strong>：</p><ul><li>令$A$表示一个集合：其元素是一个8连通的边界，且每个边界包围一个孔洞</li><li>令$X_0$表示一个与$A$相同大小的二维阵列，其初始状态为：<ul><li>包含每个孔洞中的一个指定位置处的前景像素点</li><li>除了上述的前景像素点之外，其余元素均为背景像素点</li></ul></li><li>在给定$A$和$X_0$的前提下，采用前景像素填充$A$的所有孔洞的过程如下：<ul><li>$X_k=(X_{k-1}\oplus B)\cap A^{c}$</li></ul></li><li>在算法执行过程中，如果$X_k=X_{k-1}$，则迭代结束</li><li>集合$X_k$包含所有被填充的孔洞，$X_k$与$A$的并集则包含被填充的孔洞及其边界</li><li>在每一步运算中，膨胀结果与$A^{c}$的交集操作实现了将膨胀结果限制在ROI，即条件膨胀</li></ul><p><strong>连通分量的提取</strong>：</p><ul><li>令$Y$表示一个包含于集合$A$中的连通分量，并假设$Y$中的一个点$p$是已知的。用下列迭代式生成$Y$的所有元素<ul><li>$X_k=(X_{k-1}\oplus B)\cap A$</li></ul></li></ul><p><strong>骨架抽取：</strong></p><ul><li>骨架的概念<ul><li>图像的一种细化结构（图像中物体的骨骼部分），由物体的若干条细化的中轴线组成，描述了图像中物体的<strong>形状</strong>和<strong>方向</strong>信息</li></ul></li><li><p>骨架的作用</p><ul><li>通过骨架抽取可以简化图像中物体的信息而保留其同伦结构</li><li>有助于突出形状特点和减少冗余信息量</li></ul></li><li><p>骨架的定义 (最大内切圆概念)</p><ul><li>物体$A$的骨架由$A$内部所有的最大内切圆盘的圆心组成，骨架的每个点都对应一个相应的最大内切圆盘</li><li>其中，最大内切圆盘不是其他任何完全属于$A$的圆盘的子集，并且至少有两点与集合$A$的边界轮廓相切</li></ul></li><li><p>骨架抽取的实现</p><ul><li><p>对于集合$A$，一般用$S(A)$表示其骨架，可以使用腐蚀和开启操作来实现骨架的抽取，如下：</p><ul><li>$S(A)=\bigcup_{k=0}^{K} S_k(A)$</li><li>$S_k(A)=(A\ominus kB)-((A\ominus kB)\circ B)$</li></ul></li></ul></li><li><p>式中，$B$是一个结构元素，而$(A\ominus kB)$表示对$A$的连续$k$次腐蚀</p><ul><li>$(A\ominus kB)=((…((A\ominus B)\ominus B)\ominus B…)\ominus B)$</li><li>$K$是A被腐蚀为空集前的最后一次迭代步骤，即</li><li>$K=\max\{k|(A\ominus kB) \neq\phi  \}$</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
            <tag> 机器视觉 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
